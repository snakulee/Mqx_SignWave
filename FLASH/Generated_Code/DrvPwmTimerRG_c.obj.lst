   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"DrvPwmTimerRG.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.rodata.ChannelDevice,"a",%progbits
  18              		.align	2
  21              	ChannelDevice:
  22 0000 00       		.byte	0
  23 0001 01       		.byte	1
  24 0002 0000     		.section	.rodata.ChannelMode,"a",%progbits
  25              		.align	2
  28              	ChannelMode:
  29 0000 0000     		.space	2
  30 0002 0000     		.section	.bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  31              		.align	2
  34              	DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  35 0000 00000000 		.space	20
  35      00000000 
  35      00000000 
  35      00000000 
  35      00000000 
  36              		.section	.text.DrvPwmTimerRG_Init,"ax",%progbits
  37              		.align	2
  38              		.global	DrvPwmTimerRG_Init
  39              		.code	16
  40              		.thumb_func
  42              	DrvPwmTimerRG_Init:
  43              	.LFB0:
  44              		.file 1 "../Generated_Code/DrvPwmTimerRG.c"
   1:../Generated_Code/DrvPwmTimerRG.c **** /** ###################################################################
   2:../Generated_Code/DrvPwmTimerRG.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/DrvPwmTimerRG.c **** **     Filename    : DrvPwmTimerRG.c
   4:../Generated_Code/DrvPwmTimerRG.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/DrvPwmTimerRG.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/DrvPwmTimerRG.c **** **     Component   : TimerUnit_LDD
   7:../Generated_Code/DrvPwmTimerRG.c **** **     Version     : Component 01.139, Driver 01.09, CPU db: 3.00.000
   8:../Generated_Code/DrvPwmTimerRG.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/DrvPwmTimerRG.c **** **     Date/Time   : 2013-02-21, 16:27, # CodeGen: 12
  10:../Generated_Code/DrvPwmTimerRG.c **** **     Abstract    :
  11:../Generated_Code/DrvPwmTimerRG.c **** **          This TimerUnit component provides a low level API for unified hardware access across
  12:../Generated_Code/DrvPwmTimerRG.c **** **          various timer devices using the Prescaler-Counter-Compare-Capture timer structure.
  13:../Generated_Code/DrvPwmTimerRG.c **** **     Settings    :
  14:../Generated_Code/DrvPwmTimerRG.c **** **          Component name                                 : DrvPwmTimerRG
  15:../Generated_Code/DrvPwmTimerRG.c **** **          Module name                                    : TPM2
  16:../Generated_Code/DrvPwmTimerRG.c **** **          Counter                                        : TPM2_CNT
  17:../Generated_Code/DrvPwmTimerRG.c **** **          Counter direction                              : Up
  18:../Generated_Code/DrvPwmTimerRG.c **** **          Counter width                                  : 16 bits
  19:../Generated_Code/DrvPwmTimerRG.c **** **          Value type                                     : Optimal
  20:../Generated_Code/DrvPwmTimerRG.c **** **          Input clock source                             : Internal
  21:../Generated_Code/DrvPwmTimerRG.c **** **            Counter frequency                            : 24 MHz
  22:../Generated_Code/DrvPwmTimerRG.c **** **          Counter restart                                : On-overrun
  23:../Generated_Code/DrvPwmTimerRG.c **** **            Overrun period                               : 2.730667 ms
  24:../Generated_Code/DrvPwmTimerRG.c **** **            Interrupt                                    : Enabled
  25:../Generated_Code/DrvPwmTimerRG.c **** **              Interrupt                                  : INT_TPM2
  26:../Generated_Code/DrvPwmTimerRG.c **** **              Interrupt priority                         : medium priority
  27:../Generated_Code/DrvPwmTimerRG.c **** **          Channel list                                   : 2
  28:../Generated_Code/DrvPwmTimerRG.c **** **            Channel 0                                    : 
  29:../Generated_Code/DrvPwmTimerRG.c **** **              Mode                                       : Compare
  30:../Generated_Code/DrvPwmTimerRG.c **** **                Compare                                  : TPM2_C0V
  31:../Generated_Code/DrvPwmTimerRG.c **** **                Offset                                   : 0 timer-ticks
  32:../Generated_Code/DrvPwmTimerRG.c **** **                Output on compare                        : Set
  33:../Generated_Code/DrvPwmTimerRG.c **** **                  Output on overrun                      : Clear
  34:../Generated_Code/DrvPwmTimerRG.c **** **                  Initial state                          : Low
  35:../Generated_Code/DrvPwmTimerRG.c **** **                  Output pin                             : TSI0_CH11/PTB18/TPM2_CH0
  36:../Generated_Code/DrvPwmTimerRG.c **** **                  Output pin signal                      : 
  37:../Generated_Code/DrvPwmTimerRG.c **** **                Interrupt                                : Enabled
  38:../Generated_Code/DrvPwmTimerRG.c **** **                  Interrupt                              : INT_TPM2
  39:../Generated_Code/DrvPwmTimerRG.c **** **                  Interrupt priority                     : medium priority
  40:../Generated_Code/DrvPwmTimerRG.c **** **            Channel 1                                    : 
  41:../Generated_Code/DrvPwmTimerRG.c **** **              Mode                                       : Compare
  42:../Generated_Code/DrvPwmTimerRG.c **** **                Compare                                  : TPM2_C1V
  43:../Generated_Code/DrvPwmTimerRG.c **** **                Offset                                   : 21845 timer-ticks
  44:../Generated_Code/DrvPwmTimerRG.c **** **                Output on compare                        : Set
  45:../Generated_Code/DrvPwmTimerRG.c **** **                  Output on overrun                      : Clear
  46:../Generated_Code/DrvPwmTimerRG.c **** **                  Initial state                          : Low
  47:../Generated_Code/DrvPwmTimerRG.c **** **                  Output pin                             : TSI0_CH12/PTB19/TPM2_CH1
  48:../Generated_Code/DrvPwmTimerRG.c **** **                  Output pin signal                      : 
  49:../Generated_Code/DrvPwmTimerRG.c **** **                Interrupt                                : Disabled
  50:../Generated_Code/DrvPwmTimerRG.c **** **          Initialization                                 : 
  51:../Generated_Code/DrvPwmTimerRG.c **** **            Enabled in init. code                        : yes
  52:../Generated_Code/DrvPwmTimerRG.c **** **            Auto initialization                          : no
  53:../Generated_Code/DrvPwmTimerRG.c **** **            Event mask                                   : 
  54:../Generated_Code/DrvPwmTimerRG.c **** **              OnCounterRestart                           : Enabled
  55:../Generated_Code/DrvPwmTimerRG.c **** **              OnChannel0                                 : Enabled
  56:../Generated_Code/DrvPwmTimerRG.c **** **              OnChannel1                                 : Disabled
  57:../Generated_Code/DrvPwmTimerRG.c **** **              OnChannel2                                 : Disabled
  58:../Generated_Code/DrvPwmTimerRG.c **** **              OnChannel3                                 : Disabled
  59:../Generated_Code/DrvPwmTimerRG.c **** **              OnChannel4                                 : Disabled
  60:../Generated_Code/DrvPwmTimerRG.c **** **              OnChannel5                                 : Disabled
  61:../Generated_Code/DrvPwmTimerRG.c **** **              OnChannel6                                 : Disabled
  62:../Generated_Code/DrvPwmTimerRG.c **** **              OnChannel7                                 : Disabled
  63:../Generated_Code/DrvPwmTimerRG.c **** **          CPU clock/configuration selection              : 
  64:../Generated_Code/DrvPwmTimerRG.c **** **            Clock configuration 0                        : This component enabled
  65:../Generated_Code/DrvPwmTimerRG.c **** **            Clock configuration 1                        : This component disabled
  66:../Generated_Code/DrvPwmTimerRG.c **** **            Clock configuration 2                        : This component disabled
  67:../Generated_Code/DrvPwmTimerRG.c **** **            Clock configuration 3                        : This component disabled
  68:../Generated_Code/DrvPwmTimerRG.c **** **            Clock configuration 4                        : This component disabled
  69:../Generated_Code/DrvPwmTimerRG.c **** **            Clock configuration 5                        : This component disabled
  70:../Generated_Code/DrvPwmTimerRG.c **** **            Clock configuration 6                        : This component disabled
  71:../Generated_Code/DrvPwmTimerRG.c **** **            Clock configuration 7                        : This component disabled
  72:../Generated_Code/DrvPwmTimerRG.c **** **     Contents    :
  73:../Generated_Code/DrvPwmTimerRG.c **** **         Init            - LDD_TDeviceData* DrvPwmTimerRG_Init(LDD_TUserData *UserDataPtr);
  74:../Generated_Code/DrvPwmTimerRG.c **** **         Deinit          - void DrvPwmTimerRG_Deinit(LDD_TDeviceData *DeviceDataPtr);
  75:../Generated_Code/DrvPwmTimerRG.c **** **         Enable          - LDD_TError DrvPwmTimerRG_Enable(LDD_TDeviceData *DeviceDataPtr);
  76:../Generated_Code/DrvPwmTimerRG.c **** **         Disable         - LDD_TError DrvPwmTimerRG_Disable(LDD_TDeviceData *DeviceDataPtr);
  77:../Generated_Code/DrvPwmTimerRG.c **** **         GetCounterValue - DrvPwmTimerRG_TValueType DrvPwmTimerRG_GetCounterValue(LDD_TDeviceData
  78:../Generated_Code/DrvPwmTimerRG.c **** **         SetOffsetTicks  - LDD_TError DrvPwmTimerRG_SetOffsetTicks(LDD_TDeviceData *DeviceDataPtr
  79:../Generated_Code/DrvPwmTimerRG.c **** **         GetOffsetTicks  - LDD_TError DrvPwmTimerRG_GetOffsetTicks(LDD_TDeviceData *DeviceDataPtr
  80:../Generated_Code/DrvPwmTimerRG.c **** **
  81:../Generated_Code/DrvPwmTimerRG.c **** **     Copyright : 1997 - 2012 Freescale, Inc. All Rights Reserved.
  82:../Generated_Code/DrvPwmTimerRG.c **** **     
  83:../Generated_Code/DrvPwmTimerRG.c **** **     http      : www.freescale.com
  84:../Generated_Code/DrvPwmTimerRG.c **** **     mail      : support@freescale.com
  85:../Generated_Code/DrvPwmTimerRG.c **** ** ###################################################################*/
  86:../Generated_Code/DrvPwmTimerRG.c **** 
  87:../Generated_Code/DrvPwmTimerRG.c **** /* MODULE DrvPwmTimerRG. */
  88:../Generated_Code/DrvPwmTimerRG.c **** 
  89:../Generated_Code/DrvPwmTimerRG.c **** #include "Events.h"
  90:../Generated_Code/DrvPwmTimerRG.c **** #include "DrvPwmTimerRG.h"
  91:../Generated_Code/DrvPwmTimerRG.c **** /* MQX Lite include files */
  92:../Generated_Code/DrvPwmTimerRG.c **** #include "mqxlite.h"
  93:../Generated_Code/DrvPwmTimerRG.c **** #include "mqxlite_prv.h"
  94:../Generated_Code/DrvPwmTimerRG.c **** #include "IO_Map.h"
  95:../Generated_Code/DrvPwmTimerRG.c **** 
  96:../Generated_Code/DrvPwmTimerRG.c **** /* List of channels used by component */
  97:../Generated_Code/DrvPwmTimerRG.c **** static const uint8_t ChannelDevice[DrvPwmTimerRG_NUMBER_OF_CHANNELS] = {0x00U,0x01U};
  98:../Generated_Code/DrvPwmTimerRG.c **** 
  99:../Generated_Code/DrvPwmTimerRG.c **** /* Table of channels mode / 0 - compare mode, 1 - capture mode */
 100:../Generated_Code/DrvPwmTimerRG.c **** static const uint8_t ChannelMode[DrvPwmTimerRG_NUMBER_OF_CHANNELS] = {0x00U,0x00U};
 101:../Generated_Code/DrvPwmTimerRG.c **** 
 102:../Generated_Code/DrvPwmTimerRG.c **** 
 103:../Generated_Code/DrvPwmTimerRG.c **** typedef struct {
 104:../Generated_Code/DrvPwmTimerRG.c ****   LDD_RTOS_TISRVectorSettings SavedISRSettings_TUInterrupt; /* {MQXLite RTOS Adapter} Saved setting
 105:../Generated_Code/DrvPwmTimerRG.c ****   LDD_TEventMask EnEvents;             /* Enable/Disable events mask */
 106:../Generated_Code/DrvPwmTimerRG.c ****   uint32_t Source;                     /* Current source clock */
 107:../Generated_Code/DrvPwmTimerRG.c ****   LDD_TUserData *UserDataPtr;          /* RTOS device data structure */
 108:../Generated_Code/DrvPwmTimerRG.c **** } DrvPwmTimerRG_TDeviceData;
 109:../Generated_Code/DrvPwmTimerRG.c **** 
 110:../Generated_Code/DrvPwmTimerRG.c **** typedef DrvPwmTimerRG_TDeviceData *DrvPwmTimerRG_TDeviceDataPtr; /* Pointer to the device data stru
 111:../Generated_Code/DrvPwmTimerRG.c **** 
 112:../Generated_Code/DrvPwmTimerRG.c **** /* {MQXLite RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
 113:../Generated_Code/DrvPwmTimerRG.c **** static DrvPwmTimerRG_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 114:../Generated_Code/DrvPwmTimerRG.c **** 
 115:../Generated_Code/DrvPwmTimerRG.c **** #define AVAILABLE_EVENTS_MASK (LDD_TEventMask)(LDD_TIMERUNIT_ON_CHANNEL_0 | LDD_TIMERUNIT_ON_COUNTE
 116:../Generated_Code/DrvPwmTimerRG.c **** #define AVAILABLE_PIN_MASK (LDD_TPinMask)(DrvPwmTimerRG_CHANNEL_0_PIN | DrvPwmTimerRG_CHANNEL_1_PIN
 117:../Generated_Code/DrvPwmTimerRG.c **** #define LAST_CHANNEL 0x01U
 118:../Generated_Code/DrvPwmTimerRG.c **** 
 119:../Generated_Code/DrvPwmTimerRG.c **** /* Internal method prototypes */
 120:../Generated_Code/DrvPwmTimerRG.c **** /*
 121:../Generated_Code/DrvPwmTimerRG.c **** ** ===================================================================
 122:../Generated_Code/DrvPwmTimerRG.c **** **     Method      :  DrvPwmTimerRG_Init (component TimerUnit_LDD)
 123:../Generated_Code/DrvPwmTimerRG.c **** **
 124:../Generated_Code/DrvPwmTimerRG.c **** **     Description :
 125:../Generated_Code/DrvPwmTimerRG.c **** **         Initializes the device. Allocates memory for the device data
 126:../Generated_Code/DrvPwmTimerRG.c **** **         structure, allocates interrupt vectors and sets interrupt
 127:../Generated_Code/DrvPwmTimerRG.c **** **         priority, sets pin routing, sets timing, etc. If the
 128:../Generated_Code/DrvPwmTimerRG.c **** **         property <"Enable in init. code"> is set to "yes" value then
 129:../Generated_Code/DrvPwmTimerRG.c **** **         the device is also enabled (see the description of the
 130:../Generated_Code/DrvPwmTimerRG.c **** **         <Enable> method). In this case the <Enable> method is not
 131:../Generated_Code/DrvPwmTimerRG.c **** **         necessary and needn't to be generated. This method can be
 132:../Generated_Code/DrvPwmTimerRG.c **** **         called only once. Before the second call of Init the <Deinit>
 133:../Generated_Code/DrvPwmTimerRG.c **** **         must be called first.
 134:../Generated_Code/DrvPwmTimerRG.c **** **     Parameters  :
 135:../Generated_Code/DrvPwmTimerRG.c **** **         NAME            - DESCRIPTION
 136:../Generated_Code/DrvPwmTimerRG.c **** **       * UserDataPtr     - Pointer to the user or
 137:../Generated_Code/DrvPwmTimerRG.c **** **                           RTOS specific data. This pointer will be
 138:../Generated_Code/DrvPwmTimerRG.c **** **                           passed as an event or callback parameter.
 139:../Generated_Code/DrvPwmTimerRG.c **** **     Returns     :
 140:../Generated_Code/DrvPwmTimerRG.c **** **         ---             - Pointer to the dynamically allocated
 141:../Generated_Code/DrvPwmTimerRG.c **** **                           private structure or NULL if there was an
 142:../Generated_Code/DrvPwmTimerRG.c **** **                           error.
 143:../Generated_Code/DrvPwmTimerRG.c **** ** ===================================================================
 144:../Generated_Code/DrvPwmTimerRG.c **** */
 145:../Generated_Code/DrvPwmTimerRG.c **** LDD_TDeviceData* DrvPwmTimerRG_Init(LDD_TUserData *UserDataPtr)
 146:../Generated_Code/DrvPwmTimerRG.c **** {
  45              		.loc 1 146 0
  46              		.cfi_startproc
  47 0000 80B5     		push	{r7, lr}
  48              	.LCFI0:
  49              		.cfi_def_cfa_offset 8
  50              		.cfi_offset 7, -8
  51              		.cfi_offset 14, -4
  52 0002 84B0     		sub	sp, sp, #16
  53              	.LCFI1:
  54              		.cfi_def_cfa_offset 24
  55 0004 00AF     		add	r7, sp, #0
  56              	.LCFI2:
  57              		.cfi_def_cfa_register 7
  58 0006 7860     		str	r0, [r7, #4]
 147:../Generated_Code/DrvPwmTimerRG.c ****   /* Allocate device structure */
 148:../Generated_Code/DrvPwmTimerRG.c ****   DrvPwmTimerRG_TDeviceData *DeviceDataPrv;
 149:../Generated_Code/DrvPwmTimerRG.c ****   /* {MQXLite RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer 
 150:../Generated_Code/DrvPwmTimerRG.c ****   DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
  59              		.loc 1 150 0
  60 0008 374B     		ldr	r3, .L3
  61 000a FB60     		str	r3, [r7, #12]
 151:../Generated_Code/DrvPwmTimerRG.c ****   DeviceDataPrv->UserDataPtr = UserDataPtr; /* Store the RTOS device structure */
  62              		.loc 1 151 0
  63 000c FB68     		ldr	r3, [r7, #12]
  64 000e 7A68     		ldr	r2, [r7, #4]
  65 0010 1A61     		str	r2, [r3, #16]
 152:../Generated_Code/DrvPwmTimerRG.c ****   /* Interrupt vector(s) allocation */
 153:../Generated_Code/DrvPwmTimerRG.c ****   /* {MQXLite RTOS Adapter} Save old and set new interrupt vector (function handler and ISR paramet
 154:../Generated_Code/DrvPwmTimerRG.c ****   /* Note: Exception handler for interrupt is not saved, because it is not modified */
 155:../Generated_Code/DrvPwmTimerRG.c ****   DeviceDataPrv->SavedISRSettings_TUInterrupt.isrData = _int_get_isr_data(LDD_ivIndex_INT_TPM2);
  66              		.loc 1 155 0
  67 0012 2320     		mov	r0, #35
  68 0014 FFF7FEFF 		bl	_int_get_isr_data
  69 0018 021C     		mov	r2, r0
  70 001a FB68     		ldr	r3, [r7, #12]
  71 001c 5A60     		str	r2, [r3, #4]
 156:../Generated_Code/DrvPwmTimerRG.c ****   DeviceDataPrv->SavedISRSettings_TUInterrupt.isrFunction = _int_install_isr(LDD_ivIndex_INT_TPM2, 
  72              		.loc 1 156 0
  73 001e 334A     		ldr	r2, .L3+4
  74 0020 FB68     		ldr	r3, [r7, #12]
  75 0022 2320     		mov	r0, #35
  76 0024 111C     		mov	r1, r2
  77 0026 1A1C     		mov	r2, r3
  78 0028 FFF7FEFF 		bl	_int_install_isr
  79 002c 021C     		mov	r2, r0
  80 002e FB68     		ldr	r3, [r7, #12]
  81 0030 1A60     		str	r2, [r3]
 157:../Generated_Code/DrvPwmTimerRG.c ****   /* SIM_SCGC6: TPM2=1 */
 158:../Generated_Code/DrvPwmTimerRG.c ****   SIM_SCGC6 |= SIM_SCGC6_TPM2_MASK;                                                   
  82              		.loc 1 158 0
  83 0032 2F4A     		ldr	r2, .L3+8
  84 0034 2E49     		ldr	r1, .L3+8
  85 0036 2F4B     		ldr	r3, .L3+12
  86 0038 CB58     		ldr	r3, [r1, r3]
  87 003a 8021     		mov	r1, #128
  88 003c C904     		lsl	r1, r1, #19
  89 003e 1943     		orr	r1, r3
  90 0040 2C4B     		ldr	r3, .L3+12
  91 0042 D150     		str	r1, [r2, r3]
 159:../Generated_Code/DrvPwmTimerRG.c ****   /* TPM2_SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,
 160:../Generated_Code/DrvPwmTimerRG.c ****   TPM2_SC = 0x00U;                     /* Clear status and control register */
  92              		.loc 1 160 0
  93 0044 2C4B     		ldr	r3, .L3+16
  94 0046 0022     		mov	r2, #0
  95 0048 1A60     		str	r2, [r3]
 161:../Generated_Code/DrvPwmTimerRG.c ****   /* TPM2_CNT: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,COUN
 162:../Generated_Code/DrvPwmTimerRG.c ****   TPM2_CNT = 0x00U;                    /* Reset counter register */
  96              		.loc 1 162 0
  97 004a 2B4B     		ldr	r3, .L3+16
  98 004c 0022     		mov	r2, #0
  99 004e 5A60     		str	r2, [r3, #4]
 163:../Generated_Code/DrvPwmTimerRG.c ****   /* TPM2_C0SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 164:../Generated_Code/DrvPwmTimerRG.c ****   TPM2_C0SC = 0x00U;                   /* Clear channel status and control register */
 100              		.loc 1 164 0
 101 0050 294B     		ldr	r3, .L3+16
 102 0052 0022     		mov	r2, #0
 103 0054 DA60     		str	r2, [r3, #12]
 165:../Generated_Code/DrvPwmTimerRG.c ****   /* TPM2_C1SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 166:../Generated_Code/DrvPwmTimerRG.c ****   TPM2_C1SC = 0x00U;                   /* Clear channel status and control register */
 104              		.loc 1 166 0
 105 0056 284B     		ldr	r3, .L3+16
 106 0058 0022     		mov	r2, #0
 107 005a 5A61     		str	r2, [r3, #20]
 167:../Generated_Code/DrvPwmTimerRG.c ****   /* TPM2_MOD: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,MOD=
 168:../Generated_Code/DrvPwmTimerRG.c ****   TPM2_MOD = TPM_MOD_MOD(0xFFFF);      /* Set up modulo register */
 108              		.loc 1 168 0
 109 005c 264B     		ldr	r3, .L3+16
 110 005e 274A     		ldr	r2, .L3+20
 111 0060 9A60     		str	r2, [r3, #8]
 169:../Generated_Code/DrvPwmTimerRG.c ****   /* TPM2_C0SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 170:../Generated_Code/DrvPwmTimerRG.c ****   TPM2_C0SC = TPM_CnSC_CHIE_MASK |
 112              		.loc 1 170 0
 113 0062 254B     		ldr	r3, .L3+16
 114 0064 6C22     		mov	r2, #108
 115 0066 DA60     		str	r2, [r3, #12]
 171:../Generated_Code/DrvPwmTimerRG.c ****               TPM_CnSC_MSB_MASK |
 172:../Generated_Code/DrvPwmTimerRG.c ****               TPM_CnSC_ELSB_MASK |
 173:../Generated_Code/DrvPwmTimerRG.c ****               TPM_CnSC_ELSA_MASK;      /* Set up channel status and control register */
 174:../Generated_Code/DrvPwmTimerRG.c ****   /* TPM2_C0V: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,VAL=
 175:../Generated_Code/DrvPwmTimerRG.c ****   TPM2_C0V = 0x00U;                    /* Set up channel value register */
 116              		.loc 1 175 0
 117 0068 234B     		ldr	r3, .L3+16
 118 006a 0022     		mov	r2, #0
 119 006c 1A61     		str	r2, [r3, #16]
 176:../Generated_Code/DrvPwmTimerRG.c ****   /* TPM2_C1SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 177:../Generated_Code/DrvPwmTimerRG.c ****   TPM2_C1SC = (TPM_CnSC_MSB_MASK | TPM_CnSC_ELSB_MASK | TPM_CnSC_ELSA_MASK); /* Set up channel stat
 120              		.loc 1 177 0
 121 006e 224B     		ldr	r3, .L3+16
 122 0070 2C22     		mov	r2, #44
 123 0072 5A61     		str	r2, [r3, #20]
 178:../Generated_Code/DrvPwmTimerRG.c ****   /* TPM2_C1V: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,VAL=
 179:../Generated_Code/DrvPwmTimerRG.c ****   TPM2_C1V = TPM_CnV_VAL(0x5555);      /* Set up channel value register */
 124              		.loc 1 179 0
 125 0074 204B     		ldr	r3, .L3+16
 126 0076 224A     		ldr	r2, .L3+24
 127 0078 9A61     		str	r2, [r3, #24]
 180:../Generated_Code/DrvPwmTimerRG.c ****   /* PORTB_PCR18: ISF=0,MUX=3 */
 181:../Generated_Code/DrvPwmTimerRG.c ****   PORTB_PCR18 = (uint32_t)((PORTB_PCR18 & (uint32_t)~(uint32_t)(
 128              		.loc 1 181 0
 129 007a 224B     		ldr	r3, .L3+28
 130 007c 214A     		ldr	r2, .L3+28
 131 007e 916C     		ldr	r1, [r2, #72]
 132 0080 214A     		ldr	r2, .L3+32
 133 0082 0A40     		and	r2, r1
 134 0084 C021     		mov	r1, #192
 135 0086 8900     		lsl	r1, r1, #2
 136 0088 0A43     		orr	r2, r1
 137 008a 9A64     		str	r2, [r3, #72]
 182:../Generated_Code/DrvPwmTimerRG.c ****                  PORT_PCR_ISF_MASK |
 183:../Generated_Code/DrvPwmTimerRG.c ****                  PORT_PCR_MUX(0x04)
 184:../Generated_Code/DrvPwmTimerRG.c ****                 )) | (uint32_t)(
 185:../Generated_Code/DrvPwmTimerRG.c ****                  PORT_PCR_MUX(0x03)
 186:../Generated_Code/DrvPwmTimerRG.c ****                 ));                                                  
 187:../Generated_Code/DrvPwmTimerRG.c ****   /* PORTB_PCR19: ISF=0,MUX=3 */
 188:../Generated_Code/DrvPwmTimerRG.c ****   PORTB_PCR19 = (uint32_t)((PORTB_PCR19 & (uint32_t)~(uint32_t)(
 138              		.loc 1 188 0
 139 008c 1D4B     		ldr	r3, .L3+28
 140 008e 1D4A     		ldr	r2, .L3+28
 141 0090 D16C     		ldr	r1, [r2, #76]
 142 0092 1D4A     		ldr	r2, .L3+32
 143 0094 0A40     		and	r2, r1
 144 0096 C021     		mov	r1, #192
 145 0098 8900     		lsl	r1, r1, #2
 146 009a 0A43     		orr	r2, r1
 147 009c DA64     		str	r2, [r3, #76]
 189:../Generated_Code/DrvPwmTimerRG.c ****                  PORT_PCR_ISF_MASK |
 190:../Generated_Code/DrvPwmTimerRG.c ****                  PORT_PCR_MUX(0x04)
 191:../Generated_Code/DrvPwmTimerRG.c ****                 )) | (uint32_t)(
 192:../Generated_Code/DrvPwmTimerRG.c ****                  PORT_PCR_MUX(0x03)
 193:../Generated_Code/DrvPwmTimerRG.c ****                 ));                                                  
 194:../Generated_Code/DrvPwmTimerRG.c ****   DeviceDataPrv->EnEvents = 0x0101U;   /* Enable selected events */
 148              		.loc 1 194 0
 149 009e FB68     		ldr	r3, [r7, #12]
 150 00a0 1A4A     		ldr	r2, .L3+36
 151 00a2 9A60     		str	r2, [r3, #8]
 195:../Generated_Code/DrvPwmTimerRG.c ****   DeviceDataPrv->Source = TPM_PDD_SYSTEM; /* Store clock source */
 152              		.loc 1 195 0
 153 00a4 FB68     		ldr	r3, [r7, #12]
 154 00a6 0822     		mov	r2, #8
 155 00a8 DA60     		str	r2, [r3, #12]
 196:../Generated_Code/DrvPwmTimerRG.c ****   /* NVIC_IPR4: PRI_19=0x80 */
 197:../Generated_Code/DrvPwmTimerRG.c ****   NVIC_IPR4 = (uint32_t)((NVIC_IPR4 & (uint32_t)~(uint32_t)(
 156              		.loc 1 197 0
 157 00aa 194A     		ldr	r2, .L3+40
 158 00ac 1849     		ldr	r1, .L3+40
 159 00ae C423     		mov	r3, #196
 160 00b0 9B00     		lsl	r3, r3, #2
 161 00b2 CB58     		ldr	r3, [r1, r3]
 162 00b4 1B02     		lsl	r3, r3, #8
 163 00b6 1B0A     		lsr	r3, r3, #8
 164 00b8 8021     		mov	r1, #128
 165 00ba 0906     		lsl	r1, r1, #24
 166 00bc 1943     		orr	r1, r3
 167 00be C423     		mov	r3, #196
 168 00c0 9B00     		lsl	r3, r3, #2
 169 00c2 D150     		str	r1, [r2, r3]
 198:../Generated_Code/DrvPwmTimerRG.c ****                NVIC_IP_PRI_19(0x7F)
 199:../Generated_Code/DrvPwmTimerRG.c ****               )) | (uint32_t)(
 200:../Generated_Code/DrvPwmTimerRG.c ****                NVIC_IP_PRI_19(0x80)
 201:../Generated_Code/DrvPwmTimerRG.c ****               ));                                                  
 202:../Generated_Code/DrvPwmTimerRG.c ****   /* NVIC_ISER: SETENA|=0x00080000 */
 203:../Generated_Code/DrvPwmTimerRG.c ****   NVIC_ISER |= NVIC_ISER_SETENA(0x00080000);                                                   
 170              		.loc 1 203 0
 171 00c4 124B     		ldr	r3, .L3+40
 172 00c6 124A     		ldr	r2, .L3+40
 173 00c8 1268     		ldr	r2, [r2]
 174 00ca 8021     		mov	r1, #128
 175 00cc 0903     		lsl	r1, r1, #12
 176 00ce 0A43     		orr	r2, r1
 177 00d0 1A60     		str	r2, [r3]
 204:../Generated_Code/DrvPwmTimerRG.c ****   /* TPM2_SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,
 205:../Generated_Code/DrvPwmTimerRG.c ****   TPM2_SC = (TPM_SC_TOIE_MASK | TPM_SC_CMOD(0x01) | TPM_SC_PS(0x01)); /* Set up status and control 
 178              		.loc 1 205 0
 179 00d2 094B     		ldr	r3, .L3+16
 180 00d4 4922     		mov	r2, #73
 181 00d6 1A60     		str	r2, [r3]
 206:../Generated_Code/DrvPwmTimerRG.c ****   /* Registration of the device structure */
 207:../Generated_Code/DrvPwmTimerRG.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_DrvPwmTimerRG_ID,DeviceDataPrv);
 182              		.loc 1 207 0
 183 00d8 0E4B     		ldr	r3, .L3+44
 184 00da FA68     		ldr	r2, [r7, #12]
 185 00dc 9A60     		str	r2, [r3, #8]
 208:../Generated_Code/DrvPwmTimerRG.c ****   return ((LDD_TDeviceData *)DeviceDataPrv); /* Return pointer to the device data structure */
 186              		.loc 1 208 0
 187 00de FB68     		ldr	r3, [r7, #12]
 209:../Generated_Code/DrvPwmTimerRG.c **** }
 188              		.loc 1 209 0
 189 00e0 181C     		mov	r0, r3
 190 00e2 BD46     		mov	sp, r7
 191 00e4 04B0     		add	sp, sp, #16
 192              		@ sp needed for prologue
 193 00e6 80BD     		pop	{r7, pc}
 194              	.L4:
 195              		.align	2
 196              	.L3:
 197 00e8 00000000 		.word	DeviceDataPrv__DEFAULT_RTOS_ALLOC
 198 00ec 00000000 		.word	DrvPwmTimerRG_Interrupt
 199 00f0 00700440 		.word	1074032640
 200 00f4 3C100000 		.word	4156
 201 00f8 00A00340 		.word	1073979392
 202 00fc FFFF0000 		.word	65535
 203 0100 55550000 		.word	21845
 204 0104 00A00440 		.word	1074044928
 205 0108 FFF8FFFE 		.word	-16779009
 206 010c 01010000 		.word	257
 207 0110 00E100E0 		.word	-536813312
 208 0114 00000000 		.word	PE_LDD_DeviceDataList
 209              		.cfi_endproc
 210              	.LFE0:
 212              		.section	.text.DrvPwmTimerRG_Deinit,"ax",%progbits
 213              		.align	2
 214              		.global	DrvPwmTimerRG_Deinit
 215              		.code	16
 216              		.thumb_func
 218              	DrvPwmTimerRG_Deinit:
 219              	.LFB1:
 210:../Generated_Code/DrvPwmTimerRG.c **** 
 211:../Generated_Code/DrvPwmTimerRG.c **** /*
 212:../Generated_Code/DrvPwmTimerRG.c **** ** ===================================================================
 213:../Generated_Code/DrvPwmTimerRG.c **** **     Method      :  DrvPwmTimerRG_Deinit (component TimerUnit_LDD)
 214:../Generated_Code/DrvPwmTimerRG.c **** **
 215:../Generated_Code/DrvPwmTimerRG.c **** **     Description :
 216:../Generated_Code/DrvPwmTimerRG.c **** **         Deinitializes the device. Switches off the device, frees the
 217:../Generated_Code/DrvPwmTimerRG.c **** **         device data structure memory, interrupts vectors, etc.
 218:../Generated_Code/DrvPwmTimerRG.c **** **     Parameters  :
 219:../Generated_Code/DrvPwmTimerRG.c **** **         NAME            - DESCRIPTION
 220:../Generated_Code/DrvPwmTimerRG.c **** **       * DeviceDataPtr   - Device data structure
 221:../Generated_Code/DrvPwmTimerRG.c **** **                           pointer returned by Init method
 222:../Generated_Code/DrvPwmTimerRG.c **** **     Returns     : Nothing
 223:../Generated_Code/DrvPwmTimerRG.c **** ** ===================================================================
 224:../Generated_Code/DrvPwmTimerRG.c **** */
 225:../Generated_Code/DrvPwmTimerRG.c **** void DrvPwmTimerRG_Deinit(LDD_TDeviceData *DeviceDataPtr)
 226:../Generated_Code/DrvPwmTimerRG.c **** {
 220              		.loc 1 226 0
 221              		.cfi_startproc
 222 0000 80B5     		push	{r7, lr}
 223              	.LCFI3:
 224              		.cfi_def_cfa_offset 8
 225              		.cfi_offset 7, -8
 226              		.cfi_offset 14, -4
 227 0002 84B0     		sub	sp, sp, #16
 228              	.LCFI4:
 229              		.cfi_def_cfa_offset 24
 230 0004 00AF     		add	r7, sp, #0
 231              	.LCFI5:
 232              		.cfi_def_cfa_register 7
 233 0006 7860     		str	r0, [r7, #4]
 227:../Generated_Code/DrvPwmTimerRG.c ****   DrvPwmTimerRG_TDeviceData *DeviceDataPrv = (DrvPwmTimerRG_TDeviceData *)DeviceDataPtr;
 234              		.loc 1 227 0
 235 0008 7B68     		ldr	r3, [r7, #4]
 236 000a FB60     		str	r3, [r7, #12]
 228:../Generated_Code/DrvPwmTimerRG.c **** 
 229:../Generated_Code/DrvPwmTimerRG.c ****   (void)DeviceDataPrv;
 230:../Generated_Code/DrvPwmTimerRG.c ****   TPM_PDD_SelectPrescalerSource(TPM2_BASE_PTR, TPM_PDD_DISABLED);
 237              		.loc 1 230 0
 238 000c 0A4B     		ldr	r3, .L6
 239 000e 0A4A     		ldr	r2, .L6
 240 0010 1268     		ldr	r2, [r2]
 241 0012 9821     		mov	r1, #152
 242 0014 8A43     		bic	r2, r1
 243 0016 1A60     		str	r2, [r3]
 231:../Generated_Code/DrvPwmTimerRG.c ****   /* Interrupt vector(s) deallocation */
 232:../Generated_Code/DrvPwmTimerRG.c ****   /* {MQXLite RTOS Adapter} Restore interrupt vector (function handler and ISR parameter) */
 233:../Generated_Code/DrvPwmTimerRG.c ****   /* Note: Exception handler for interrupt is not restored, because it was not modified */
 234:../Generated_Code/DrvPwmTimerRG.c ****   (void)_int_install_isr(LDD_ivIndex_INT_TPM2, ((DrvPwmTimerRG_TDeviceDataPtr)DeviceDataPrv)->Saved
 244              		.loc 1 234 0
 245 0018 FB68     		ldr	r3, [r7, #12]
 246 001a 1A68     		ldr	r2, [r3]
 247 001c FB68     		ldr	r3, [r7, #12]
 248 001e 5B68     		ldr	r3, [r3, #4]
 249 0020 2320     		mov	r0, #35
 250 0022 111C     		mov	r1, r2
 251 0024 1A1C     		mov	r2, r3
 252 0026 FFF7FEFF 		bl	_int_install_isr
 235:../Generated_Code/DrvPwmTimerRG.c ****   /* Unregistration of the device structure */
 236:../Generated_Code/DrvPwmTimerRG.c ****   PE_LDD_UnregisterDeviceStructure(PE_LDD_COMPONENT_DrvPwmTimerRG_ID);
 253              		.loc 1 236 0
 254 002a 044B     		ldr	r3, .L6+4
 255 002c 0022     		mov	r2, #0
 256 002e 9A60     		str	r2, [r3, #8]
 237:../Generated_Code/DrvPwmTimerRG.c ****   /* Deallocation of the device structure */
 238:../Generated_Code/DrvPwmTimerRG.c ****   /* {MQXLite RTOS Adapter} Driver memory deallocation: Dynamic allocation is simulated, no dealloc
 239:../Generated_Code/DrvPwmTimerRG.c **** }
 257              		.loc 1 239 0
 258 0030 BD46     		mov	sp, r7
 259 0032 04B0     		add	sp, sp, #16
 260              		@ sp needed for prologue
 261 0034 80BD     		pop	{r7, pc}
 262              	.L7:
 263 0036 C046     		.align	2
 264              	.L6:
 265 0038 00A00340 		.word	1073979392
 266 003c 00000000 		.word	PE_LDD_DeviceDataList
 267              		.cfi_endproc
 268              	.LFE1:
 270              		.section	.text.DrvPwmTimerRG_Enable,"ax",%progbits
 271              		.align	2
 272              		.global	DrvPwmTimerRG_Enable
 273              		.code	16
 274              		.thumb_func
 276              	DrvPwmTimerRG_Enable:
 277              	.LFB2:
 240:../Generated_Code/DrvPwmTimerRG.c **** 
 241:../Generated_Code/DrvPwmTimerRG.c **** /*
 242:../Generated_Code/DrvPwmTimerRG.c **** ** ===================================================================
 243:../Generated_Code/DrvPwmTimerRG.c **** **     Method      :  DrvPwmTimerRG_Enable (component TimerUnit_LDD)
 244:../Generated_Code/DrvPwmTimerRG.c **** **
 245:../Generated_Code/DrvPwmTimerRG.c **** **     Description :
 246:../Generated_Code/DrvPwmTimerRG.c **** **         Enables the component - it starts the signal generation.
 247:../Generated_Code/DrvPwmTimerRG.c **** **         Events may be generated (see SetEventMask). The method is
 248:../Generated_Code/DrvPwmTimerRG.c **** **         not available if the counter can't be disabled/enabled by HW.
 249:../Generated_Code/DrvPwmTimerRG.c **** **     Parameters  :
 250:../Generated_Code/DrvPwmTimerRG.c **** **         NAME            - DESCRIPTION
 251:../Generated_Code/DrvPwmTimerRG.c **** **       * DeviceDataPtr   - Device data structure
 252:../Generated_Code/DrvPwmTimerRG.c **** **                           pointer returned by <Init> method.
 253:../Generated_Code/DrvPwmTimerRG.c **** **     Returns     :
 254:../Generated_Code/DrvPwmTimerRG.c **** **         ---             - Error code, possible codes:
 255:../Generated_Code/DrvPwmTimerRG.c **** **                           ERR_OK - OK
 256:../Generated_Code/DrvPwmTimerRG.c **** **                           ERR_SPEED - The component does not work in
 257:../Generated_Code/DrvPwmTimerRG.c **** **                           the active clock configuration
 258:../Generated_Code/DrvPwmTimerRG.c **** ** ===================================================================
 259:../Generated_Code/DrvPwmTimerRG.c **** */
 260:../Generated_Code/DrvPwmTimerRG.c **** LDD_TError DrvPwmTimerRG_Enable(LDD_TDeviceData *DeviceDataPtr)
 261:../Generated_Code/DrvPwmTimerRG.c **** {
 278              		.loc 1 261 0
 279              		.cfi_startproc
 280 0000 80B5     		push	{r7, lr}
 281              	.LCFI6:
 282              		.cfi_def_cfa_offset 8
 283              		.cfi_offset 7, -8
 284              		.cfi_offset 14, -4
 285 0002 84B0     		sub	sp, sp, #16
 286              	.LCFI7:
 287              		.cfi_def_cfa_offset 24
 288 0004 00AF     		add	r7, sp, #0
 289              	.LCFI8:
 290              		.cfi_def_cfa_register 7
 291 0006 7860     		str	r0, [r7, #4]
 262:../Generated_Code/DrvPwmTimerRG.c ****   DrvPwmTimerRG_TDeviceData *DeviceDataPrv = (DrvPwmTimerRG_TDeviceData *)DeviceDataPtr;
 292              		.loc 1 262 0
 293 0008 7B68     		ldr	r3, [r7, #4]
 294 000a FB60     		str	r3, [r7, #12]
 263:../Generated_Code/DrvPwmTimerRG.c **** 
 264:../Generated_Code/DrvPwmTimerRG.c ****   TPM_PDD_SelectPrescalerSource(TPM2_BASE_PTR, DeviceDataPrv->Source); /* Enable the device */
 295              		.loc 1 264 0
 296 000c 074B     		ldr	r3, .L10
 297 000e 074A     		ldr	r2, .L10
 298 0010 1268     		ldr	r2, [r2]
 299 0012 9821     		mov	r1, #152
 300 0014 101C     		mov	r0, r2
 301 0016 8843     		bic	r0, r1
 302 0018 011C     		mov	r1, r0
 303 001a FA68     		ldr	r2, [r7, #12]
 304 001c D268     		ldr	r2, [r2, #12]
 305 001e 0A43     		orr	r2, r1
 306 0020 1A60     		str	r2, [r3]
 265:../Generated_Code/DrvPwmTimerRG.c ****   return ERR_OK;
 307              		.loc 1 265 0
 308 0022 0023     		mov	r3, #0
 266:../Generated_Code/DrvPwmTimerRG.c **** }
 309              		.loc 1 266 0
 310 0024 181C     		mov	r0, r3
 311 0026 BD46     		mov	sp, r7
 312 0028 04B0     		add	sp, sp, #16
 313              		@ sp needed for prologue
 314 002a 80BD     		pop	{r7, pc}
 315              	.L11:
 316              		.align	2
 317              	.L10:
 318 002c 00A00340 		.word	1073979392
 319              		.cfi_endproc
 320              	.LFE2:
 322              		.section	.text.DrvPwmTimerRG_Disable,"ax",%progbits
 323              		.align	2
 324              		.global	DrvPwmTimerRG_Disable
 325              		.code	16
 326              		.thumb_func
 328              	DrvPwmTimerRG_Disable:
 329              	.LFB3:
 267:../Generated_Code/DrvPwmTimerRG.c **** 
 268:../Generated_Code/DrvPwmTimerRG.c **** /*
 269:../Generated_Code/DrvPwmTimerRG.c **** ** ===================================================================
 270:../Generated_Code/DrvPwmTimerRG.c **** **     Method      :  DrvPwmTimerRG_Disable (component TimerUnit_LDD)
 271:../Generated_Code/DrvPwmTimerRG.c **** **
 272:../Generated_Code/DrvPwmTimerRG.c **** **     Description :
 273:../Generated_Code/DrvPwmTimerRG.c **** **         Disables the component - it stops signal generation and
 274:../Generated_Code/DrvPwmTimerRG.c **** **         events calling. The method is not available if the counter
 275:../Generated_Code/DrvPwmTimerRG.c **** **         can't be disabled/enabled by HW.
 276:../Generated_Code/DrvPwmTimerRG.c **** **     Parameters  :
 277:../Generated_Code/DrvPwmTimerRG.c **** **         NAME            - DESCRIPTION
 278:../Generated_Code/DrvPwmTimerRG.c **** **       * DeviceDataPtr   - Device data structure
 279:../Generated_Code/DrvPwmTimerRG.c **** **                           pointer returned by <Init> method.
 280:../Generated_Code/DrvPwmTimerRG.c **** **     Returns     :
 281:../Generated_Code/DrvPwmTimerRG.c **** **         ---             - Error code, possible codes:
 282:../Generated_Code/DrvPwmTimerRG.c **** **                           ERR_OK - OK
 283:../Generated_Code/DrvPwmTimerRG.c **** **                           ERR_SPEED - The component does not work in
 284:../Generated_Code/DrvPwmTimerRG.c **** **                           the active clock configuration
 285:../Generated_Code/DrvPwmTimerRG.c **** ** ===================================================================
 286:../Generated_Code/DrvPwmTimerRG.c **** */
 287:../Generated_Code/DrvPwmTimerRG.c **** LDD_TError DrvPwmTimerRG_Disable(LDD_TDeviceData *DeviceDataPtr)
 288:../Generated_Code/DrvPwmTimerRG.c **** {
 330              		.loc 1 288 0
 331              		.cfi_startproc
 332 0000 80B5     		push	{r7, lr}
 333              	.LCFI9:
 334              		.cfi_def_cfa_offset 8
 335              		.cfi_offset 7, -8
 336              		.cfi_offset 14, -4
 337 0002 82B0     		sub	sp, sp, #8
 338              	.LCFI10:
 339              		.cfi_def_cfa_offset 16
 340 0004 00AF     		add	r7, sp, #0
 341              	.LCFI11:
 342              		.cfi_def_cfa_register 7
 343 0006 7860     		str	r0, [r7, #4]
 289:../Generated_Code/DrvPwmTimerRG.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 290:../Generated_Code/DrvPwmTimerRG.c ****   TPM_PDD_SelectPrescalerSource(TPM2_BASE_PTR, TPM_PDD_DISABLED);
 344              		.loc 1 290 0
 345 0008 054B     		ldr	r3, .L14
 346 000a 054A     		ldr	r2, .L14
 347 000c 1268     		ldr	r2, [r2]
 348 000e 9821     		mov	r1, #152
 349 0010 8A43     		bic	r2, r1
 350 0012 1A60     		str	r2, [r3]
 291:../Generated_Code/DrvPwmTimerRG.c ****   return ERR_OK;
 351              		.loc 1 291 0
 352 0014 0023     		mov	r3, #0
 292:../Generated_Code/DrvPwmTimerRG.c **** }
 353              		.loc 1 292 0
 354 0016 181C     		mov	r0, r3
 355 0018 BD46     		mov	sp, r7
 356 001a 02B0     		add	sp, sp, #8
 357              		@ sp needed for prologue
 358 001c 80BD     		pop	{r7, pc}
 359              	.L15:
 360 001e C046     		.align	2
 361              	.L14:
 362 0020 00A00340 		.word	1073979392
 363              		.cfi_endproc
 364              	.LFE3:
 366              		.section	.text.DrvPwmTimerRG_GetCounterValue,"ax",%progbits
 367              		.align	2
 368              		.global	DrvPwmTimerRG_GetCounterValue
 369              		.code	16
 370              		.thumb_func
 372              	DrvPwmTimerRG_GetCounterValue:
 373              	.LFB4:
 293:../Generated_Code/DrvPwmTimerRG.c **** 
 294:../Generated_Code/DrvPwmTimerRG.c **** /*
 295:../Generated_Code/DrvPwmTimerRG.c **** ** ===================================================================
 296:../Generated_Code/DrvPwmTimerRG.c **** **     Method      :  DrvPwmTimerRG_GetCounterValue (component TimerUnit_LDD)
 297:../Generated_Code/DrvPwmTimerRG.c **** **
 298:../Generated_Code/DrvPwmTimerRG.c **** **     Description :
 299:../Generated_Code/DrvPwmTimerRG.c **** **         Returns the content of counter register. This method can be
 300:../Generated_Code/DrvPwmTimerRG.c **** **         used both if counter is enabled and if counter is disabled.
 301:../Generated_Code/DrvPwmTimerRG.c **** **         The method is not available if HW doesn't allow reading of
 302:../Generated_Code/DrvPwmTimerRG.c **** **         the counter.
 303:../Generated_Code/DrvPwmTimerRG.c **** **     Parameters  :
 304:../Generated_Code/DrvPwmTimerRG.c **** **         NAME            - DESCRIPTION
 305:../Generated_Code/DrvPwmTimerRG.c **** **       * DeviceDataPtr   - Device data structure
 306:../Generated_Code/DrvPwmTimerRG.c **** **                           pointer returned by <Init> method.
 307:../Generated_Code/DrvPwmTimerRG.c **** **     Returns     :
 308:../Generated_Code/DrvPwmTimerRG.c **** **         ---             - Counter value (number of counted ticks).
 309:../Generated_Code/DrvPwmTimerRG.c **** ** ===================================================================
 310:../Generated_Code/DrvPwmTimerRG.c **** */
 311:../Generated_Code/DrvPwmTimerRG.c **** DrvPwmTimerRG_TValueType DrvPwmTimerRG_GetCounterValue(LDD_TDeviceData *DeviceDataPtr)
 312:../Generated_Code/DrvPwmTimerRG.c **** {
 374              		.loc 1 312 0
 375              		.cfi_startproc
 376 0000 80B5     		push	{r7, lr}
 377              	.LCFI12:
 378              		.cfi_def_cfa_offset 8
 379              		.cfi_offset 7, -8
 380              		.cfi_offset 14, -4
 381 0002 82B0     		sub	sp, sp, #8
 382              	.LCFI13:
 383              		.cfi_def_cfa_offset 16
 384 0004 00AF     		add	r7, sp, #0
 385              	.LCFI14:
 386              		.cfi_def_cfa_register 7
 387 0006 7860     		str	r0, [r7, #4]
 313:../Generated_Code/DrvPwmTimerRG.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 314:../Generated_Code/DrvPwmTimerRG.c ****   return (DrvPwmTimerRG_TValueType)TPM_PDD_ReadCounterReg(TPM2_BASE_PTR);
 388              		.loc 1 314 0
 389 0008 024B     		ldr	r3, .L18
 390 000a 5B68     		ldr	r3, [r3, #4]
 315:../Generated_Code/DrvPwmTimerRG.c **** }
 391              		.loc 1 315 0
 392 000c 181C     		mov	r0, r3
 393 000e BD46     		mov	sp, r7
 394 0010 02B0     		add	sp, sp, #8
 395              		@ sp needed for prologue
 396 0012 80BD     		pop	{r7, pc}
 397              	.L19:
 398              		.align	2
 399              	.L18:
 400 0014 00A00340 		.word	1073979392
 401              		.cfi_endproc
 402              	.LFE4:
 404              		.section	.text.DrvPwmTimerRG_SetOffsetTicks,"ax",%progbits
 405              		.align	2
 406              		.global	DrvPwmTimerRG_SetOffsetTicks
 407              		.code	16
 408              		.thumb_func
 410              	DrvPwmTimerRG_SetOffsetTicks:
 411              	.LFB5:
 316:../Generated_Code/DrvPwmTimerRG.c **** 
 317:../Generated_Code/DrvPwmTimerRG.c **** /*
 318:../Generated_Code/DrvPwmTimerRG.c **** ** ===================================================================
 319:../Generated_Code/DrvPwmTimerRG.c **** **     Method      :  DrvPwmTimerRG_SetOffsetTicks (component TimerUnit_LDD)
 320:../Generated_Code/DrvPwmTimerRG.c **** **
 321:../Generated_Code/DrvPwmTimerRG.c **** **     Description :
 322:../Generated_Code/DrvPwmTimerRG.c **** **         Sets the new offset value to channel specified by the
 323:../Generated_Code/DrvPwmTimerRG.c **** **         parameter ChannelIdx. It is user responsibility to use value
 324:../Generated_Code/DrvPwmTimerRG.c **** **         below selected period. This method is available when at
 325:../Generated_Code/DrvPwmTimerRG.c **** **         least one channel is configured.
 326:../Generated_Code/DrvPwmTimerRG.c **** **     Parameters  :
 327:../Generated_Code/DrvPwmTimerRG.c **** **         NAME            - DESCRIPTION
 328:../Generated_Code/DrvPwmTimerRG.c **** **       * DeviceDataPtr   - Device data structure
 329:../Generated_Code/DrvPwmTimerRG.c **** **                           pointer returned by <Init> method.
 330:../Generated_Code/DrvPwmTimerRG.c **** **         ChannelIdx      - Index of the component
 331:../Generated_Code/DrvPwmTimerRG.c **** **                           channel.
 332:../Generated_Code/DrvPwmTimerRG.c **** **         Ticks           - Number of counter ticks to compare
 333:../Generated_Code/DrvPwmTimerRG.c **** **                           match.
 334:../Generated_Code/DrvPwmTimerRG.c **** **     Returns     :
 335:../Generated_Code/DrvPwmTimerRG.c **** **         ---             - Error code, possible codes:
 336:../Generated_Code/DrvPwmTimerRG.c **** **                           ERR_OK - OK 
 337:../Generated_Code/DrvPwmTimerRG.c **** **                           ERR_PARAM_INDEX - ChannelIdx parameter is
 338:../Generated_Code/DrvPwmTimerRG.c **** **                           out of possible range.
 339:../Generated_Code/DrvPwmTimerRG.c **** **                           ERR_NOTAVAIL -  The compare mode is not
 340:../Generated_Code/DrvPwmTimerRG.c **** **                           selected for selected channel
 341:../Generated_Code/DrvPwmTimerRG.c **** **                           ERR_PARAM_TICKS - Ticks parameter is out of
 342:../Generated_Code/DrvPwmTimerRG.c **** **                           possible range.
 343:../Generated_Code/DrvPwmTimerRG.c **** **                           ERR_SPEED - The component does not work in
 344:../Generated_Code/DrvPwmTimerRG.c **** **                           the active clock configuration
 345:../Generated_Code/DrvPwmTimerRG.c **** ** ===================================================================
 346:../Generated_Code/DrvPwmTimerRG.c **** */
 347:../Generated_Code/DrvPwmTimerRG.c **** LDD_TError DrvPwmTimerRG_SetOffsetTicks(LDD_TDeviceData *DeviceDataPtr, uint8_t ChannelIdx, DrvPwmT
 348:../Generated_Code/DrvPwmTimerRG.c **** {
 412              		.loc 1 348 0
 413              		.cfi_startproc
 414 0000 80B5     		push	{r7, lr}
 415              	.LCFI15:
 416              		.cfi_def_cfa_offset 8
 417              		.cfi_offset 7, -8
 418              		.cfi_offset 14, -4
 419 0002 84B0     		sub	sp, sp, #16
 420              	.LCFI16:
 421              		.cfi_def_cfa_offset 24
 422 0004 00AF     		add	r7, sp, #0
 423              	.LCFI17:
 424              		.cfi_def_cfa_register 7
 425 0006 F860     		str	r0, [r7, #12]
 426 0008 7A60     		str	r2, [r7, #4]
 427 000a 3B1C     		mov	r3, r7
 428 000c 0B33     		add	r3, r3, #11
 429 000e 0A1C     		add	r2, r1, #0
 430 0010 1A70     		strb	r2, [r3]
 349:../Generated_Code/DrvPwmTimerRG.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 350:../Generated_Code/DrvPwmTimerRG.c ****   /* Parameter test - this test can be disabled by setting the "Ignore range checking"
 351:../Generated_Code/DrvPwmTimerRG.c ****      property to the "yes" value in the "Configuration inspector" */
 352:../Generated_Code/DrvPwmTimerRG.c ****   if (ChannelIdx > LAST_CHANNEL) {     /* Is the channel index out of range? */
 431              		.loc 1 352 0
 432 0012 3B1C     		mov	r3, r7
 433 0014 0B33     		add	r3, r3, #11
 434 0016 1B78     		ldrb	r3, [r3]
 435 0018 012B     		cmp	r3, #1
 436 001a 01D9     		bls	.L21
 353:../Generated_Code/DrvPwmTimerRG.c ****     return ERR_PARAM_INDEX;            /* If yes then error */
 437              		.loc 1 353 0
 438 001c 8223     		mov	r3, #130
 439 001e 1BE0     		b	.L22
 440              	.L21:
 354:../Generated_Code/DrvPwmTimerRG.c ****   }
 355:../Generated_Code/DrvPwmTimerRG.c ****   if ((ChannelMode[ChannelIdx]) != 0U) { /* Is the channel in compare mode? */
 441              		.loc 1 355 0
 442 0020 3B1C     		mov	r3, r7
 443 0022 0B33     		add	r3, r3, #11
 444 0024 1B78     		ldrb	r3, [r3]
 445 0026 0E4A     		ldr	r2, .L25
 446 0028 D35C     		ldrb	r3, [r2, r3]
 447 002a 002B     		cmp	r3, #0
 448 002c 01D0     		beq	.L23
 356:../Generated_Code/DrvPwmTimerRG.c ****     return ERR_NOTAVAIL;               /* If not then error */
 449              		.loc 1 356 0
 450 002e 0923     		mov	r3, #9
 451 0030 12E0     		b	.L22
 452              	.L23:
 357:../Generated_Code/DrvPwmTimerRG.c ****   }
 358:../Generated_Code/DrvPwmTimerRG.c ****   TPM_PDD_WriteChannelValueReg(TPM2_BASE_PTR, ChannelDevice[ChannelIdx], (uint16_t)Ticks);
 453              		.loc 1 358 0
 454 0032 0C49     		ldr	r1, .L25+4
 455 0034 3B1C     		mov	r3, r7
 456 0036 0B33     		add	r3, r3, #11
 457 0038 1B78     		ldrb	r3, [r3]
 458 003a 0B4A     		ldr	r2, .L25+8
 459 003c D35C     		ldrb	r3, [r2, r3]
 460 003e 7A68     		ldr	r2, [r7, #4]
 461 0040 92B2     		uxth	r2, r2
 462 0042 0133     		add	r3, r3, #1
 463 0044 DB00     		lsl	r3, r3, #3
 464 0046 CB18     		add	r3, r1, r3
 465 0048 9A60     		str	r2, [r3, #8]
 359:../Generated_Code/DrvPwmTimerRG.c ****   if (Ticks > 65535U) {                /* Was the given value greater than counter width? */
 466              		.loc 1 359 0
 467 004a 7A68     		ldr	r2, [r7, #4]
 468 004c 074B     		ldr	r3, .L25+12
 469 004e 9A42     		cmp	r2, r3
 470 0050 01D9     		bls	.L24
 360:../Generated_Code/DrvPwmTimerRG.c ****     return ERR_PARAM_TICKS;            /* If yes then truncation of user data to 16 bits is reporte
 471              		.loc 1 360 0
 472 0052 9823     		mov	r3, #152
 473 0054 00E0     		b	.L22
 474              	.L24:
 361:../Generated_Code/DrvPwmTimerRG.c ****   }
 362:../Generated_Code/DrvPwmTimerRG.c ****   return ERR_OK;                       /* OK */
 475              		.loc 1 362 0
 476 0056 0023     		mov	r3, #0
 477              	.L22:
 363:../Generated_Code/DrvPwmTimerRG.c **** }
 478              		.loc 1 363 0
 479 0058 181C     		mov	r0, r3
 480 005a BD46     		mov	sp, r7
 481 005c 04B0     		add	sp, sp, #16
 482              		@ sp needed for prologue
 483 005e 80BD     		pop	{r7, pc}
 484              	.L26:
 485              		.align	2
 486              	.L25:
 487 0060 00000000 		.word	ChannelMode
 488 0064 00A00340 		.word	1073979392
 489 0068 00000000 		.word	ChannelDevice
 490 006c FFFF0000 		.word	65535
 491              		.cfi_endproc
 492              	.LFE5:
 494              		.section	.text.DrvPwmTimerRG_GetOffsetTicks,"ax",%progbits
 495              		.align	2
 496              		.global	DrvPwmTimerRG_GetOffsetTicks
 497              		.code	16
 498              		.thumb_func
 500              	DrvPwmTimerRG_GetOffsetTicks:
 501              	.LFB6:
 364:../Generated_Code/DrvPwmTimerRG.c **** 
 365:../Generated_Code/DrvPwmTimerRG.c **** /*
 366:../Generated_Code/DrvPwmTimerRG.c **** ** ===================================================================
 367:../Generated_Code/DrvPwmTimerRG.c **** **     Method      :  DrvPwmTimerRG_GetOffsetTicks (component TimerUnit_LDD)
 368:../Generated_Code/DrvPwmTimerRG.c **** **
 369:../Generated_Code/DrvPwmTimerRG.c **** **     Description :
 370:../Generated_Code/DrvPwmTimerRG.c **** **         Returns the number of counter ticks to compare match channel
 371:../Generated_Code/DrvPwmTimerRG.c **** **         specified by the parameter ChannelIdx. See also method
 372:../Generated_Code/DrvPwmTimerRG.c **** **         <SetOffsetTicks>. This method is available when at least one
 373:../Generated_Code/DrvPwmTimerRG.c **** **         channel is configured.
 374:../Generated_Code/DrvPwmTimerRG.c **** **     Parameters  :
 375:../Generated_Code/DrvPwmTimerRG.c **** **         NAME            - DESCRIPTION
 376:../Generated_Code/DrvPwmTimerRG.c **** **       * DeviceDataPtr   - Device data structure
 377:../Generated_Code/DrvPwmTimerRG.c **** **                           pointer returned by <Init> method.
 378:../Generated_Code/DrvPwmTimerRG.c **** **         ChannelIdx      - Index of the component
 379:../Generated_Code/DrvPwmTimerRG.c **** **                           channel.
 380:../Generated_Code/DrvPwmTimerRG.c **** **       * TicksPtr        - Pointer to return value of the
 381:../Generated_Code/DrvPwmTimerRG.c **** **                           number of counter ticks to compare match.
 382:../Generated_Code/DrvPwmTimerRG.c **** **     Returns     :
 383:../Generated_Code/DrvPwmTimerRG.c **** **         ---             - Error code, possible codes:
 384:../Generated_Code/DrvPwmTimerRG.c **** **                           ERR_OK - OK 
 385:../Generated_Code/DrvPwmTimerRG.c **** **                           ERR_PARAM_INDEX - ChannelIdx parameter is
 386:../Generated_Code/DrvPwmTimerRG.c **** **                           out of possible range.
 387:../Generated_Code/DrvPwmTimerRG.c **** **                           ERR_NOTAVAIL -  The compare mode is not
 388:../Generated_Code/DrvPwmTimerRG.c **** **                           selected for selected channel.
 389:../Generated_Code/DrvPwmTimerRG.c **** **                           ERR_SPEED - The component does not work in
 390:../Generated_Code/DrvPwmTimerRG.c **** **                           the active clock configuration
 391:../Generated_Code/DrvPwmTimerRG.c **** ** ===================================================================
 392:../Generated_Code/DrvPwmTimerRG.c **** */
 393:../Generated_Code/DrvPwmTimerRG.c **** LDD_TError DrvPwmTimerRG_GetOffsetTicks(LDD_TDeviceData *DeviceDataPtr, uint8_t ChannelIdx, DrvPwmT
 394:../Generated_Code/DrvPwmTimerRG.c **** {
 502              		.loc 1 394 0
 503              		.cfi_startproc
 504 0000 80B5     		push	{r7, lr}
 505              	.LCFI18:
 506              		.cfi_def_cfa_offset 8
 507              		.cfi_offset 7, -8
 508              		.cfi_offset 14, -4
 509 0002 84B0     		sub	sp, sp, #16
 510              	.LCFI19:
 511              		.cfi_def_cfa_offset 24
 512 0004 00AF     		add	r7, sp, #0
 513              	.LCFI20:
 514              		.cfi_def_cfa_register 7
 515 0006 F860     		str	r0, [r7, #12]
 516 0008 7A60     		str	r2, [r7, #4]
 517 000a 3B1C     		mov	r3, r7
 518 000c 0B33     		add	r3, r3, #11
 519 000e 0A1C     		add	r2, r1, #0
 520 0010 1A70     		strb	r2, [r3]
 395:../Generated_Code/DrvPwmTimerRG.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 396:../Generated_Code/DrvPwmTimerRG.c ****   /* Parameter test - this test can be disabled by setting the "Ignore range checking"
 397:../Generated_Code/DrvPwmTimerRG.c ****      property to the "yes" value in the "Configuration inspector" */
 398:../Generated_Code/DrvPwmTimerRG.c ****   if (ChannelIdx > LAST_CHANNEL) {     /* Is the channel index out of range? */
 521              		.loc 1 398 0
 522 0012 3B1C     		mov	r3, r7
 523 0014 0B33     		add	r3, r3, #11
 524 0016 1B78     		ldrb	r3, [r3]
 525 0018 012B     		cmp	r3, #1
 526 001a 01D9     		bls	.L28
 399:../Generated_Code/DrvPwmTimerRG.c ****     return ERR_PARAM_INDEX;            /* If yes then error */
 527              		.loc 1 399 0
 528 001c 8223     		mov	r3, #130
 529 001e 15E0     		b	.L29
 530              	.L28:
 400:../Generated_Code/DrvPwmTimerRG.c ****   }
 401:../Generated_Code/DrvPwmTimerRG.c ****   if ((ChannelMode[ChannelIdx]) != 0U) { /* Is the channel in compare mode? */
 531              		.loc 1 401 0
 532 0020 3B1C     		mov	r3, r7
 533 0022 0B33     		add	r3, r3, #11
 534 0024 1B78     		ldrb	r3, [r3]
 535 0026 0B4A     		ldr	r2, .L31
 536 0028 D35C     		ldrb	r3, [r2, r3]
 537 002a 002B     		cmp	r3, #0
 538 002c 01D0     		beq	.L30
 402:../Generated_Code/DrvPwmTimerRG.c ****     return ERR_NOTAVAIL;               /* If not then error */
 539              		.loc 1 402 0
 540 002e 0923     		mov	r3, #9
 541 0030 0CE0     		b	.L29
 542              	.L30:
 403:../Generated_Code/DrvPwmTimerRG.c ****   }
 404:../Generated_Code/DrvPwmTimerRG.c ****   *TicksPtr = (DrvPwmTimerRG_TValueType)(TPM_PDD_ReadChannelValueReg(TPM2_BASE_PTR, ChannelDevice[C
 543              		.loc 1 404 0
 544 0032 094A     		ldr	r2, .L31+4
 545 0034 3B1C     		mov	r3, r7
 546 0036 0B33     		add	r3, r3, #11
 547 0038 1B78     		ldrb	r3, [r3]
 548 003a 0849     		ldr	r1, .L31+8
 549 003c CB5C     		ldrb	r3, [r1, r3]
 550 003e 0133     		add	r3, r3, #1
 551 0040 DB00     		lsl	r3, r3, #3
 552 0042 D318     		add	r3, r2, r3
 553 0044 9A68     		ldr	r2, [r3, #8]
 554 0046 7B68     		ldr	r3, [r7, #4]
 555 0048 1A60     		str	r2, [r3]
 405:../Generated_Code/DrvPwmTimerRG.c ****   return ERR_OK;                       /* OK */
 556              		.loc 1 405 0
 557 004a 0023     		mov	r3, #0
 558              	.L29:
 406:../Generated_Code/DrvPwmTimerRG.c **** }
 559              		.loc 1 406 0
 560 004c 181C     		mov	r0, r3
 561 004e BD46     		mov	sp, r7
 562 0050 04B0     		add	sp, sp, #16
 563              		@ sp needed for prologue
 564 0052 80BD     		pop	{r7, pc}
 565              	.L32:
 566              		.align	2
 567              	.L31:
 568 0054 00000000 		.word	ChannelMode
 569 0058 00A00340 		.word	1073979392
 570 005c 00000000 		.word	ChannelDevice
 571              		.cfi_endproc
 572              	.LFE6:
 574              		.section	.text.DrvPwmTimerRG_Interrupt,"ax",%progbits
 575              		.align	2
 576              		.global	DrvPwmTimerRG_Interrupt
 577              		.code	16
 578              		.thumb_func
 580              	DrvPwmTimerRG_Interrupt:
 581              	.LFB7:
 407:../Generated_Code/DrvPwmTimerRG.c **** 
 408:../Generated_Code/DrvPwmTimerRG.c **** /*
 409:../Generated_Code/DrvPwmTimerRG.c **** ** ===================================================================
 410:../Generated_Code/DrvPwmTimerRG.c **** **     Method      :  DrvPwmTimerRG_Interrupt (component TimerUnit_LDD)
 411:../Generated_Code/DrvPwmTimerRG.c **** **
 412:../Generated_Code/DrvPwmTimerRG.c **** **     Description :
 413:../Generated_Code/DrvPwmTimerRG.c **** **         The method services the interrupt of the selected peripheral(s)
 414:../Generated_Code/DrvPwmTimerRG.c **** **         and eventually invokes event(s) of the component.
 415:../Generated_Code/DrvPwmTimerRG.c **** **         This method is internal. It is used by Processor Expert only.
 416:../Generated_Code/DrvPwmTimerRG.c **** ** ===================================================================
 417:../Generated_Code/DrvPwmTimerRG.c **** */
 418:../Generated_Code/DrvPwmTimerRG.c **** void DrvPwmTimerRG_Interrupt(LDD_RTOS_TISRParameter _isrParameter)
 419:../Generated_Code/DrvPwmTimerRG.c **** {
 582              		.loc 1 419 0
 583              		.cfi_startproc
 584 0000 80B5     		push	{r7, lr}
 585              	.LCFI21:
 586              		.cfi_def_cfa_offset 8
 587              		.cfi_offset 7, -8
 588              		.cfi_offset 14, -4
 589 0002 84B0     		sub	sp, sp, #16
 590              	.LCFI22:
 591              		.cfi_def_cfa_offset 24
 592 0004 00AF     		add	r7, sp, #0
 593              	.LCFI23:
 594              		.cfi_def_cfa_register 7
 595 0006 7860     		str	r0, [r7, #4]
 420:../Generated_Code/DrvPwmTimerRG.c ****   /* {MQXLite RTOS Adapter} ISR parameter is passed as parameter from RTOS interrupt dispatcher */
 421:../Generated_Code/DrvPwmTimerRG.c ****   DrvPwmTimerRG_TDeviceDataPtr DeviceDataPrv = (DrvPwmTimerRG_TDeviceDataPtr)_isrParameter;
 596              		.loc 1 421 0
 597 0008 7B68     		ldr	r3, [r7, #4]
 598 000a BB60     		str	r3, [r7, #8]
 422:../Generated_Code/DrvPwmTimerRG.c **** 
 423:../Generated_Code/DrvPwmTimerRG.c ****   LDD_TEventMask State = 0U;
 599              		.loc 1 423 0
 600 000c 0023     		mov	r3, #0
 601 000e FB60     		str	r3, [r7, #12]
 424:../Generated_Code/DrvPwmTimerRG.c **** 
 425:../Generated_Code/DrvPwmTimerRG.c ****   if ((TPM_PDD_GetOverflowInterruptFlag(TPM2_BASE_PTR)) != 0U) { /* Is the overflow interrupt flag 
 602              		.loc 1 425 0
 603 0010 244B     		ldr	r3, .L38
 604 0012 1A68     		ldr	r2, [r3]
 605 0014 8023     		mov	r3, #128
 606 0016 1340     		and	r3, r2
 607 0018 04D0     		beq	.L34
 426:../Generated_Code/DrvPwmTimerRG.c ****     State |= LDD_TIMERUNIT_ON_COUNTER_RESTART; /* and set mask */
 608              		.loc 1 426 0
 609 001a FB68     		ldr	r3, [r7, #12]
 610 001c 8022     		mov	r2, #128
 611 001e 5200     		lsl	r2, r2, #1
 612 0020 1343     		orr	r3, r2
 613 0022 FB60     		str	r3, [r7, #12]
 614              	.L34:
 427:../Generated_Code/DrvPwmTimerRG.c ****   }
 428:../Generated_Code/DrvPwmTimerRG.c ****   if ((TPM_PDD_GetChannelInterruptFlag(TPM2_BASE_PTR, ChannelDevice[0])) != 0U) { /* Is the channel
 615              		.loc 1 428 0
 616 0024 1F4A     		ldr	r2, .L38
 617 0026 204B     		ldr	r3, .L38+4
 618 0028 1B78     		ldrb	r3, [r3]
 619 002a 0133     		add	r3, r3, #1
 620 002c DB00     		lsl	r3, r3, #3
 621 002e D318     		add	r3, r2, r3
 622 0030 5A68     		ldr	r2, [r3, #4]
 623 0032 8023     		mov	r3, #128
 624 0034 1340     		and	r3, r2
 625 0036 03D0     		beq	.L35
 429:../Generated_Code/DrvPwmTimerRG.c ****     State |= LDD_TIMERUNIT_ON_CHANNEL_0; /* and set mask */
 626              		.loc 1 429 0
 627 0038 FB68     		ldr	r3, [r7, #12]
 628 003a 0122     		mov	r2, #1
 629 003c 1343     		orr	r3, r2
 630 003e FB60     		str	r3, [r7, #12]
 631              	.L35:
 430:../Generated_Code/DrvPwmTimerRG.c ****   }
 431:../Generated_Code/DrvPwmTimerRG.c ****   State &= DeviceDataPrv->EnEvents;    /* Handle only enabled interrupts */
 632              		.loc 1 431 0
 633 0040 BB68     		ldr	r3, [r7, #8]
 634 0042 9A68     		ldr	r2, [r3, #8]
 635 0044 FB68     		ldr	r3, [r7, #12]
 636 0046 1340     		and	r3, r2
 637 0048 FB60     		str	r3, [r7, #12]
 432:../Generated_Code/DrvPwmTimerRG.c ****   if (State & LDD_TIMERUNIT_ON_COUNTER_RESTART) { /* Is the overflow interrupt flag pending? */
 638              		.loc 1 432 0
 639 004a FA68     		ldr	r2, [r7, #12]
 640 004c 8023     		mov	r3, #128
 641 004e 5B00     		lsl	r3, r3, #1
 642 0050 1340     		and	r3, r2
 643 0052 0AD0     		beq	.L36
 433:../Generated_Code/DrvPwmTimerRG.c ****     TPM_PDD_ClearOverflowInterruptFlag(TPM2_BASE_PTR); /* Clear flag */
 644              		.loc 1 433 0
 645 0054 134B     		ldr	r3, .L38
 646 0056 134A     		ldr	r2, .L38
 647 0058 1268     		ldr	r2, [r2]
 648 005a 8021     		mov	r1, #128
 649 005c 0A43     		orr	r2, r1
 650 005e 1A60     		str	r2, [r3]
 434:../Generated_Code/DrvPwmTimerRG.c ****     DrvPwmTimerRG_OnCounterRestart(DeviceDataPrv->UserDataPtr); /* Invoke OnCounterRestart event */
 651              		.loc 1 434 0
 652 0060 BB68     		ldr	r3, [r7, #8]
 653 0062 1B69     		ldr	r3, [r3, #16]
 654 0064 181C     		mov	r0, r3
 655 0066 FFF7FEFF 		bl	DrvPwmTimerRG_OnCounterRestart
 656              	.L36:
 435:../Generated_Code/DrvPwmTimerRG.c ****   }
 436:../Generated_Code/DrvPwmTimerRG.c ****   if (State & LDD_TIMERUNIT_ON_CHANNEL_0) { /* Is the channel 0 interrupt flag pending? */
 657              		.loc 1 436 0
 658 006a FA68     		ldr	r2, [r7, #12]
 659 006c 0123     		mov	r3, #1
 660 006e 1340     		and	r3, r2
 661 0070 15D0     		beq	.L33
 437:../Generated_Code/DrvPwmTimerRG.c ****     TPM_PDD_ClearChannelInterruptFlag(TPM2_BASE_PTR, ChannelDevice[0]); /* Clear flag */
 662              		.loc 1 437 0
 663 0072 0C49     		ldr	r1, .L38
 664 0074 0C4B     		ldr	r3, .L38+4
 665 0076 1B78     		ldrb	r3, [r3]
 666 0078 181C     		mov	r0, r3
 667 007a 0A4A     		ldr	r2, .L38
 668 007c 0A4B     		ldr	r3, .L38+4
 669 007e 1B78     		ldrb	r3, [r3]
 670 0080 0133     		add	r3, r3, #1
 671 0082 DB00     		lsl	r3, r3, #3
 672 0084 D318     		add	r3, r2, r3
 673 0086 5B68     		ldr	r3, [r3, #4]
 674 0088 8022     		mov	r2, #128
 675 008a 1A43     		orr	r2, r3
 676 008c 431C     		add	r3, r0, #1
 677 008e DB00     		lsl	r3, r3, #3
 678 0090 CB18     		add	r3, r1, r3
 679 0092 5A60     		str	r2, [r3, #4]
 438:../Generated_Code/DrvPwmTimerRG.c ****     DrvPwmTimerRG_OnChannel0(DeviceDataPrv->UserDataPtr); /* Invoke OnChannel0 event */
 680              		.loc 1 438 0
 681 0094 BB68     		ldr	r3, [r7, #8]
 682 0096 1B69     		ldr	r3, [r3, #16]
 683 0098 181C     		mov	r0, r3
 684 009a FFF7FEFF 		bl	DrvPwmTimerRG_OnChannel0
 685              	.L33:
 439:../Generated_Code/DrvPwmTimerRG.c ****   }
 440:../Generated_Code/DrvPwmTimerRG.c **** }
 686              		.loc 1 440 0
 687 009e BD46     		mov	sp, r7
 688 00a0 04B0     		add	sp, sp, #16
 689              		@ sp needed for prologue
 690 00a2 80BD     		pop	{r7, pc}
 691              	.L39:
 692              		.align	2
 693              	.L38:
 694 00a4 00A00340 		.word	1073979392
 695 00a8 00000000 		.word	ChannelDevice
 696              		.cfi_endproc
 697              	.LFE7:
 699              		.text
 700              	.Letext0:
 701              		.file 2 "C:/Freescale/CW MCU v10.3/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 702              		.file 3 "E:/CW103_Work_Space/Mqx_Lite_Test/Generated_Code/IO_Map.h"
 703              		.file 4 "E:/CW103_Work_Space/Mqx_Lite_Test/Generated_Code/PE_LDD.h"
 704              		.file 5 "E:/CW103_Work_Space/Mqx_Lite_Test/Generated_Code/DrvPwmTimerRG.h"
 705              		.file 6 "E:/CW103_Work_Space/Mqx_Lite_Test/MQXLITE/psp/cortex_m/psptypes.h"
DEFINED SYMBOLS
                            *ABS*:00000000 DrvPwmTimerRG.c
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:18     .rodata.ChannelDevice:00000000 $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:21     .rodata.ChannelDevice:00000000 ChannelDevice
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:25     .rodata.ChannelMode:00000000 $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:28     .rodata.ChannelMode:00000000 ChannelMode
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:31     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:34     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:37     .text.DrvPwmTimerRG_Init:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:42     .text.DrvPwmTimerRG_Init:00000000 DrvPwmTimerRG_Init
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:197    .text.DrvPwmTimerRG_Init:000000e8 $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:580    .text.DrvPwmTimerRG_Interrupt:00000000 DrvPwmTimerRG_Interrupt
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:213    .text.DrvPwmTimerRG_Deinit:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:218    .text.DrvPwmTimerRG_Deinit:00000000 DrvPwmTimerRG_Deinit
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:265    .text.DrvPwmTimerRG_Deinit:00000038 $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:271    .text.DrvPwmTimerRG_Enable:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:276    .text.DrvPwmTimerRG_Enable:00000000 DrvPwmTimerRG_Enable
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:318    .text.DrvPwmTimerRG_Enable:0000002c $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:323    .text.DrvPwmTimerRG_Disable:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:328    .text.DrvPwmTimerRG_Disable:00000000 DrvPwmTimerRG_Disable
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:362    .text.DrvPwmTimerRG_Disable:00000020 $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:367    .text.DrvPwmTimerRG_GetCounterValue:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:372    .text.DrvPwmTimerRG_GetCounterValue:00000000 DrvPwmTimerRG_GetCounterValue
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:400    .text.DrvPwmTimerRG_GetCounterValue:00000014 $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:405    .text.DrvPwmTimerRG_SetOffsetTicks:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:410    .text.DrvPwmTimerRG_SetOffsetTicks:00000000 DrvPwmTimerRG_SetOffsetTicks
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:487    .text.DrvPwmTimerRG_SetOffsetTicks:00000060 $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:495    .text.DrvPwmTimerRG_GetOffsetTicks:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:500    .text.DrvPwmTimerRG_GetOffsetTicks:00000000 DrvPwmTimerRG_GetOffsetTicks
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:568    .text.DrvPwmTimerRG_GetOffsetTicks:00000054 $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:575    .text.DrvPwmTimerRG_Interrupt:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccdgByD3.s:694    .text.DrvPwmTimerRG_Interrupt:000000a4 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_int_get_isr_data
_int_install_isr
PE_LDD_DeviceDataList
DrvPwmTimerRG_OnCounterRestart
DrvPwmTimerRG_OnChannel0
