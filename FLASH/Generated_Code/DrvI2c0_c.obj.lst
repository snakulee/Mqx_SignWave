   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"DrvI2c0.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  18              		.align	2
  21              	DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  22 0000 00000000 		.space	28
  22      00000000 
  22      00000000 
  22      00000000 
  22      00000000 
  23              		.section	.text.DrvI2c0_Interrupt,"ax",%progbits
  24              		.align	2
  25              		.global	DrvI2c0_Interrupt
  26              		.code	16
  27              		.thumb_func
  29              	DrvI2c0_Interrupt:
  30              	.LFB0:
  31              		.file 1 "../Generated_Code/DrvI2c0.c"
   1:../Generated_Code/DrvI2c0.c **** /** ###################################################################
   2:../Generated_Code/DrvI2c0.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/DrvI2c0.c **** **     Filename    : DrvI2c0.c
   4:../Generated_Code/DrvI2c0.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/DrvI2c0.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/DrvI2c0.c **** **     Component   : I2C_LDD
   7:../Generated_Code/DrvI2c0.c **** **     Version     : Component 01.011, Driver 01.06, CPU db: 3.00.000
   8:../Generated_Code/DrvI2c0.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/DrvI2c0.c **** **     Date/Time   : 2013-02-22, 13:57, # CodeGen: 14
  10:../Generated_Code/DrvI2c0.c **** **     Abstract    :
  11:../Generated_Code/DrvI2c0.c **** **          This component encapsulates the internal I2C communication
  12:../Generated_Code/DrvI2c0.c **** **          interface. The implementation of the interface is based
  13:../Generated_Code/DrvI2c0.c **** **          on the Philips I2C-bus specification version 2.0.
  14:../Generated_Code/DrvI2c0.c **** **          Interface features:
  15:../Generated_Code/DrvI2c0.c **** **          MASTER mode
  16:../Generated_Code/DrvI2c0.c **** **            - Multi master communication
  17:../Generated_Code/DrvI2c0.c **** **            - The combined format of communication possible
  18:../Generated_Code/DrvI2c0.c **** **              (see SendStop parameter in MasterSend/ReceiveBlock method)
  19:../Generated_Code/DrvI2c0.c **** **            - 7-bit slave addressing (10-bit addressing can be made as well)
  20:../Generated_Code/DrvI2c0.c **** **            - Acknowledge polling provided
  21:../Generated_Code/DrvI2c0.c **** **            - No wait state initiated when a slave device holds the SCL line low
  22:../Generated_Code/DrvI2c0.c **** **            - Holding of the SCL line low by slave device recognized as 'not available bus'
  23:../Generated_Code/DrvI2c0.c **** **            - Invalid start/stop condition detection provided
  24:../Generated_Code/DrvI2c0.c **** **          SLAVE mode
  25:../Generated_Code/DrvI2c0.c **** **            - 7-bit slave addressing
  26:../Generated_Code/DrvI2c0.c **** **            - General call address detection provided
  27:../Generated_Code/DrvI2c0.c **** **     Settings    :
  28:../Generated_Code/DrvI2c0.c **** **          Component name                                 : DrvI2c0
  29:../Generated_Code/DrvI2c0.c **** **          I2C channel                                    : I2C0
  30:../Generated_Code/DrvI2c0.c **** **          Interrupt service                              : Enabled
  31:../Generated_Code/DrvI2c0.c **** **            Interrupt                                    : INT_I2C0
  32:../Generated_Code/DrvI2c0.c **** **            Interrupt priority                           : medium priority
  33:../Generated_Code/DrvI2c0.c **** **          Settings                                       : 
  34:../Generated_Code/DrvI2c0.c **** **            Mode selection                               : MASTER
  35:../Generated_Code/DrvI2c0.c **** **            MASTER mode                                  : Enabled
  36:../Generated_Code/DrvI2c0.c **** **              Initialization                             : 
  37:../Generated_Code/DrvI2c0.c **** **                Address mode                             : 7-bit addressing
  38:../Generated_Code/DrvI2c0.c **** **                Target slave address init                : 1D
  39:../Generated_Code/DrvI2c0.c **** **            SLAVE mode                                   : Disabled
  40:../Generated_Code/DrvI2c0.c **** **            Pins                                         : 
  41:../Generated_Code/DrvI2c0.c **** **              SDA pin                                    : 
  42:../Generated_Code/DrvI2c0.c **** **                SDA pin                                  : PTE25/TPM0_CH1/I2C0_SDA
  43:../Generated_Code/DrvI2c0.c **** **                SDA pin signal                           : 
  44:../Generated_Code/DrvI2c0.c **** **              SCL pin                                    : 
  45:../Generated_Code/DrvI2c0.c **** **                SCL pin                                  : PTE24/TPM0_CH0/I2C0_SCL
  46:../Generated_Code/DrvI2c0.c **** **                SCL pin signal                           : 
  47:../Generated_Code/DrvI2c0.c **** **              High drive select                          : Disabled
  48:../Generated_Code/DrvI2c0.c **** **              Input Glitch filter                        : 0
  49:../Generated_Code/DrvI2c0.c **** **            Internal frequency (multiplier factor)       : 24 MHz
  50:../Generated_Code/DrvI2c0.c **** **            Bits 0-2 of Frequency divider register       : 101
  51:../Generated_Code/DrvI2c0.c **** **            Bits 3-5 of Frequency divider register       : 100
  52:../Generated_Code/DrvI2c0.c **** **            SCL frequency                                : 75 kHz
  53:../Generated_Code/DrvI2c0.c **** **            SDA Hold                                     : 2.042 us
  54:../Generated_Code/DrvI2c0.c **** **            SCL start Hold                               : 6.583 us
  55:../Generated_Code/DrvI2c0.c **** **            SCL stop Hold                                : 6.708 us
  56:../Generated_Code/DrvI2c0.c **** **            Control acknowledge bit                      : Disabled
  57:../Generated_Code/DrvI2c0.c **** **            Low timeout                                  : Disabled
  58:../Generated_Code/DrvI2c0.c **** **          Initialization                                 : 
  59:../Generated_Code/DrvI2c0.c **** **            Enabled in init code                         : yes
  60:../Generated_Code/DrvI2c0.c **** **            Auto initialization                          : no
  61:../Generated_Code/DrvI2c0.c **** **            Event mask                                   : 
  62:../Generated_Code/DrvI2c0.c **** **              OnMasterBlockSent                          : Enabled
  63:../Generated_Code/DrvI2c0.c **** **              OnMasterBlockReceived                      : Enabled
  64:../Generated_Code/DrvI2c0.c **** **              OnMasterByteReceived                       : Disabled
  65:../Generated_Code/DrvI2c0.c **** **              OnSlaveBlockSent                           : Disabled
  66:../Generated_Code/DrvI2c0.c **** **              OnSlaveBlockReceived                       : Disabled
  67:../Generated_Code/DrvI2c0.c **** **              OnSlaveByteReceived                        : Disabled
  68:../Generated_Code/DrvI2c0.c **** **              OnSlaveRxRequest                           : Disabled
  69:../Generated_Code/DrvI2c0.c **** **              OnSlaveTxRequest                           : Disabled
  70:../Generated_Code/DrvI2c0.c **** **              OnSlaveGeneralCallAddr                     : Disabled
  71:../Generated_Code/DrvI2c0.c **** **              OnSlaveSmBusCallAddr                       : Disabled
  72:../Generated_Code/DrvI2c0.c **** **              OnSlaveSmBusAlertResponse                  : Disabled
  73:../Generated_Code/DrvI2c0.c **** **              OnError                                    : Enabled
  74:../Generated_Code/DrvI2c0.c **** **              OnBusStopDetected                          : Disabled
  75:../Generated_Code/DrvI2c0.c **** **          CPU clock/configuration selection              : 
  76:../Generated_Code/DrvI2c0.c **** **            Clock configuration 0                        : This component enabled
  77:../Generated_Code/DrvI2c0.c **** **            Clock configuration 1                        : This component disabled
  78:../Generated_Code/DrvI2c0.c **** **            Clock configuration 2                        : This component disabled
  79:../Generated_Code/DrvI2c0.c **** **            Clock configuration 3                        : This component disabled
  80:../Generated_Code/DrvI2c0.c **** **            Clock configuration 4                        : This component disabled
  81:../Generated_Code/DrvI2c0.c **** **            Clock configuration 5                        : This component disabled
  82:../Generated_Code/DrvI2c0.c **** **            Clock configuration 6                        : This component disabled
  83:../Generated_Code/DrvI2c0.c **** **            Clock configuration 7                        : This component disabled
  84:../Generated_Code/DrvI2c0.c **** **     Contents    :
  85:../Generated_Code/DrvI2c0.c **** **         Init               - LDD_TDeviceData* DrvI2c0_Init(LDD_TUserData *UserDataPtr);
  86:../Generated_Code/DrvI2c0.c **** **         Deinit             - void DrvI2c0_Deinit(LDD_TDeviceData *DeviceDataPtr);
  87:../Generated_Code/DrvI2c0.c **** **         MasterSendBlock    - LDD_TError DrvI2c0_MasterSendBlock(LDD_TDeviceData *DeviceDataPtr, 
  88:../Generated_Code/DrvI2c0.c **** **         MasterReceiveBlock - LDD_TError DrvI2c0_MasterReceiveBlock(LDD_TDeviceData *DeviceDataPt
  89:../Generated_Code/DrvI2c0.c **** **         CheckBus           - LDD_TError DrvI2c0_CheckBus(LDD_TDeviceData *DeviceDataPtr, LDD_I2C
  90:../Generated_Code/DrvI2c0.c **** **
  91:../Generated_Code/DrvI2c0.c **** **     Copyright : 1997 - 2012 Freescale, Inc. All Rights Reserved.
  92:../Generated_Code/DrvI2c0.c **** **     
  93:../Generated_Code/DrvI2c0.c **** **     http      : www.freescale.com
  94:../Generated_Code/DrvI2c0.c **** **     mail      : support@freescale.com
  95:../Generated_Code/DrvI2c0.c **** ** ###################################################################*/
  96:../Generated_Code/DrvI2c0.c **** 
  97:../Generated_Code/DrvI2c0.c **** /* MODULE DrvI2c0. */
  98:../Generated_Code/DrvI2c0.c **** 
  99:../Generated_Code/DrvI2c0.c **** #include "Events.h"
 100:../Generated_Code/DrvI2c0.c **** #include "DrvI2c0.h"
 101:../Generated_Code/DrvI2c0.c **** #include "PORT_PDD.h"
 102:../Generated_Code/DrvI2c0.c **** #include "I2C_PDD.h"
 103:../Generated_Code/DrvI2c0.c **** /* MQX Lite include files */
 104:../Generated_Code/DrvI2c0.c **** #include "mqxlite.h"
 105:../Generated_Code/DrvI2c0.c **** #include "mqxlite_prv.h"
 106:../Generated_Code/DrvI2c0.c **** #include "IO_Map.h"
 107:../Generated_Code/DrvI2c0.c **** 
 108:../Generated_Code/DrvI2c0.c **** 
 109:../Generated_Code/DrvI2c0.c **** /* SerFlag bits */
 110:../Generated_Code/DrvI2c0.c **** #define MASTER_IN_PROGRES       0x01U  /* Communication is in progress (Master) */
 111:../Generated_Code/DrvI2c0.c **** 
 112:../Generated_Code/DrvI2c0.c **** typedef struct {
 113:../Generated_Code/DrvI2c0.c ****   uint8_t SerFlag;                     /* Flags for serial communication */
 114:../Generated_Code/DrvI2c0.c ****                                        /* Bits: 0 - Running int from TX */
 115:../Generated_Code/DrvI2c0.c ****   LDD_I2C_TSendStop SendStop;          /* Enable/Disable generate send stop condition after transmi
 116:../Generated_Code/DrvI2c0.c ****   LDD_I2C_TSize InpLenM;               /* The counter of input bufer's content */
 117:../Generated_Code/DrvI2c0.c ****   uint8_t *InpPtrM;                    /* Pointer to input buffer for Master mode */
 118:../Generated_Code/DrvI2c0.c ****   LDD_I2C_TSize OutLenM;               /* The counter of output bufer's content */
 119:../Generated_Code/DrvI2c0.c ****   uint8_t *OutPtrM;                    /* Pointer to output buffer for Master mode */
 120:../Generated_Code/DrvI2c0.c ****   LDD_RTOS_TISRVectorSettings SavedISRSettings; /* {MQXLite RTOS Adapter} Saved settings of allocat
 121:../Generated_Code/DrvI2c0.c ****   LDD_TUserData *UserData;             /* RTOS device data structure */
 122:../Generated_Code/DrvI2c0.c **** } DrvI2c0_TDeviceData;
 123:../Generated_Code/DrvI2c0.c **** 
 124:../Generated_Code/DrvI2c0.c **** typedef DrvI2c0_TDeviceData *DrvI2c0_TDeviceDataPtr; /* Pointer to the device data structure. */
 125:../Generated_Code/DrvI2c0.c **** 
 126:../Generated_Code/DrvI2c0.c **** /* {MQXLite RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
 127:../Generated_Code/DrvI2c0.c **** static DrvI2c0_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 128:../Generated_Code/DrvI2c0.c **** 
 129:../Generated_Code/DrvI2c0.c **** #define AVAILABLE_EVENTS_MASK (LDD_I2C_ON_MASTER_BLOCK_SENT | LDD_I2C_ON_MASTER_BLOCK_RECEIVED | LD
 130:../Generated_Code/DrvI2c0.c **** 
 131:../Generated_Code/DrvI2c0.c **** /*
 132:../Generated_Code/DrvI2c0.c **** ** ===================================================================
 133:../Generated_Code/DrvI2c0.c **** **     Method      :  DrvI2c0_Interrupt (component I2C_LDD)
 134:../Generated_Code/DrvI2c0.c **** **
 135:../Generated_Code/DrvI2c0.c **** **     Description :
 136:../Generated_Code/DrvI2c0.c **** **         The method services the interrupt of the selected peripheral(s)
 137:../Generated_Code/DrvI2c0.c **** **         and eventually invokes event(s) of the component.
 138:../Generated_Code/DrvI2c0.c **** **         This method is internal. It is used by Processor Expert only.
 139:../Generated_Code/DrvI2c0.c **** ** ===================================================================
 140:../Generated_Code/DrvI2c0.c **** */
 141:../Generated_Code/DrvI2c0.c **** 
 142:../Generated_Code/DrvI2c0.c **** void DrvI2c0_Interrupt(LDD_RTOS_TISRParameter _isrParameter)
 143:../Generated_Code/DrvI2c0.c **** {
  32              		.loc 1 143 0
  33              		.cfi_startproc
  34 0000 90B5     		push	{r4, r7, lr}
  35              	.LCFI0:
  36              		.cfi_def_cfa_offset 12
  37              		.cfi_offset 4, -12
  38              		.cfi_offset 7, -8
  39              		.cfi_offset 14, -4
  40 0002 85B0     		sub	sp, sp, #20
  41              	.LCFI1:
  42              		.cfi_def_cfa_offset 32
  43 0004 00AF     		add	r7, sp, #0
  44              	.LCFI2:
  45              		.cfi_def_cfa_register 7
  46 0006 7860     		str	r0, [r7, #4]
 144:../Generated_Code/DrvI2c0.c ****   /* {MQXLite RTOS Adapter} ISR parameter is passed as parameter from RTOS interrupt dispatcher */
 145:../Generated_Code/DrvI2c0.c ****   DrvI2c0_TDeviceDataPtr DeviceDataPrv = (DrvI2c0_TDeviceDataPtr)_isrParameter;
  47              		.loc 1 145 0
  48 0008 7B68     		ldr	r3, [r7, #4]
  49 000a BB60     		str	r3, [r7, #8]
 146:../Generated_Code/DrvI2c0.c ****   LDD_I2C_TErrorMask ErrorMask = 0x00U; /* Temporary variable for error mask */
  50              		.loc 1 146 0
  51 000c 3B1C     		mov	r3, r7
  52 000e 0E33     		add	r3, r3, #14
  53 0010 0022     		mov	r2, #0
  54 0012 1A80     		strh	r2, [r3]
 147:../Generated_Code/DrvI2c0.c ****   register uint8_t Status;             /* Temporary variable for status register */
 148:../Generated_Code/DrvI2c0.c **** 
 149:../Generated_Code/DrvI2c0.c ****   Status = I2C_PDD_ReadStatusReg(I2C0_BASE_PTR); /* Safe status register */
  55              		.loc 1 149 0
  56 0014 894B     		ldr	r3, .L14
  57 0016 DB78     		ldrb	r3, [r3, #3]
  58 0018 DCB2     		uxtb	r4, r3
 150:../Generated_Code/DrvI2c0.c ****   I2C_PDD_ClearInterruptFlags(I2C0_BASE_PTR, (Status)); /* Clear interrupt flag */
  59              		.loc 1 150 0
  60 001a 884B     		ldr	r3, .L14
  61 001c 874A     		ldr	r2, .L14
  62 001e D278     		ldrb	r2, [r2, #3]
  63 0020 D2B2     		uxtb	r2, r2
  64 0022 D2B2     		uxtb	r2, r2
  65 0024 1221     		mov	r1, #18
  66 0026 8A43     		bic	r2, r1
  67 0028 D1B2     		uxtb	r1, r2
  68 002a E2B2     		uxtb	r2, r4
  69 002c 0A43     		orr	r2, r1
  70 002e D2B2     		uxtb	r2, r2
  71 0030 D2B2     		uxtb	r2, r2
  72 0032 DA70     		strb	r2, [r3, #3]
 151:../Generated_Code/DrvI2c0.c ****   if (I2C_PDD_GetMasterMode(I2C0_BASE_PTR) == I2C_PDD_MASTER_MODE) { /* Is device in master mode? *
  73              		.loc 1 151 0
  74 0034 814B     		ldr	r3, .L14
  75 0036 9B78     		ldrb	r3, [r3, #2]
  76 0038 DBB2     		uxtb	r3, r3
  77 003a 1A1C     		mov	r2, r3
  78 003c 2023     		mov	r3, #32
  79 003e 1340     		and	r3, r2
  80 0040 00D1     		bne	.LCB46
  81 0042 CAE0     		b	.L2	@long jump
  82              	.LCB46:
 152:../Generated_Code/DrvI2c0.c ****     if (I2C_PDD_GetTransmitMode(I2C0_BASE_PTR) == I2C_PDD_TX_DIRECTION) { /* Is device in Tx mode? 
  83              		.loc 1 152 0
  84 0044 7D4B     		ldr	r3, .L14
  85 0046 9B78     		ldrb	r3, [r3, #2]
  86 0048 DBB2     		uxtb	r3, r3
  87 004a 1A1C     		mov	r2, r3
  88 004c 1023     		mov	r3, #16
  89 004e 1340     		and	r3, r2
  90 0050 00D1     		bne	.LCB54
  91 0052 81E0     		b	.L3	@long jump
  92              	.LCB54:
 153:../Generated_Code/DrvI2c0.c ****       if ((Status & I2C_PDD_RX_ACKNOWLEDGE) != 0x00U){ /* NACK received? */
  93              		.loc 1 153 0
  94 0054 221C     		mov	r2, r4
  95 0056 0123     		mov	r3, #1
  96 0058 1340     		and	r3, r2
  97 005a 25D0     		beq	.L4
 154:../Generated_Code/DrvI2c0.c ****         I2C_PDD_SetMasterMode(I2C0_BASE_PTR, I2C_PDD_SLAVE_MODE); /* Switch device to slave mode (s
  98              		.loc 1 154 0
  99 005c 774B     		ldr	r3, .L14
 100 005e 774A     		ldr	r2, .L14
 101 0060 9278     		ldrb	r2, [r2, #2]
 102 0062 D2B2     		uxtb	r2, r2
 103 0064 2021     		mov	r1, #32
 104 0066 8A43     		bic	r2, r1
 105 0068 D2B2     		uxtb	r2, r2
 106 006a 9A70     		strb	r2, [r3, #2]
 155:../Generated_Code/DrvI2c0.c ****         I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode */
 107              		.loc 1 155 0
 108 006c 734B     		ldr	r3, .L14
 109 006e 734A     		ldr	r2, .L14
 110 0070 9278     		ldrb	r2, [r2, #2]
 111 0072 D2B2     		uxtb	r2, r2
 112 0074 1021     		mov	r1, #16
 113 0076 8A43     		bic	r2, r1
 114 0078 D2B2     		uxtb	r2, r2
 115 007a 9A70     		strb	r2, [r3, #2]
 156:../Generated_Code/DrvI2c0.c ****         DeviceDataPrv->OutLenM = 0x00U; /* No character for sending */
 116              		.loc 1 156 0
 117 007c BB68     		ldr	r3, [r7, #8]
 118 007e 0022     		mov	r2, #0
 119 0080 1A81     		strh	r2, [r3, #8]
 157:../Generated_Code/DrvI2c0.c ****         DeviceDataPrv->InpLenM = 0x00U; /* No character for reception */
 120              		.loc 1 157 0
 121 0082 BB68     		ldr	r3, [r7, #8]
 122 0084 0022     		mov	r2, #0
 123 0086 5A80     		strh	r2, [r3, #2]
 158:../Generated_Code/DrvI2c0.c ****         DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* No character for sending or rec
 124              		.loc 1 158 0
 125 0088 BB68     		ldr	r3, [r7, #8]
 126 008a 1B78     		ldrb	r3, [r3]
 127 008c 0122     		mov	r2, #1
 128 008e 9343     		bic	r3, r2
 129 0090 DAB2     		uxtb	r2, r3
 130 0092 BB68     		ldr	r3, [r7, #8]
 131 0094 1A70     		strb	r2, [r3]
 159:../Generated_Code/DrvI2c0.c ****         ErrorMask |= LDD_I2C_MASTER_NACK; /* Set the Master Nack error mask */
 132              		.loc 1 159 0
 133 0096 3B1C     		mov	r3, r7
 134 0098 0E33     		add	r3, r3, #14
 135 009a 3A1C     		mov	r2, r7
 136 009c 0E32     		add	r2, r2, #14
 137 009e 1288     		ldrh	r2, [r2]
 138 00a0 0821     		mov	r1, #8
 139 00a2 0A43     		orr	r2, r1
 140 00a4 1A80     		strh	r2, [r3]
 141 00a6 BCE0     		b	.L5
 142              	.L4:
 160:../Generated_Code/DrvI2c0.c ****       } else {
 161:../Generated_Code/DrvI2c0.c ****         if (DeviceDataPrv->OutLenM != 0x00U) { /* Is any char. for transmitting? */
 143              		.loc 1 161 0
 144 00a8 BB68     		ldr	r3, [r7, #8]
 145 00aa 1B89     		ldrh	r3, [r3, #8]
 146 00ac 002B     		cmp	r3, #0
 147 00ae 0ED0     		beq	.L6
 162:../Generated_Code/DrvI2c0.c ****           DeviceDataPrv->OutLenM--;    /* Decrease number of chars for the transmit */
 148              		.loc 1 162 0
 149 00b0 BB68     		ldr	r3, [r7, #8]
 150 00b2 1B89     		ldrh	r3, [r3, #8]
 151 00b4 013B     		sub	r3, r3, #1
 152 00b6 9AB2     		uxth	r2, r3
 153 00b8 BB68     		ldr	r3, [r7, #8]
 154 00ba 1A81     		strh	r2, [r3, #8]
 163:../Generated_Code/DrvI2c0.c ****           I2C_PDD_WriteDataReg(I2C0_BASE_PTR, *(DeviceDataPrv->OutPtrM)++); /* Send character */
 155              		.loc 1 163 0
 156 00bc 5F4A     		ldr	r2, .L14
 157 00be BB68     		ldr	r3, [r7, #8]
 158 00c0 DB68     		ldr	r3, [r3, #12]
 159 00c2 1978     		ldrb	r1, [r3]
 160 00c4 1171     		strb	r1, [r2, #4]
 161 00c6 5A1C     		add	r2, r3, #1
 162 00c8 BB68     		ldr	r3, [r7, #8]
 163 00ca DA60     		str	r2, [r3, #12]
 164 00cc A9E0     		b	.L5
 165              	.L6:
 164:../Generated_Code/DrvI2c0.c ****         }
 165:../Generated_Code/DrvI2c0.c ****         else {
 166:../Generated_Code/DrvI2c0.c ****           if (DeviceDataPrv->InpLenM != 0x00U) { /* Is any char. for reception? */
 166              		.loc 1 166 0
 167 00ce BB68     		ldr	r3, [r7, #8]
 168 00d0 5B88     		ldrh	r3, [r3, #2]
 169 00d2 002B     		cmp	r3, #0
 170 00d4 1FD0     		beq	.L7
 167:../Generated_Code/DrvI2c0.c ****             if (DeviceDataPrv->InpLenM == 0x01U) { /* If only one char to receive */
 171              		.loc 1 167 0
 172 00d6 BB68     		ldr	r3, [r7, #8]
 173 00d8 5B88     		ldrh	r3, [r3, #2]
 174 00da 012B     		cmp	r3, #1
 175 00dc 08D1     		bne	.L8
 168:../Generated_Code/DrvI2c0.c ****               I2C_PDD_EnableTransmitAcknowledge(I2C0_BASE_PTR, PDD_DISABLE); /* then transmit ACK d
 176              		.loc 1 168 0
 177 00de 574B     		ldr	r3, .L14
 178 00e0 564A     		ldr	r2, .L14
 179 00e2 9278     		ldrb	r2, [r2, #2]
 180 00e4 D2B2     		uxtb	r2, r2
 181 00e6 0821     		mov	r1, #8
 182 00e8 0A43     		orr	r2, r1
 183 00ea D2B2     		uxtb	r2, r2
 184 00ec 9A70     		strb	r2, [r3, #2]
 185 00ee 07E0     		b	.L9
 186              	.L8:
 169:../Generated_Code/DrvI2c0.c ****             } else {
 170:../Generated_Code/DrvI2c0.c ****               I2C_PDD_EnableTransmitAcknowledge(I2C0_BASE_PTR, PDD_ENABLE); /* else transmit ACK en
 187              		.loc 1 170 0
 188 00f0 524B     		ldr	r3, .L14
 189 00f2 524A     		ldr	r2, .L14
 190 00f4 9278     		ldrb	r2, [r2, #2]
 191 00f6 D2B2     		uxtb	r2, r2
 192 00f8 0821     		mov	r1, #8
 193 00fa 8A43     		bic	r2, r1
 194 00fc D2B2     		uxtb	r2, r2
 195 00fe 9A70     		strb	r2, [r3, #2]
 196              	.L9:
 171:../Generated_Code/DrvI2c0.c ****             }
 172:../Generated_Code/DrvI2c0.c ****             I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode */
 197              		.loc 1 172 0
 198 0100 4E4B     		ldr	r3, .L14
 199 0102 4E4A     		ldr	r2, .L14
 200 0104 9278     		ldrb	r2, [r2, #2]
 201 0106 D2B2     		uxtb	r2, r2
 202 0108 1021     		mov	r1, #16
 203 010a 8A43     		bic	r2, r1
 204 010c D2B2     		uxtb	r2, r2
 205 010e 9A70     		strb	r2, [r3, #2]
 173:../Generated_Code/DrvI2c0.c ****             (void)I2C_PDD_ReadDataReg(I2C0_BASE_PTR); /* Dummy read character */
 206              		.loc 1 173 0
 207 0110 4A4B     		ldr	r3, .L14
 208 0112 1B79     		ldrb	r3, [r3, #4]
 209 0114 85E0     		b	.L5
 210              	.L7:
 174:../Generated_Code/DrvI2c0.c ****           }
 175:../Generated_Code/DrvI2c0.c ****           else {
 176:../Generated_Code/DrvI2c0.c ****             DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* Clear flag "busy" */
 211              		.loc 1 176 0
 212 0116 BB68     		ldr	r3, [r7, #8]
 213 0118 1B78     		ldrb	r3, [r3]
 214 011a 0122     		mov	r2, #1
 215 011c 9343     		bic	r3, r2
 216 011e DAB2     		uxtb	r2, r3
 217 0120 BB68     		ldr	r3, [r7, #8]
 218 0122 1A70     		strb	r2, [r3]
 177:../Generated_Code/DrvI2c0.c ****             if (DeviceDataPrv->SendStop == LDD_I2C_SEND_STOP) {
 219              		.loc 1 177 0
 220 0124 BB68     		ldr	r3, [r7, #8]
 221 0126 5B78     		ldrb	r3, [r3, #1]
 222 0128 012B     		cmp	r3, #1
 223 012a 0FD1     		bne	.L10
 178:../Generated_Code/DrvI2c0.c ****               I2C_PDD_SetMasterMode(I2C0_BASE_PTR, I2C_PDD_SLAVE_MODE); /* Switch device to slave m
 224              		.loc 1 178 0
 225 012c 434B     		ldr	r3, .L14
 226 012e 434A     		ldr	r2, .L14
 227 0130 9278     		ldrb	r2, [r2, #2]
 228 0132 D2B2     		uxtb	r2, r2
 229 0134 2021     		mov	r1, #32
 230 0136 8A43     		bic	r2, r1
 231 0138 D2B2     		uxtb	r2, r2
 232 013a 9A70     		strb	r2, [r3, #2]
 179:../Generated_Code/DrvI2c0.c ****               I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode */
 233              		.loc 1 179 0
 234 013c 3F4B     		ldr	r3, .L14
 235 013e 3F4A     		ldr	r2, .L14
 236 0140 9278     		ldrb	r2, [r2, #2]
 237 0142 D2B2     		uxtb	r2, r2
 238 0144 1021     		mov	r1, #16
 239 0146 8A43     		bic	r2, r1
 240 0148 D2B2     		uxtb	r2, r2
 241 014a 9A70     		strb	r2, [r3, #2]
 242              	.L10:
 180:../Generated_Code/DrvI2c0.c ****             }
 181:../Generated_Code/DrvI2c0.c ****             DrvI2c0_OnMasterBlockSent(DeviceDataPrv->UserData); /* Invoke OnMasterBlockSent event *
 243              		.loc 1 181 0
 244 014c BB68     		ldr	r3, [r7, #8]
 245 014e 9B69     		ldr	r3, [r3, #24]
 246 0150 181C     		mov	r0, r3
 247 0152 FFF7FEFF 		bl	DrvI2c0_OnMasterBlockSent
 248 0156 64E0     		b	.L5
 249              	.L3:
 182:../Generated_Code/DrvI2c0.c ****           }
 183:../Generated_Code/DrvI2c0.c ****         }
 184:../Generated_Code/DrvI2c0.c ****       }
 185:../Generated_Code/DrvI2c0.c ****     }
 186:../Generated_Code/DrvI2c0.c ****     else {
 187:../Generated_Code/DrvI2c0.c ****       DeviceDataPrv->InpLenM--;        /* Decrease number of chars for the receive */
 250              		.loc 1 187 0
 251 0158 BB68     		ldr	r3, [r7, #8]
 252 015a 5B88     		ldrh	r3, [r3, #2]
 253 015c 013B     		sub	r3, r3, #1
 254 015e 9AB2     		uxth	r2, r3
 255 0160 BB68     		ldr	r3, [r7, #8]
 256 0162 5A80     		strh	r2, [r3, #2]
 188:../Generated_Code/DrvI2c0.c ****       if (DeviceDataPrv->InpLenM != 0x00U) { /* Is any char. for reception? */
 257              		.loc 1 188 0
 258 0164 BB68     		ldr	r3, [r7, #8]
 259 0166 5B88     		ldrh	r3, [r3, #2]
 260 0168 002B     		cmp	r3, #0
 261 016a 0CD0     		beq	.L11
 189:../Generated_Code/DrvI2c0.c ****         if (DeviceDataPrv->InpLenM == 0x01U) {
 262              		.loc 1 189 0
 263 016c BB68     		ldr	r3, [r7, #8]
 264 016e 5B88     		ldrh	r3, [r3, #2]
 265 0170 012B     		cmp	r3, #1
 266 0172 1FD1     		bne	.L12
 190:../Generated_Code/DrvI2c0.c ****           I2C_PDD_EnableTransmitAcknowledge(I2C0_BASE_PTR, PDD_DISABLE); /* Transmit NACK */
 267              		.loc 1 190 0
 268 0174 314B     		ldr	r3, .L14
 269 0176 314A     		ldr	r2, .L14
 270 0178 9278     		ldrb	r2, [r2, #2]
 271 017a D2B2     		uxtb	r2, r2
 272 017c 0821     		mov	r1, #8
 273 017e 0A43     		orr	r2, r1
 274 0180 D2B2     		uxtb	r2, r2
 275 0182 9A70     		strb	r2, [r3, #2]
 276 0184 16E0     		b	.L12
 277              	.L11:
 191:../Generated_Code/DrvI2c0.c ****         }
 192:../Generated_Code/DrvI2c0.c ****       } else {
 193:../Generated_Code/DrvI2c0.c ****         DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* Clear flag "busy" */
 278              		.loc 1 193 0
 279 0186 BB68     		ldr	r3, [r7, #8]
 280 0188 1B78     		ldrb	r3, [r3]
 281 018a 0122     		mov	r2, #1
 282 018c 9343     		bic	r3, r2
 283 018e DAB2     		uxtb	r2, r3
 284 0190 BB68     		ldr	r3, [r7, #8]
 285 0192 1A70     		strb	r2, [r3]
 194:../Generated_Code/DrvI2c0.c ****         I2C_PDD_SetMasterMode(I2C0_BASE_PTR, I2C_PDD_SLAVE_MODE); /* If no, switch device to slave 
 286              		.loc 1 194 0
 287 0194 294B     		ldr	r3, .L14
 288 0196 294A     		ldr	r2, .L14
 289 0198 9278     		ldrb	r2, [r2, #2]
 290 019a D2B2     		uxtb	r2, r2
 291 019c 2021     		mov	r1, #32
 292 019e 8A43     		bic	r2, r1
 293 01a0 D2B2     		uxtb	r2, r2
 294 01a2 9A70     		strb	r2, [r3, #2]
 195:../Generated_Code/DrvI2c0.c ****         I2C_PDD_EnableTransmitAcknowledge(I2C0_BASE_PTR, PDD_ENABLE); /* Transmit ACK */
 295              		.loc 1 195 0
 296 01a4 254B     		ldr	r3, .L14
 297 01a6 254A     		ldr	r2, .L14
 298 01a8 9278     		ldrb	r2, [r2, #2]
 299 01aa D2B2     		uxtb	r2, r2
 300 01ac 0821     		mov	r1, #8
 301 01ae 8A43     		bic	r2, r1
 302 01b0 D2B2     		uxtb	r2, r2
 303 01b2 9A70     		strb	r2, [r3, #2]
 304              	.L12:
 196:../Generated_Code/DrvI2c0.c ****       }
 197:../Generated_Code/DrvI2c0.c ****       *(DeviceDataPrv->InpPtrM)++ = I2C_PDD_ReadDataReg(I2C0_BASE_PTR); /* Receive character */
 305              		.loc 1 197 0
 306 01b4 BB68     		ldr	r3, [r7, #8]
 307 01b6 5B68     		ldr	r3, [r3, #4]
 308 01b8 204A     		ldr	r2, .L14
 309 01ba 1279     		ldrb	r2, [r2, #4]
 310 01bc D2B2     		uxtb	r2, r2
 311 01be 1A70     		strb	r2, [r3]
 312 01c0 5A1C     		add	r2, r3, #1
 313 01c2 BB68     		ldr	r3, [r7, #8]
 314 01c4 5A60     		str	r2, [r3, #4]
 198:../Generated_Code/DrvI2c0.c ****       if (DeviceDataPrv->InpLenM == 0x00U) { /* Is any char. for reception? */
 315              		.loc 1 198 0
 316 01c6 BB68     		ldr	r3, [r7, #8]
 317 01c8 5B88     		ldrh	r3, [r3, #2]
 318 01ca 002B     		cmp	r3, #0
 319 01cc 29D1     		bne	.L5
 199:../Generated_Code/DrvI2c0.c ****         DrvI2c0_OnMasterBlockReceived(DeviceDataPrv->UserData); /* Invoke OnMasterBlockReceived eve
 320              		.loc 1 199 0
 321 01ce BB68     		ldr	r3, [r7, #8]
 322 01d0 9B69     		ldr	r3, [r3, #24]
 323 01d2 181C     		mov	r0, r3
 324 01d4 FFF7FEFF 		bl	DrvI2c0_OnMasterBlockReceived
 325 01d8 23E0     		b	.L5
 326              	.L2:
 200:../Generated_Code/DrvI2c0.c ****       }
 201:../Generated_Code/DrvI2c0.c ****     }
 202:../Generated_Code/DrvI2c0.c ****   } else {
 203:../Generated_Code/DrvI2c0.c ****     if ((Status & I2C_PDD_ARBIT_LOST) != 0x00U) { /* Arbitration lost? */
 327              		.loc 1 203 0
 328 01da 221C     		mov	r2, r4
 329 01dc 1023     		mov	r3, #16
 330 01de 1340     		and	r3, r2
 331 01e0 1FD0     		beq	.L5
 204:../Generated_Code/DrvI2c0.c ****       DeviceDataPrv->OutLenM = 0x00U;  /* Any character is not for sent */
 332              		.loc 1 204 0
 333 01e2 BB68     		ldr	r3, [r7, #8]
 334 01e4 0022     		mov	r2, #0
 335 01e6 1A81     		strh	r2, [r3, #8]
 205:../Generated_Code/DrvI2c0.c ****       DeviceDataPrv->InpLenM = 0x00U;  /* Any character is not for reception */
 336              		.loc 1 205 0
 337 01e8 BB68     		ldr	r3, [r7, #8]
 338 01ea 0022     		mov	r2, #0
 339 01ec 5A80     		strh	r2, [r3, #2]
 206:../Generated_Code/DrvI2c0.c ****       DeviceDataPrv->SendStop = LDD_I2C_SEND_STOP; /* Set variable for sending stop condition (for 
 340              		.loc 1 206 0
 341 01ee BB68     		ldr	r3, [r7, #8]
 342 01f0 0122     		mov	r2, #1
 343 01f2 5A70     		strb	r2, [r3, #1]
 207:../Generated_Code/DrvI2c0.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* Any character is not for sent or 
 344              		.loc 1 207 0
 345 01f4 BB68     		ldr	r3, [r7, #8]
 346 01f6 1B78     		ldrb	r3, [r3]
 347 01f8 0122     		mov	r2, #1
 348 01fa 9343     		bic	r3, r2
 349 01fc DAB2     		uxtb	r2, r3
 350 01fe BB68     		ldr	r3, [r7, #8]
 351 0200 1A70     		strb	r2, [r3]
 208:../Generated_Code/DrvI2c0.c ****       I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode */
 352              		.loc 1 208 0
 353 0202 0E4B     		ldr	r3, .L14
 354 0204 0D4A     		ldr	r2, .L14
 355 0206 9278     		ldrb	r2, [r2, #2]
 356 0208 D2B2     		uxtb	r2, r2
 357 020a 1021     		mov	r1, #16
 358 020c 8A43     		bic	r2, r1
 359 020e D2B2     		uxtb	r2, r2
 360 0210 9A70     		strb	r2, [r3, #2]
 209:../Generated_Code/DrvI2c0.c ****       ErrorMask |= LDD_I2C_ARBIT_LOST; /* Set the ArbitLost error mask */
 361              		.loc 1 209 0
 362 0212 3B1C     		mov	r3, r7
 363 0214 0E33     		add	r3, r3, #14
 364 0216 3A1C     		mov	r2, r7
 365 0218 0E32     		add	r2, r2, #14
 366 021a 1288     		ldrh	r2, [r2]
 367 021c 0421     		mov	r1, #4
 368 021e 0A43     		orr	r2, r1
 369 0220 1A80     		strh	r2, [r3]
 370              	.L5:
 210:../Generated_Code/DrvI2c0.c ****     }
 211:../Generated_Code/DrvI2c0.c ****   }
 212:../Generated_Code/DrvI2c0.c ****   if (ErrorMask != 0x00U) {            /* Is any error mask set? */
 371              		.loc 1 212 0
 372 0222 3B1C     		mov	r3, r7
 373 0224 0E33     		add	r3, r3, #14
 374 0226 1B88     		ldrh	r3, [r3]
 375 0228 002B     		cmp	r3, #0
 376 022a 04D0     		beq	.L1
 213:../Generated_Code/DrvI2c0.c ****     DrvI2c0_OnError(DeviceDataPrv->UserData); /* If yes then invoke user event */
 377              		.loc 1 213 0
 378 022c BB68     		ldr	r3, [r7, #8]
 379 022e 9B69     		ldr	r3, [r3, #24]
 380 0230 181C     		mov	r0, r3
 381 0232 FFF7FEFF 		bl	DrvI2c0_OnError
 382              	.L1:
 214:../Generated_Code/DrvI2c0.c ****   }
 215:../Generated_Code/DrvI2c0.c **** }
 383              		.loc 1 215 0
 384 0236 BD46     		mov	sp, r7
 385 0238 05B0     		add	sp, sp, #20
 386              		@ sp needed for prologue
 387 023a 90BD     		pop	{r4, r7, pc}
 388              	.L15:
 389              		.align	2
 390              	.L14:
 391 023c 00600640 		.word	1074159616
 392              		.cfi_endproc
 393              	.LFE0:
 395              		.section	.text.DrvI2c0_Init,"ax",%progbits
 396              		.align	2
 397              		.global	DrvI2c0_Init
 398              		.code	16
 399              		.thumb_func
 401              	DrvI2c0_Init:
 402              	.LFB1:
 216:../Generated_Code/DrvI2c0.c **** 
 217:../Generated_Code/DrvI2c0.c **** /*
 218:../Generated_Code/DrvI2c0.c **** ** ===================================================================
 219:../Generated_Code/DrvI2c0.c **** **     Method      :  DrvI2c0_Init (component I2C_LDD)
 220:../Generated_Code/DrvI2c0.c **** **
 221:../Generated_Code/DrvI2c0.c **** **     Description :
 222:../Generated_Code/DrvI2c0.c **** **         Initializes the device. Allocates memory for the device data
 223:../Generated_Code/DrvI2c0.c **** **         structure, allocates interrupt vectors and sets interrupt
 224:../Generated_Code/DrvI2c0.c **** **         priority, sets pin routing, sets timing, etc.
 225:../Generated_Code/DrvI2c0.c **** **         If the "Enable in init. code" is set to "yes" value then the
 226:../Generated_Code/DrvI2c0.c **** **         device is also enabled(see the description of the Enable()
 227:../Generated_Code/DrvI2c0.c **** **         method). In this case the Enable() method is not necessary
 228:../Generated_Code/DrvI2c0.c **** **         and needn't to be generated. 
 229:../Generated_Code/DrvI2c0.c **** **         This method can be called only once. Before the second call
 230:../Generated_Code/DrvI2c0.c **** **         of Init() the Deinit() must be called first.
 231:../Generated_Code/DrvI2c0.c **** **     Parameters  :
 232:../Generated_Code/DrvI2c0.c **** **         NAME            - DESCRIPTION
 233:../Generated_Code/DrvI2c0.c **** **       * UserDataPtr     - Pointer to the user or
 234:../Generated_Code/DrvI2c0.c **** **                           RTOS specific data. This pointer will be
 235:../Generated_Code/DrvI2c0.c **** **                           passed as an event or callback parameter.
 236:../Generated_Code/DrvI2c0.c **** **     Returns     :
 237:../Generated_Code/DrvI2c0.c **** **         ---             - Pointer to the device data structure. 
 238:../Generated_Code/DrvI2c0.c **** ** ===================================================================
 239:../Generated_Code/DrvI2c0.c **** */
 240:../Generated_Code/DrvI2c0.c **** LDD_TDeviceData* DrvI2c0_Init(LDD_TUserData *UserDataPtr)
 241:../Generated_Code/DrvI2c0.c **** {
 403              		.loc 1 241 0
 404              		.cfi_startproc
 405 0000 80B5     		push	{r7, lr}
 406              	.LCFI3:
 407              		.cfi_def_cfa_offset 8
 408              		.cfi_offset 7, -8
 409              		.cfi_offset 14, -4
 410 0002 84B0     		sub	sp, sp, #16
 411              	.LCFI4:
 412              		.cfi_def_cfa_offset 24
 413 0004 00AF     		add	r7, sp, #0
 414              	.LCFI5:
 415              		.cfi_def_cfa_register 7
 416 0006 7860     		str	r0, [r7, #4]
 242:../Generated_Code/DrvI2c0.c ****   /* Allocate HAL device structure */
 243:../Generated_Code/DrvI2c0.c ****   DrvI2c0_TDeviceData *DeviceDataPrv;
 244:../Generated_Code/DrvI2c0.c ****   /* {MQXLite RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer 
 245:../Generated_Code/DrvI2c0.c ****   DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 417              		.loc 1 245 0
 418 0008 3E4B     		ldr	r3, .L18
 419 000a FB60     		str	r3, [r7, #12]
 246:../Generated_Code/DrvI2c0.c **** 
 247:../Generated_Code/DrvI2c0.c ****   DeviceDataPrv->UserData = UserDataPtr; /* Store the RTOS device structure */
 420              		.loc 1 247 0
 421 000c FB68     		ldr	r3, [r7, #12]
 422 000e 7A68     		ldr	r2, [r7, #4]
 423 0010 9A61     		str	r2, [r3, #24]
 248:../Generated_Code/DrvI2c0.c **** 
 249:../Generated_Code/DrvI2c0.c ****   /* Allocate interrupt vector */
 250:../Generated_Code/DrvI2c0.c ****   /* {MQXLite RTOS Adapter} Save old and set new interrupt vector (function handler and ISR paramet
 251:../Generated_Code/DrvI2c0.c ****   /* Note: Exception handler for interrupt is not saved, because it is not modified */
 252:../Generated_Code/DrvI2c0.c ****   DeviceDataPrv->SavedISRSettings.isrData = _int_get_isr_data(LDD_ivIndex_INT_I2C0);
 424              		.loc 1 252 0
 425 0012 1820     		mov	r0, #24
 426 0014 FFF7FEFF 		bl	_int_get_isr_data
 427 0018 021C     		mov	r2, r0
 428 001a FB68     		ldr	r3, [r7, #12]
 429 001c 5A61     		str	r2, [r3, #20]
 253:../Generated_Code/DrvI2c0.c ****   DeviceDataPrv->SavedISRSettings.isrFunction = _int_install_isr(LDD_ivIndex_INT_I2C0, DrvI2c0_Inte
 430              		.loc 1 253 0
 431 001e 3A4A     		ldr	r2, .L18+4
 432 0020 FB68     		ldr	r3, [r7, #12]
 433 0022 1820     		mov	r0, #24
 434 0024 111C     		mov	r1, r2
 435 0026 1A1C     		mov	r2, r3
 436 0028 FFF7FEFF 		bl	_int_install_isr
 437 002c 021C     		mov	r2, r0
 438 002e FB68     		ldr	r3, [r7, #12]
 439 0030 1A61     		str	r2, [r3, #16]
 254:../Generated_Code/DrvI2c0.c ****   DeviceDataPrv->SerFlag = 0x00U;      /* Reset all flags */
 440              		.loc 1 254 0
 441 0032 FB68     		ldr	r3, [r7, #12]
 442 0034 0022     		mov	r2, #0
 443 0036 1A70     		strb	r2, [r3]
 255:../Generated_Code/DrvI2c0.c ****   DeviceDataPrv->SendStop = LDD_I2C_SEND_STOP; /* Set variable for sending stop condition (for mast
 444              		.loc 1 255 0
 445 0038 FB68     		ldr	r3, [r7, #12]
 446 003a 0122     		mov	r2, #1
 447 003c 5A70     		strb	r2, [r3, #1]
 256:../Generated_Code/DrvI2c0.c ****   DeviceDataPrv->InpLenM = 0x00U;      /* Set zero counter of data of reception */
 448              		.loc 1 256 0
 449 003e FB68     		ldr	r3, [r7, #12]
 450 0040 0022     		mov	r2, #0
 451 0042 5A80     		strh	r2, [r3, #2]
 257:../Generated_Code/DrvI2c0.c ****   DeviceDataPrv->OutLenM = 0x00U;      /* Set zero counter of data of transmission */
 452              		.loc 1 257 0
 453 0044 FB68     		ldr	r3, [r7, #12]
 454 0046 0022     		mov	r2, #0
 455 0048 1A81     		strh	r2, [r3, #8]
 258:../Generated_Code/DrvI2c0.c ****   /* SIM_SCGC4: I2C0=1 */
 259:../Generated_Code/DrvI2c0.c ****   SIM_SCGC4 |= SIM_SCGC4_I2C0_MASK;                                                   
 456              		.loc 1 259 0
 457 004a 304A     		ldr	r2, .L18+8
 458 004c 2F49     		ldr	r1, .L18+8
 459 004e 304B     		ldr	r3, .L18+12
 460 0050 CB58     		ldr	r3, [r1, r3]
 461 0052 4021     		mov	r1, #64
 462 0054 1943     		orr	r1, r3
 463 0056 2E4B     		ldr	r3, .L18+12
 464 0058 D150     		str	r1, [r2, r3]
 260:../Generated_Code/DrvI2c0.c ****   /* I2C0_C1: IICEN=0,IICIE=0,MST=0,TX=0,TXAK=0,RSTA=0,WUEN=0,DMAEN=0 */
 261:../Generated_Code/DrvI2c0.c ****   I2C0_C1 = 0x00U;                     /* Clear control register */
 465              		.loc 1 261 0
 466 005a 2E4B     		ldr	r3, .L18+16
 467 005c 0022     		mov	r2, #0
 468 005e 9A70     		strb	r2, [r3, #2]
 262:../Generated_Code/DrvI2c0.c ****   /* I2C0_FLT: SHEN=0,STOPF=1,STOPIE=0,FLT=0 */
 263:../Generated_Code/DrvI2c0.c ****   I2C0_FLT = I2C_FLT_STOPF_MASK;       /* Clear bus status interrupt flags */
 469              		.loc 1 263 0
 470 0060 2C4B     		ldr	r3, .L18+16
 471 0062 4022     		mov	r2, #64
 472 0064 9A71     		strb	r2, [r3, #6]
 264:../Generated_Code/DrvI2c0.c ****   /* I2C0_S: TCF=0,IAAS=0,BUSY=0,ARBL=0,RAM=0,SRW=0,IICIF=1,RXAK=0 */
 265:../Generated_Code/DrvI2c0.c ****   I2C0_S = I2C_S_IICIF_MASK;           /* Clear interrupt flag */
 473              		.loc 1 265 0
 474 0066 2B4B     		ldr	r3, .L18+16
 475 0068 0222     		mov	r2, #2
 476 006a DA70     		strb	r2, [r3, #3]
 266:../Generated_Code/DrvI2c0.c ****   /* PORTE_PCR25: ISF=0,MUX=5 */
 267:../Generated_Code/DrvI2c0.c ****   PORTE_PCR25 = (uint32_t)((PORTE_PCR25 & (uint32_t)~(uint32_t)(
 477              		.loc 1 267 0
 478 006c 2A4B     		ldr	r3, .L18+20
 479 006e 2A4A     		ldr	r2, .L18+20
 480 0070 516E     		ldr	r1, [r2, #100]
 481 0072 2A4A     		ldr	r2, .L18+24
 482 0074 0A40     		and	r2, r1
 483 0076 A021     		mov	r1, #160
 484 0078 C900     		lsl	r1, r1, #3
 485 007a 0A43     		orr	r2, r1
 486 007c 5A66     		str	r2, [r3, #100]
 268:../Generated_Code/DrvI2c0.c ****                  PORT_PCR_ISF_MASK |
 269:../Generated_Code/DrvI2c0.c ****                  PORT_PCR_MUX(0x02)
 270:../Generated_Code/DrvI2c0.c ****                 )) | (uint32_t)(
 271:../Generated_Code/DrvI2c0.c ****                  PORT_PCR_MUX(0x05)
 272:../Generated_Code/DrvI2c0.c ****                 ));                                                  
 273:../Generated_Code/DrvI2c0.c ****   /* PORTE_PCR24: ISF=0,MUX=5 */
 274:../Generated_Code/DrvI2c0.c ****   PORTE_PCR24 = (uint32_t)((PORTE_PCR24 & (uint32_t)~(uint32_t)(
 487              		.loc 1 274 0
 488 007e 264B     		ldr	r3, .L18+20
 489 0080 254A     		ldr	r2, .L18+20
 490 0082 116E     		ldr	r1, [r2, #96]
 491 0084 254A     		ldr	r2, .L18+24
 492 0086 0A40     		and	r2, r1
 493 0088 A021     		mov	r1, #160
 494 008a C900     		lsl	r1, r1, #3
 495 008c 0A43     		orr	r2, r1
 496 008e 1A66     		str	r2, [r3, #96]
 275:../Generated_Code/DrvI2c0.c ****                  PORT_PCR_ISF_MASK |
 276:../Generated_Code/DrvI2c0.c ****                  PORT_PCR_MUX(0x02)
 277:../Generated_Code/DrvI2c0.c ****                 )) | (uint32_t)(
 278:../Generated_Code/DrvI2c0.c ****                  PORT_PCR_MUX(0x05)
 279:../Generated_Code/DrvI2c0.c ****                 ));                                                  
 280:../Generated_Code/DrvI2c0.c ****   /* NVIC_IPR2: PRI_8=0x80 */
 281:../Generated_Code/DrvI2c0.c ****   NVIC_IPR2 = (uint32_t)((NVIC_IPR2 & (uint32_t)~(uint32_t)(
 497              		.loc 1 281 0
 498 0090 234A     		ldr	r2, .L18+28
 499 0092 2349     		ldr	r1, .L18+28
 500 0094 C223     		mov	r3, #194
 501 0096 9B00     		lsl	r3, r3, #2
 502 0098 CB58     		ldr	r3, [r1, r3]
 503 009a FF21     		mov	r1, #255
 504 009c 8B43     		bic	r3, r1
 505 009e 8021     		mov	r1, #128
 506 00a0 1943     		orr	r1, r3
 507 00a2 C223     		mov	r3, #194
 508 00a4 9B00     		lsl	r3, r3, #2
 509 00a6 D150     		str	r1, [r2, r3]
 282:../Generated_Code/DrvI2c0.c ****                NVIC_IP_PRI_8(0x7F)
 283:../Generated_Code/DrvI2c0.c ****               )) | (uint32_t)(
 284:../Generated_Code/DrvI2c0.c ****                NVIC_IP_PRI_8(0x80)
 285:../Generated_Code/DrvI2c0.c ****               ));                                                  
 286:../Generated_Code/DrvI2c0.c ****   /* NVIC_ISER: SETENA|=0x0100 */
 287:../Generated_Code/DrvI2c0.c ****   NVIC_ISER |= NVIC_ISER_SETENA(0x0100);                                                   
 510              		.loc 1 287 0
 511 00a8 1D4B     		ldr	r3, .L18+28
 512 00aa 1D4A     		ldr	r2, .L18+28
 513 00ac 1268     		ldr	r2, [r2]
 514 00ae 8021     		mov	r1, #128
 515 00b0 4900     		lsl	r1, r1, #1
 516 00b2 0A43     		orr	r2, r1
 517 00b4 1A60     		str	r2, [r3]
 288:../Generated_Code/DrvI2c0.c ****   /* I2C0_C2: GCAEN=0,ADEXT=0,HDRS=0,SBRC=0,RMEN=0,AD=0 */
 289:../Generated_Code/DrvI2c0.c ****   I2C0_C2 = 0x00U;                                                   
 518              		.loc 1 289 0
 519 00b6 174B     		ldr	r3, .L18+16
 520 00b8 0022     		mov	r2, #0
 521 00ba 5A71     		strb	r2, [r3, #5]
 290:../Generated_Code/DrvI2c0.c ****   /* I2C0_FLT: SHEN=0,STOPF=0,STOPIE=0,FLT=0 */
 291:../Generated_Code/DrvI2c0.c ****   I2C0_FLT = 0x00U;                    /* Set glitch filter register */
 522              		.loc 1 291 0
 523 00bc 154B     		ldr	r3, .L18+16
 524 00be 0022     		mov	r2, #0
 525 00c0 9A71     		strb	r2, [r3, #6]
 292:../Generated_Code/DrvI2c0.c ****   /* I2C0_SMB: FACK=0,ALERTEN=0,SIICAEN=0,TCKSEL=0,SLTF=1,SHTF1=0,SHTF2=0,SHTF2IE=0 */
 293:../Generated_Code/DrvI2c0.c ****   I2C0_SMB = I2C_SMB_SLTF_MASK;                                                   
 526              		.loc 1 293 0
 527 00c2 144B     		ldr	r3, .L18+16
 528 00c4 0822     		mov	r2, #8
 529 00c6 1A72     		strb	r2, [r3, #8]
 294:../Generated_Code/DrvI2c0.c ****   /* I2C0_F: MULT=0,ICR=0x25 */
 295:../Generated_Code/DrvI2c0.c ****   I2C0_F = I2C_F_ICR(0x25);            /* Set prescaler bits */
 530              		.loc 1 295 0
 531 00c8 124B     		ldr	r3, .L18+16
 532 00ca 2522     		mov	r2, #37
 533 00cc 5A70     		strb	r2, [r3, #1]
 296:../Generated_Code/DrvI2c0.c ****   I2C_PDD_EnableDevice(I2C0_BASE_PTR, PDD_ENABLE); /* Enable device */
 534              		.loc 1 296 0
 535 00ce 114B     		ldr	r3, .L18+16
 536 00d0 104A     		ldr	r2, .L18+16
 537 00d2 9278     		ldrb	r2, [r2, #2]
 538 00d4 D2B2     		uxtb	r2, r2
 539 00d6 D2B2     		uxtb	r2, r2
 540 00d8 8021     		mov	r1, #128
 541 00da 4942     		neg	r1, r1
 542 00dc 0A43     		orr	r2, r1
 543 00de D2B2     		uxtb	r2, r2
 544 00e0 D2B2     		uxtb	r2, r2
 545 00e2 9A70     		strb	r2, [r3, #2]
 297:../Generated_Code/DrvI2c0.c ****   I2C_PDD_EnableInterrupt(I2C0_BASE_PTR); /* Enable interrupt */
 546              		.loc 1 297 0
 547 00e4 0B4B     		ldr	r3, .L18+16
 548 00e6 0B4A     		ldr	r2, .L18+16
 549 00e8 9278     		ldrb	r2, [r2, #2]
 550 00ea D2B2     		uxtb	r2, r2
 551 00ec 4021     		mov	r1, #64
 552 00ee 0A43     		orr	r2, r1
 553 00f0 D2B2     		uxtb	r2, r2
 554 00f2 9A70     		strb	r2, [r3, #2]
 298:../Generated_Code/DrvI2c0.c ****   /* Registration of the device structure */
 299:../Generated_Code/DrvI2c0.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_DrvI2c0_ID,DeviceDataPrv);
 555              		.loc 1 299 0
 556 00f4 0B4B     		ldr	r3, .L18+32
 557 00f6 FA68     		ldr	r2, [r7, #12]
 558 00f8 1A61     		str	r2, [r3, #16]
 300:../Generated_Code/DrvI2c0.c ****   return ((LDD_TDeviceData *)DeviceDataPrv); /* Return pointer to the data data structure */
 559              		.loc 1 300 0
 560 00fa FB68     		ldr	r3, [r7, #12]
 301:../Generated_Code/DrvI2c0.c **** }
 561              		.loc 1 301 0
 562 00fc 181C     		mov	r0, r3
 563 00fe BD46     		mov	sp, r7
 564 0100 04B0     		add	sp, sp, #16
 565              		@ sp needed for prologue
 566 0102 80BD     		pop	{r7, pc}
 567              	.L19:
 568              		.align	2
 569              	.L18:
 570 0104 00000000 		.word	DeviceDataPrv__DEFAULT_RTOS_ALLOC
 571 0108 00000000 		.word	DrvI2c0_Interrupt
 572 010c 00700440 		.word	1074032640
 573 0110 34100000 		.word	4148
 574 0114 00600640 		.word	1074159616
 575 0118 00D00440 		.word	1074057216
 576 011c FFF8FFFE 		.word	-16779009
 577 0120 00E100E0 		.word	-536813312
 578 0124 00000000 		.word	PE_LDD_DeviceDataList
 579              		.cfi_endproc
 580              	.LFE1:
 582              		.section	.text.DrvI2c0_Deinit,"ax",%progbits
 583              		.align	2
 584              		.global	DrvI2c0_Deinit
 585              		.code	16
 586              		.thumb_func
 588              	DrvI2c0_Deinit:
 589              	.LFB2:
 302:../Generated_Code/DrvI2c0.c **** 
 303:../Generated_Code/DrvI2c0.c **** /*
 304:../Generated_Code/DrvI2c0.c **** ** ===================================================================
 305:../Generated_Code/DrvI2c0.c **** **     Method      :  DrvI2c0_Deinit (component I2C_LDD)
 306:../Generated_Code/DrvI2c0.c **** **
 307:../Generated_Code/DrvI2c0.c **** **     Description :
 308:../Generated_Code/DrvI2c0.c **** **         Deinitializes the device. Switches off the device, frees the
 309:../Generated_Code/DrvI2c0.c **** **         device data structure memory, interrupts vectors, etc.
 310:../Generated_Code/DrvI2c0.c **** **     Parameters  :
 311:../Generated_Code/DrvI2c0.c **** **         NAME            - DESCRIPTION
 312:../Generated_Code/DrvI2c0.c **** **       * DeviceDataPtr   - Device data structure
 313:../Generated_Code/DrvI2c0.c **** **                           pointer returned by <Init> method.
 314:../Generated_Code/DrvI2c0.c **** **     Returns     : Nothing
 315:../Generated_Code/DrvI2c0.c **** ** ===================================================================
 316:../Generated_Code/DrvI2c0.c **** */
 317:../Generated_Code/DrvI2c0.c **** void DrvI2c0_Deinit(LDD_TDeviceData *DeviceDataPtr)
 318:../Generated_Code/DrvI2c0.c **** {
 590              		.loc 1 318 0
 591              		.cfi_startproc
 592 0000 80B5     		push	{r7, lr}
 593              	.LCFI6:
 594              		.cfi_def_cfa_offset 8
 595              		.cfi_offset 7, -8
 596              		.cfi_offset 14, -4
 597 0002 82B0     		sub	sp, sp, #8
 598              	.LCFI7:
 599              		.cfi_def_cfa_offset 16
 600 0004 00AF     		add	r7, sp, #0
 601              	.LCFI8:
 602              		.cfi_def_cfa_register 7
 603 0006 7860     		str	r0, [r7, #4]
 319:../Generated_Code/DrvI2c0.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 320:../Generated_Code/DrvI2c0.c **** 
 321:../Generated_Code/DrvI2c0.c ****   /* I2C0_C1: IICEN=0,IICIE=0,MST=0,TX=0,TXAK=0,RSTA=0,WUEN=0,DMAEN=0 */
 322:../Generated_Code/DrvI2c0.c ****   I2C0_C1 = 0x00U;                     /* Reset I2C Control register */
 604              		.loc 1 322 0
 605 0008 0D4B     		ldr	r3, .L21
 606 000a 0022     		mov	r2, #0
 607 000c 9A70     		strb	r2, [r3, #2]
 323:../Generated_Code/DrvI2c0.c ****   /* Restoring the interrupt vector */
 324:../Generated_Code/DrvI2c0.c ****   /* {MQXLite RTOS Adapter} Restore interrupt vector (function handler and ISR parameter) */
 325:../Generated_Code/DrvI2c0.c ****   /* Note: Exception handler for interrupt is not restored, because it was not modified */
 326:../Generated_Code/DrvI2c0.c ****   (void)_int_install_isr(LDD_ivIndex_INT_I2C0, ((DrvI2c0_TDeviceDataPtr)DeviceDataPtr)->SavedISRSet
 608              		.loc 1 326 0
 609 000e 7B68     		ldr	r3, [r7, #4]
 610 0010 1A69     		ldr	r2, [r3, #16]
 611 0012 7B68     		ldr	r3, [r7, #4]
 612 0014 5B69     		ldr	r3, [r3, #20]
 613 0016 1820     		mov	r0, #24
 614 0018 111C     		mov	r1, r2
 615 001a 1A1C     		mov	r2, r3
 616 001c FFF7FEFF 		bl	_int_install_isr
 327:../Generated_Code/DrvI2c0.c ****   /* Unregistration of the device structure */
 328:../Generated_Code/DrvI2c0.c ****   PE_LDD_UnregisterDeviceStructure(PE_LDD_COMPONENT_DrvI2c0_ID);
 617              		.loc 1 328 0
 618 0020 084B     		ldr	r3, .L21+4
 619 0022 0022     		mov	r2, #0
 620 0024 1A61     		str	r2, [r3, #16]
 329:../Generated_Code/DrvI2c0.c ****   /* Deallocation of the device structure */
 330:../Generated_Code/DrvI2c0.c ****   /* {MQXLite RTOS Adapter} Driver memory deallocation: Dynamic allocation is simulated, no dealloc
 331:../Generated_Code/DrvI2c0.c ****   /* SIM_SCGC4: I2C0=0 */
 332:../Generated_Code/DrvI2c0.c ****   SIM_SCGC4 &= (uint32_t)~(uint32_t)(SIM_SCGC4_I2C0_MASK);                                         
 621              		.loc 1 332 0
 622 0026 084A     		ldr	r2, .L21+8
 623 0028 0749     		ldr	r1, .L21+8
 624 002a 084B     		ldr	r3, .L21+12
 625 002c CB58     		ldr	r3, [r1, r3]
 626 002e 4021     		mov	r1, #64
 627 0030 181C     		mov	r0, r3
 628 0032 8843     		bic	r0, r1
 629 0034 011C     		mov	r1, r0
 630 0036 054B     		ldr	r3, .L21+12
 631 0038 D150     		str	r1, [r2, r3]
 333:../Generated_Code/DrvI2c0.c **** }
 632              		.loc 1 333 0
 633 003a BD46     		mov	sp, r7
 634 003c 02B0     		add	sp, sp, #8
 635              		@ sp needed for prologue
 636 003e 80BD     		pop	{r7, pc}
 637              	.L22:
 638              		.align	2
 639              	.L21:
 640 0040 00600640 		.word	1074159616
 641 0044 00000000 		.word	PE_LDD_DeviceDataList
 642 0048 00700440 		.word	1074032640
 643 004c 34100000 		.word	4148
 644              		.cfi_endproc
 645              	.LFE2:
 647              		.section	.text.DrvI2c0_MasterSendBlock,"ax",%progbits
 648              		.align	2
 649              		.global	DrvI2c0_MasterSendBlock
 650              		.code	16
 651              		.thumb_func
 653              	DrvI2c0_MasterSendBlock:
 654              	.LFB3:
 334:../Generated_Code/DrvI2c0.c **** 
 335:../Generated_Code/DrvI2c0.c **** /*
 336:../Generated_Code/DrvI2c0.c **** ** ===================================================================
 337:../Generated_Code/DrvI2c0.c **** **     Method      :  DrvI2c0_MasterSendBlock (component I2C_LDD)
 338:../Generated_Code/DrvI2c0.c **** **
 339:../Generated_Code/DrvI2c0.c **** **     Description :
 340:../Generated_Code/DrvI2c0.c **** **         This method writes one (7-bit addressing) or two (10-bit
 341:../Generated_Code/DrvI2c0.c **** **         addressing) slave address bytes inclusive of R/W bit = 0 to
 342:../Generated_Code/DrvI2c0.c **** **         the I2C bus and then writes the block of characters to the
 343:../Generated_Code/DrvI2c0.c **** **         bus. The slave address must be specified before, by the
 344:../Generated_Code/DrvI2c0.c **** **         "SelectSlaveDevice" method or in component initialization
 345:../Generated_Code/DrvI2c0.c **** **         section, "Target slave address init" property. If the method
 346:../Generated_Code/DrvI2c0.c **** **         returns ERR_OK, it doesn't mean that transmission was
 347:../Generated_Code/DrvI2c0.c **** **         successful. The state of transmission is detectable by means
 348:../Generated_Code/DrvI2c0.c **** **         of events (OnMasterSendComplete or OnError). Data to be sent
 349:../Generated_Code/DrvI2c0.c **** **         are not copied to an internal buffer and remains in the
 350:../Generated_Code/DrvI2c0.c **** **         original location. Therefore the content of the buffer
 351:../Generated_Code/DrvI2c0.c **** **         should not be changed until the transmission is complete.
 352:../Generated_Code/DrvI2c0.c **** **         Event "OnMasterBlockSent"can be used to detect the end of
 353:../Generated_Code/DrvI2c0.c **** **         the transmission. This method is available only for the
 354:../Generated_Code/DrvI2c0.c **** **         MASTER or MASTER - SLAVE mode.
 355:../Generated_Code/DrvI2c0.c **** **     Parameters  :
 356:../Generated_Code/DrvI2c0.c **** **         NAME            - DESCRIPTION
 357:../Generated_Code/DrvI2c0.c **** **       * DeviceDataPtr   - Device data structure
 358:../Generated_Code/DrvI2c0.c **** **                           pointer returned by <Init> method.
 359:../Generated_Code/DrvI2c0.c **** **       * BufferPtr       - Pointer to the block of data
 360:../Generated_Code/DrvI2c0.c **** **                           to send.
 361:../Generated_Code/DrvI2c0.c **** **         Size            - Size of the data block.
 362:../Generated_Code/DrvI2c0.c **** **         SendStop        - Parameter for generating I2C
 363:../Generated_Code/DrvI2c0.c **** **                           Stop condition
 364:../Generated_Code/DrvI2c0.c **** **                           LDD_I2C_SEND_STOP - Stop condition is
 365:../Generated_Code/DrvI2c0.c **** **                           generated on end transmission.
 366:../Generated_Code/DrvI2c0.c **** **                           LDD_I2C_NO_SEND_STOP - Stop condition isn't
 367:../Generated_Code/DrvI2c0.c **** **                           generated on end transmission.
 368:../Generated_Code/DrvI2c0.c **** **     Returns     :
 369:../Generated_Code/DrvI2c0.c **** **         ---             - Error code, possible codes:
 370:../Generated_Code/DrvI2c0.c **** **                           ERR_OK - OK
 371:../Generated_Code/DrvI2c0.c **** **                           ERR_DISABLED -  Device is disabled
 372:../Generated_Code/DrvI2c0.c **** **                           ERR_SPEED - This device does not work in
 373:../Generated_Code/DrvI2c0.c **** **                           the active clock configuration
 374:../Generated_Code/DrvI2c0.c **** **                           ERR_BUSY - The I2C device is now running
 375:../Generated_Code/DrvI2c0.c **** ** ===================================================================
 376:../Generated_Code/DrvI2c0.c **** */
 377:../Generated_Code/DrvI2c0.c **** LDD_TError DrvI2c0_MasterSendBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, LDD_I2C_TS
 378:../Generated_Code/DrvI2c0.c **** {
 655              		.loc 1 378 0
 656              		.cfi_startproc
 657 0000 80B5     		push	{r7, lr}
 658              	.LCFI9:
 659              		.cfi_def_cfa_offset 8
 660              		.cfi_offset 7, -8
 661              		.cfi_offset 14, -4
 662 0002 86B0     		sub	sp, sp, #24
 663              	.LCFI10:
 664              		.cfi_def_cfa_offset 32
 665 0004 00AF     		add	r7, sp, #0
 666              	.LCFI11:
 667              		.cfi_def_cfa_register 7
 668 0006 F860     		str	r0, [r7, #12]
 669 0008 B960     		str	r1, [r7, #8]
 670 000a 111C     		mov	r1, r2
 671 000c 1A1C     		mov	r2, r3
 672 000e BB1D     		add	r3, r7, #6
 673 0010 1980     		strh	r1, [r3]
 674 0012 7B1D     		add	r3, r7, #5
 675 0014 1A70     		strb	r2, [r3]
 379:../Generated_Code/DrvI2c0.c ****   DrvI2c0_TDeviceData *DeviceDataPrv = (DrvI2c0_TDeviceData *)DeviceDataPtr;
 676              		.loc 1 379 0
 677 0016 FB68     		ldr	r3, [r7, #12]
 678 0018 7B61     		str	r3, [r7, #20]
 380:../Generated_Code/DrvI2c0.c **** 
 381:../Generated_Code/DrvI2c0.c ****   if (Size == 0x00U) {                 /* Test variable Size on zero */
 679              		.loc 1 381 0
 680 001a BB1D     		add	r3, r7, #6
 681 001c 1B88     		ldrh	r3, [r3]
 682 001e 002B     		cmp	r3, #0
 683 0020 01D1     		bne	.L24
 382:../Generated_Code/DrvI2c0.c ****     return ERR_OK;                     /* If zero then OK */
 684              		.loc 1 382 0
 685 0022 0023     		mov	r3, #0
 686 0024 60E0     		b	.L25
 687              	.L24:
 383:../Generated_Code/DrvI2c0.c ****   }
 384:../Generated_Code/DrvI2c0.c ****   if (DeviceDataPrv->SendStop == LDD_I2C_SEND_STOP) {
 688              		.loc 1 384 0
 689 0026 7B69     		ldr	r3, [r7, #20]
 690 0028 5B78     		ldrb	r3, [r3, #1]
 691 002a 012B     		cmp	r3, #1
 692 002c 12D1     		bne	.L26
 385:../Generated_Code/DrvI2c0.c ****     if ((I2C_PDD_GetBusStatus(I2C0_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 693              		.loc 1 385 0
 694 002e 304B     		ldr	r3, .L32
 695 0030 DB78     		ldrb	r3, [r3, #3]
 696 0032 DBB2     		uxtb	r3, r3
 697 0034 1A1C     		mov	r2, r3
 698 0036 2023     		mov	r3, #32
 699 0038 1340     		and	r3, r2
 700 003a 09D1     		bne	.L27
 386:../Generated_Code/DrvI2c0.c ****        ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 701              		.loc 1 386 0
 702 003c 7B69     		ldr	r3, [r7, #20]
 703 003e 1B78     		ldrb	r3, [r3]
 704 0040 1A1C     		mov	r2, r3
 705 0042 0123     		mov	r3, #1
 706 0044 1340     		and	r3, r2
 385:../Generated_Code/DrvI2c0.c ****     if ((I2C_PDD_GetBusStatus(I2C0_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 707              		.loc 1 385 0
 708 0046 03D1     		bne	.L27
 387:../Generated_Code/DrvI2c0.c ****        (DeviceDataPrv->OutLenM != 0x00U))  {
 709              		.loc 1 387 0
 710 0048 7B69     		ldr	r3, [r7, #20]
 711 004a 1B89     		ldrh	r3, [r3, #8]
 386:../Generated_Code/DrvI2c0.c ****        ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 712              		.loc 1 386 0
 713 004c 002B     		cmp	r3, #0
 714 004e 0DD0     		beq	.L28
 715              	.L27:
 388:../Generated_Code/DrvI2c0.c ****       return ERR_BUSY;                 /* If yes then error */
 716              		.loc 1 388 0
 717 0050 0823     		mov	r3, #8
 718 0052 49E0     		b	.L25
 719              	.L26:
 389:../Generated_Code/DrvI2c0.c ****     }
 390:../Generated_Code/DrvI2c0.c ****   } else {
 391:../Generated_Code/DrvI2c0.c ****     if (((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 720              		.loc 1 391 0
 721 0054 7B69     		ldr	r3, [r7, #20]
 722 0056 1B78     		ldrb	r3, [r3]
 723 0058 1A1C     		mov	r2, r3
 724 005a 0123     		mov	r3, #1
 725 005c 1340     		and	r3, r2
 726 005e 03D1     		bne	.L29
 392:../Generated_Code/DrvI2c0.c ****       (DeviceDataPrv->OutLenM != 0x00U))  {
 727              		.loc 1 392 0
 728 0060 7B69     		ldr	r3, [r7, #20]
 729 0062 1B89     		ldrh	r3, [r3, #8]
 391:../Generated_Code/DrvI2c0.c ****     if (((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 730              		.loc 1 391 0
 731 0064 002B     		cmp	r3, #0
 732 0066 01D0     		beq	.L28
 733              	.L29:
 393:../Generated_Code/DrvI2c0.c ****       return ERR_BUSY;                 /* If yes then error */
 734              		.loc 1 393 0
 735 0068 0823     		mov	r3, #8
 736 006a 3DE0     		b	.L25
 737              	.L28:
 394:../Generated_Code/DrvI2c0.c ****     }
 395:../Generated_Code/DrvI2c0.c ****   }
 396:../Generated_Code/DrvI2c0.c ****   /* {MQXLite RTOS Adapter} Critical section begin (RTOS function call is defined by MQXLite RTOS A
 397:../Generated_Code/DrvI2c0.c ****   _int_disable();
 738              		.loc 1 397 0
 739 006c FFF7FEFF 		bl	_int_disable
 398:../Generated_Code/DrvI2c0.c ****   DeviceDataPrv->SerFlag |= MASTER_IN_PROGRES; /* Set flag "busy" */
 740              		.loc 1 398 0
 741 0070 7B69     		ldr	r3, [r7, #20]
 742 0072 1B78     		ldrb	r3, [r3]
 743 0074 0122     		mov	r2, #1
 744 0076 1343     		orr	r3, r2
 745 0078 DAB2     		uxtb	r2, r3
 746 007a 7B69     		ldr	r3, [r7, #20]
 747 007c 1A70     		strb	r2, [r3]
 399:../Generated_Code/DrvI2c0.c ****   DeviceDataPrv->OutPtrM = (uint8_t *)BufferPtr; /* Save pointer to data for transmitting */
 748              		.loc 1 399 0
 749 007e 7B69     		ldr	r3, [r7, #20]
 750 0080 BA68     		ldr	r2, [r7, #8]
 751 0082 DA60     		str	r2, [r3, #12]
 400:../Generated_Code/DrvI2c0.c ****   DeviceDataPrv->OutLenM = Size;       /* Set the counter of output bufer's content */
 752              		.loc 1 400 0
 753 0084 7B69     		ldr	r3, [r7, #20]
 754 0086 BA1D     		add	r2, r7, #6
 755 0088 1288     		ldrh	r2, [r2]
 756 008a 1A81     		strh	r2, [r3, #8]
 401:../Generated_Code/DrvI2c0.c ****   DeviceDataPrv->SendStop = SendStop;  /* Set generating stop condition */
 757              		.loc 1 401 0
 758 008c 7B69     		ldr	r3, [r7, #20]
 759 008e 7A1D     		add	r2, r7, #5
 760 0090 1278     		ldrb	r2, [r2]
 761 0092 5A70     		strb	r2, [r3, #1]
 402:../Generated_Code/DrvI2c0.c ****   I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_TX_DIRECTION); /* Set TX mode */
 762              		.loc 1 402 0
 763 0094 164B     		ldr	r3, .L32
 764 0096 164A     		ldr	r2, .L32
 765 0098 9278     		ldrb	r2, [r2, #2]
 766 009a D2B2     		uxtb	r2, r2
 767 009c D2B2     		uxtb	r2, r2
 768 009e 1021     		mov	r1, #16
 769 00a0 0A43     		orr	r2, r1
 770 00a2 D2B2     		uxtb	r2, r2
 771 00a4 D2B2     		uxtb	r2, r2
 772 00a6 9A70     		strb	r2, [r3, #2]
 403:../Generated_Code/DrvI2c0.c ****   if (I2C_PDD_GetMasterMode(I2C0_BASE_PTR) == I2C_PDD_MASTER_MODE) { /* Is device in master mode? *
 773              		.loc 1 403 0
 774 00a8 114B     		ldr	r3, .L32
 775 00aa 9B78     		ldrb	r3, [r3, #2]
 776 00ac DBB2     		uxtb	r3, r3
 777 00ae 1A1C     		mov	r2, r3
 778 00b0 2023     		mov	r3, #32
 779 00b2 1340     		and	r3, r2
 780 00b4 08D0     		beq	.L30
 404:../Generated_Code/DrvI2c0.c ****     I2C_PDD_RepeatStart(I2C0_BASE_PTR); /* If yes then repeat start cycle generated */
 781              		.loc 1 404 0
 782 00b6 0E4B     		ldr	r3, .L32
 783 00b8 0D4A     		ldr	r2, .L32
 784 00ba 9278     		ldrb	r2, [r2, #2]
 785 00bc D2B2     		uxtb	r2, r2
 786 00be 0421     		mov	r1, #4
 787 00c0 0A43     		orr	r2, r1
 788 00c2 D2B2     		uxtb	r2, r2
 789 00c4 9A70     		strb	r2, [r3, #2]
 790 00c6 09E0     		b	.L31
 791              	.L30:
 405:../Generated_Code/DrvI2c0.c ****   } else {
 406:../Generated_Code/DrvI2c0.c ****     I2C_PDD_SetMasterMode(I2C0_BASE_PTR, I2C_PDD_MASTER_MODE); /* If no then start signal generated
 792              		.loc 1 406 0
 793 00c8 094B     		ldr	r3, .L32
 794 00ca 094A     		ldr	r2, .L32
 795 00cc 9278     		ldrb	r2, [r2, #2]
 796 00ce D2B2     		uxtb	r2, r2
 797 00d0 D2B2     		uxtb	r2, r2
 798 00d2 2021     		mov	r1, #32
 799 00d4 0A43     		orr	r2, r1
 800 00d6 D2B2     		uxtb	r2, r2
 801 00d8 D2B2     		uxtb	r2, r2
 802 00da 9A70     		strb	r2, [r3, #2]
 803              	.L31:
 407:../Generated_Code/DrvI2c0.c ****   }
 408:../Generated_Code/DrvI2c0.c ****   I2C_PDD_WriteDataReg(I2C0_BASE_PTR, 0x3AU); /* Send slave address */
 804              		.loc 1 408 0
 805 00dc 044B     		ldr	r3, .L32
 806 00de 3A22     		mov	r2, #58
 807 00e0 1A71     		strb	r2, [r3, #4]
 409:../Generated_Code/DrvI2c0.c ****   /* {MQXLite RTOS Adapter} Critical section ends (RTOS function call is defined by MQXLite RTOS Ad
 410:../Generated_Code/DrvI2c0.c ****   _int_enable();
 808              		.loc 1 410 0
 809 00e2 FFF7FEFF 		bl	_int_enable
 411:../Generated_Code/DrvI2c0.c ****   return ERR_OK;                       /* OK */
 810              		.loc 1 411 0
 811 00e6 0023     		mov	r3, #0
 812              	.L25:
 412:../Generated_Code/DrvI2c0.c **** }
 813              		.loc 1 412 0
 814 00e8 181C     		mov	r0, r3
 815 00ea BD46     		mov	sp, r7
 816 00ec 06B0     		add	sp, sp, #24
 817              		@ sp needed for prologue
 818 00ee 80BD     		pop	{r7, pc}
 819              	.L33:
 820              		.align	2
 821              	.L32:
 822 00f0 00600640 		.word	1074159616
 823              		.cfi_endproc
 824              	.LFE3:
 826              		.section	.text.DrvI2c0_MasterReceiveBlock,"ax",%progbits
 827              		.align	2
 828              		.global	DrvI2c0_MasterReceiveBlock
 829              		.code	16
 830              		.thumb_func
 832              	DrvI2c0_MasterReceiveBlock:
 833              	.LFB4:
 413:../Generated_Code/DrvI2c0.c **** 
 414:../Generated_Code/DrvI2c0.c **** /*
 415:../Generated_Code/DrvI2c0.c **** ** ===================================================================
 416:../Generated_Code/DrvI2c0.c **** **     Method      :  DrvI2c0_MasterReceiveBlock (component I2C_LDD)
 417:../Generated_Code/DrvI2c0.c **** **
 418:../Generated_Code/DrvI2c0.c **** **     Description :
 419:../Generated_Code/DrvI2c0.c **** **         This method writes one (7-bit addressing) or two (10-bit
 420:../Generated_Code/DrvI2c0.c **** **         addressing) slave address bytes inclusive of R/W bit = 1 to
 421:../Generated_Code/DrvI2c0.c **** **         the I2C bus and then receives the block of characters from
 422:../Generated_Code/DrvI2c0.c **** **         the bus. The slave address must be specified before, by the
 423:../Generated_Code/DrvI2c0.c **** **         "SelectSlaveDevice" method or in component initialization
 424:../Generated_Code/DrvI2c0.c **** **         section, "Target slave address init" property. If the method
 425:../Generated_Code/DrvI2c0.c **** **         returns ERR_OK, it doesn't mean that reception was
 426:../Generated_Code/DrvI2c0.c **** **         successful. The state of reception is detectable by means of
 427:../Generated_Code/DrvI2c0.c **** **         events (OnMasterSendComplete  or OnError). Data to be
 428:../Generated_Code/DrvI2c0.c **** **         received are not copied to an internal buffer and remains in
 429:../Generated_Code/DrvI2c0.c **** **         the original location. Therefore the content of the buffer
 430:../Generated_Code/DrvI2c0.c **** **         should not be changed until the transmission is complete.
 431:../Generated_Code/DrvI2c0.c **** **         Event "OnMasterBlockReceived"can be used to detect the end
 432:../Generated_Code/DrvI2c0.c **** **         of the reception. This method is available only for the
 433:../Generated_Code/DrvI2c0.c **** **         MASTER or MASTER - SLAVE mode.
 434:../Generated_Code/DrvI2c0.c **** **     Parameters  :
 435:../Generated_Code/DrvI2c0.c **** **         NAME            - DESCRIPTION
 436:../Generated_Code/DrvI2c0.c **** **       * DeviceDataPtr   - Device data structure
 437:../Generated_Code/DrvI2c0.c **** **                           pointer returned by <Init> method.
 438:../Generated_Code/DrvI2c0.c **** **       * BufferPtr       - Pointer to a buffer where
 439:../Generated_Code/DrvI2c0.c **** **                           received characters will be stored.
 440:../Generated_Code/DrvI2c0.c **** **         Size            - The size of the block.
 441:../Generated_Code/DrvI2c0.c **** **         SendStop        - Parameter for generating I2C
 442:../Generated_Code/DrvI2c0.c **** **                           Stop condition
 443:../Generated_Code/DrvI2c0.c **** **                           LDD_I2C_SEND_STOP - Stop condition is
 444:../Generated_Code/DrvI2c0.c **** **                           generated on end transmission.
 445:../Generated_Code/DrvI2c0.c **** **                           LDD_I2C_NO_SEND_STOP - Stop condition isn't
 446:../Generated_Code/DrvI2c0.c **** **                           generated on end transmission.
 447:../Generated_Code/DrvI2c0.c **** **     Returns     :
 448:../Generated_Code/DrvI2c0.c **** **         ---             - Error code, possible codes:
 449:../Generated_Code/DrvI2c0.c **** **                           ERR_OK - OK
 450:../Generated_Code/DrvI2c0.c **** **                           ERR_DISABLED -  Device is disabled
 451:../Generated_Code/DrvI2c0.c **** **                           ERR_SPEED - This device does not work in
 452:../Generated_Code/DrvI2c0.c **** **                           the active clock configuration
 453:../Generated_Code/DrvI2c0.c **** **                           ERR_BUSY - The master device is busy
 454:../Generated_Code/DrvI2c0.c **** **                           ERR_NOTAVAIL - It is not possible to
 455:../Generated_Code/DrvI2c0.c **** **                           receive data if general call address is set.
 456:../Generated_Code/DrvI2c0.c **** **                           ERR_PARAM_MODE -  Stop condition isn't
 457:../Generated_Code/DrvI2c0.c **** **                           possible generated on end transmission.
 458:../Generated_Code/DrvI2c0.c **** ** ===================================================================
 459:../Generated_Code/DrvI2c0.c **** */
 460:../Generated_Code/DrvI2c0.c **** LDD_TError DrvI2c0_MasterReceiveBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, LDD_I2C
 461:../Generated_Code/DrvI2c0.c **** {
 834              		.loc 1 461 0
 835              		.cfi_startproc
 836 0000 80B5     		push	{r7, lr}
 837              	.LCFI12:
 838              		.cfi_def_cfa_offset 8
 839              		.cfi_offset 7, -8
 840              		.cfi_offset 14, -4
 841 0002 86B0     		sub	sp, sp, #24
 842              	.LCFI13:
 843              		.cfi_def_cfa_offset 32
 844 0004 00AF     		add	r7, sp, #0
 845              	.LCFI14:
 846              		.cfi_def_cfa_register 7
 847 0006 F860     		str	r0, [r7, #12]
 848 0008 B960     		str	r1, [r7, #8]
 849 000a 111C     		mov	r1, r2
 850 000c 1A1C     		mov	r2, r3
 851 000e BB1D     		add	r3, r7, #6
 852 0010 1980     		strh	r1, [r3]
 853 0012 7B1D     		add	r3, r7, #5
 854 0014 1A70     		strb	r2, [r3]
 462:../Generated_Code/DrvI2c0.c ****   DrvI2c0_TDeviceData *DeviceDataPrv = (DrvI2c0_TDeviceData *)DeviceDataPtr;
 855              		.loc 1 462 0
 856 0016 FB68     		ldr	r3, [r7, #12]
 857 0018 7B61     		str	r3, [r7, #20]
 463:../Generated_Code/DrvI2c0.c **** 
 464:../Generated_Code/DrvI2c0.c ****   if (Size == 0x00U) {                 /* Test variable Size on zero */
 858              		.loc 1 464 0
 859 001a BB1D     		add	r3, r7, #6
 860 001c 1B88     		ldrh	r3, [r3]
 861 001e 002B     		cmp	r3, #0
 862 0020 01D1     		bne	.L35
 465:../Generated_Code/DrvI2c0.c ****     return ERR_OK;                     /* If zero then OK */
 863              		.loc 1 465 0
 864 0022 0023     		mov	r3, #0
 865 0024 66E0     		b	.L36
 866              	.L35:
 466:../Generated_Code/DrvI2c0.c ****   }
 467:../Generated_Code/DrvI2c0.c ****   if (SendStop == LDD_I2C_NO_SEND_STOP) { /* Test variable SendStop on supported value */
 867              		.loc 1 467 0
 868 0026 7B1D     		add	r3, r7, #5
 869 0028 1B78     		ldrb	r3, [r3]
 870 002a 002B     		cmp	r3, #0
 871 002c 01D1     		bne	.L37
 468:../Generated_Code/DrvI2c0.c ****     return ERR_PARAM_MODE;             /* If not supported value then error */
 872              		.loc 1 468 0
 873 002e 8123     		mov	r3, #129
 874 0030 60E0     		b	.L36
 875              	.L37:
 469:../Generated_Code/DrvI2c0.c ****   }
 470:../Generated_Code/DrvI2c0.c ****   if (DeviceDataPrv->SendStop == LDD_I2C_SEND_STOP) {
 876              		.loc 1 470 0
 877 0032 7B69     		ldr	r3, [r7, #20]
 878 0034 5B78     		ldrb	r3, [r3, #1]
 879 0036 012B     		cmp	r3, #1
 880 0038 12D1     		bne	.L38
 471:../Generated_Code/DrvI2c0.c ****     if ((I2C_PDD_GetBusStatus(I2C0_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 881              		.loc 1 471 0
 882 003a 304B     		ldr	r3, .L44
 883 003c DB78     		ldrb	r3, [r3, #3]
 884 003e DBB2     		uxtb	r3, r3
 885 0040 1A1C     		mov	r2, r3
 886 0042 2023     		mov	r3, #32
 887 0044 1340     		and	r3, r2
 888 0046 09D1     		bne	.L39
 472:../Generated_Code/DrvI2c0.c ****       ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 889              		.loc 1 472 0
 890 0048 7B69     		ldr	r3, [r7, #20]
 891 004a 1B78     		ldrb	r3, [r3]
 892 004c 1A1C     		mov	r2, r3
 893 004e 0123     		mov	r3, #1
 894 0050 1340     		and	r3, r2
 471:../Generated_Code/DrvI2c0.c ****     if ((I2C_PDD_GetBusStatus(I2C0_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 895              		.loc 1 471 0
 896 0052 03D1     		bne	.L39
 473:../Generated_Code/DrvI2c0.c ****       (DeviceDataPrv->InpLenM != 0x00U)) {
 897              		.loc 1 473 0
 898 0054 7B69     		ldr	r3, [r7, #20]
 899 0056 5B88     		ldrh	r3, [r3, #2]
 472:../Generated_Code/DrvI2c0.c ****       ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 900              		.loc 1 472 0
 901 0058 002B     		cmp	r3, #0
 902 005a 0DD0     		beq	.L40
 903              	.L39:
 474:../Generated_Code/DrvI2c0.c ****       return ERR_BUSY;                 /* If yes then error */
 904              		.loc 1 474 0
 905 005c 0823     		mov	r3, #8
 906 005e 49E0     		b	.L36
 907              	.L38:
 475:../Generated_Code/DrvI2c0.c ****     }
 476:../Generated_Code/DrvI2c0.c ****   } else {
 477:../Generated_Code/DrvI2c0.c ****     if(((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 908              		.loc 1 477 0
 909 0060 7B69     		ldr	r3, [r7, #20]
 910 0062 1B78     		ldrb	r3, [r3]
 911 0064 1A1C     		mov	r2, r3
 912 0066 0123     		mov	r3, #1
 913 0068 1340     		and	r3, r2
 914 006a 03D1     		bne	.L41
 478:../Generated_Code/DrvI2c0.c ****       (DeviceDataPrv->InpLenM != 0x00U)) {
 915              		.loc 1 478 0
 916 006c 7B69     		ldr	r3, [r7, #20]
 917 006e 5B88     		ldrh	r3, [r3, #2]
 477:../Generated_Code/DrvI2c0.c ****     if(((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 918              		.loc 1 477 0
 919 0070 002B     		cmp	r3, #0
 920 0072 01D0     		beq	.L40
 921              	.L41:
 479:../Generated_Code/DrvI2c0.c ****       return ERR_BUSY;               /* If yes then error */
 922              		.loc 1 479 0
 923 0074 0823     		mov	r3, #8
 924 0076 3DE0     		b	.L36
 925              	.L40:
 480:../Generated_Code/DrvI2c0.c ****     }
 481:../Generated_Code/DrvI2c0.c ****   }
 482:../Generated_Code/DrvI2c0.c ****   /* {MQXLite RTOS Adapter} Critical section begin (RTOS function call is defined by MQXLite RTOS A
 483:../Generated_Code/DrvI2c0.c ****   _int_disable();
 926              		.loc 1 483 0
 927 0078 FFF7FEFF 		bl	_int_disable
 484:../Generated_Code/DrvI2c0.c ****   DeviceDataPrv->SerFlag |= MASTER_IN_PROGRES; /* Set flag "busy" */
 928              		.loc 1 484 0
 929 007c 7B69     		ldr	r3, [r7, #20]
 930 007e 1B78     		ldrb	r3, [r3]
 931 0080 0122     		mov	r2, #1
 932 0082 1343     		orr	r3, r2
 933 0084 DAB2     		uxtb	r2, r3
 934 0086 7B69     		ldr	r3, [r7, #20]
 935 0088 1A70     		strb	r2, [r3]
 485:../Generated_Code/DrvI2c0.c ****   DeviceDataPrv->InpPtrM = (uint8_t *)BufferPtr; /* Save pointer to data for reception */
 936              		.loc 1 485 0
 937 008a 7B69     		ldr	r3, [r7, #20]
 938 008c BA68     		ldr	r2, [r7, #8]
 939 008e 5A60     		str	r2, [r3, #4]
 486:../Generated_Code/DrvI2c0.c ****   DeviceDataPrv->InpLenM = Size;       /* Set the counter of input bufer's content */
 940              		.loc 1 486 0
 941 0090 7B69     		ldr	r3, [r7, #20]
 942 0092 BA1D     		add	r2, r7, #6
 943 0094 1288     		ldrh	r2, [r2]
 944 0096 5A80     		strh	r2, [r3, #2]
 487:../Generated_Code/DrvI2c0.c ****   DeviceDataPrv->SendStop = SendStop;  /* Set generating stop condition */
 945              		.loc 1 487 0
 946 0098 7B69     		ldr	r3, [r7, #20]
 947 009a 7A1D     		add	r2, r7, #5
 948 009c 1278     		ldrb	r2, [r2]
 949 009e 5A70     		strb	r2, [r3, #1]
 488:../Generated_Code/DrvI2c0.c ****   I2C_PDD_SetTransmitMode(I2C0_BASE_PTR, I2C_PDD_TX_DIRECTION); /* Set TX mode */
 950              		.loc 1 488 0
 951 00a0 164B     		ldr	r3, .L44
 952 00a2 164A     		ldr	r2, .L44
 953 00a4 9278     		ldrb	r2, [r2, #2]
 954 00a6 D2B2     		uxtb	r2, r2
 955 00a8 D2B2     		uxtb	r2, r2
 956 00aa 1021     		mov	r1, #16
 957 00ac 0A43     		orr	r2, r1
 958 00ae D2B2     		uxtb	r2, r2
 959 00b0 D2B2     		uxtb	r2, r2
 960 00b2 9A70     		strb	r2, [r3, #2]
 489:../Generated_Code/DrvI2c0.c ****   if (I2C_PDD_GetMasterMode(I2C0_BASE_PTR) == I2C_PDD_MASTER_MODE) { /* Is device in master mode? *
 961              		.loc 1 489 0
 962 00b4 114B     		ldr	r3, .L44
 963 00b6 9B78     		ldrb	r3, [r3, #2]
 964 00b8 DBB2     		uxtb	r3, r3
 965 00ba 1A1C     		mov	r2, r3
 966 00bc 2023     		mov	r3, #32
 967 00be 1340     		and	r3, r2
 968 00c0 08D0     		beq	.L42
 490:../Generated_Code/DrvI2c0.c ****     I2C_PDD_RepeatStart(I2C0_BASE_PTR); /* If yes then repeat start cycle generated */
 969              		.loc 1 490 0
 970 00c2 0E4B     		ldr	r3, .L44
 971 00c4 0D4A     		ldr	r2, .L44
 972 00c6 9278     		ldrb	r2, [r2, #2]
 973 00c8 D2B2     		uxtb	r2, r2
 974 00ca 0421     		mov	r1, #4
 975 00cc 0A43     		orr	r2, r1
 976 00ce D2B2     		uxtb	r2, r2
 977 00d0 9A70     		strb	r2, [r3, #2]
 978 00d2 09E0     		b	.L43
 979              	.L42:
 491:../Generated_Code/DrvI2c0.c ****   } else {
 492:../Generated_Code/DrvI2c0.c ****     I2C_PDD_SetMasterMode(I2C0_BASE_PTR, I2C_PDD_MASTER_MODE); /* If no then start signal generated
 980              		.loc 1 492 0
 981 00d4 094B     		ldr	r3, .L44
 982 00d6 094A     		ldr	r2, .L44
 983 00d8 9278     		ldrb	r2, [r2, #2]
 984 00da D2B2     		uxtb	r2, r2
 985 00dc D2B2     		uxtb	r2, r2
 986 00de 2021     		mov	r1, #32
 987 00e0 0A43     		orr	r2, r1
 988 00e2 D2B2     		uxtb	r2, r2
 989 00e4 D2B2     		uxtb	r2, r2
 990 00e6 9A70     		strb	r2, [r3, #2]
 991              	.L43:
 493:../Generated_Code/DrvI2c0.c ****   }
 494:../Generated_Code/DrvI2c0.c ****   I2C_PDD_WriteDataReg(I2C0_BASE_PTR, 0x3BU); /* Send slave address */
 992              		.loc 1 494 0
 993 00e8 044B     		ldr	r3, .L44
 994 00ea 3B22     		mov	r2, #59
 995 00ec 1A71     		strb	r2, [r3, #4]
 495:../Generated_Code/DrvI2c0.c ****   /* {MQXLite RTOS Adapter} Critical section ends (RTOS function call is defined by MQXLite RTOS Ad
 496:../Generated_Code/DrvI2c0.c ****   _int_enable();
 996              		.loc 1 496 0
 997 00ee FFF7FEFF 		bl	_int_enable
 497:../Generated_Code/DrvI2c0.c ****   return ERR_OK;                       /* OK */
 998              		.loc 1 497 0
 999 00f2 0023     		mov	r3, #0
 1000              	.L36:
 498:../Generated_Code/DrvI2c0.c **** }
 1001              		.loc 1 498 0
 1002 00f4 181C     		mov	r0, r3
 1003 00f6 BD46     		mov	sp, r7
 1004 00f8 06B0     		add	sp, sp, #24
 1005              		@ sp needed for prologue
 1006 00fa 80BD     		pop	{r7, pc}
 1007              	.L45:
 1008              		.align	2
 1009              	.L44:
 1010 00fc 00600640 		.word	1074159616
 1011              		.cfi_endproc
 1012              	.LFE4:
 1014              		.section	.text.DrvI2c0_CheckBus,"ax",%progbits
 1015              		.align	2
 1016              		.global	DrvI2c0_CheckBus
 1017              		.code	16
 1018              		.thumb_func
 1020              	DrvI2c0_CheckBus:
 1021              	.LFB5:
 499:../Generated_Code/DrvI2c0.c **** 
 500:../Generated_Code/DrvI2c0.c **** /*
 501:../Generated_Code/DrvI2c0.c **** ** ===================================================================
 502:../Generated_Code/DrvI2c0.c **** **     Method      :  DrvI2c0_CheckBus (component I2C_LDD)
 503:../Generated_Code/DrvI2c0.c **** **
 504:../Generated_Code/DrvI2c0.c **** **     Description :
 505:../Generated_Code/DrvI2c0.c **** **         This method returns the status of the bus. If the START
 506:../Generated_Code/DrvI2c0.c **** **         condition has been detected, the method returns LDD_I2C_BUSY.
 507:../Generated_Code/DrvI2c0.c **** **         If the STOP condition has been detected, the method returns
 508:../Generated_Code/DrvI2c0.c **** **         LDD_I2C_IDLE.
 509:../Generated_Code/DrvI2c0.c **** **     Parameters  :
 510:../Generated_Code/DrvI2c0.c **** **         NAME            - DESCRIPTION
 511:../Generated_Code/DrvI2c0.c **** **       * DeviceDataPtr   - Device data structure
 512:../Generated_Code/DrvI2c0.c **** **                           pointer returned by <Init> method.
 513:../Generated_Code/DrvI2c0.c **** **       * BusStatePtr     - Pointer to a variable,
 514:../Generated_Code/DrvI2c0.c **** **                           where value of status is stored.
 515:../Generated_Code/DrvI2c0.c **** **     Returns     :
 516:../Generated_Code/DrvI2c0.c **** **         ---             - Error code, possible codes:
 517:../Generated_Code/DrvI2c0.c **** **                           ERR_OK - OK
 518:../Generated_Code/DrvI2c0.c **** **                           ERR_DISABLED -  Device is disabled
 519:../Generated_Code/DrvI2c0.c **** **                           ERR_SPEED - This device does not work in
 520:../Generated_Code/DrvI2c0.c **** **                           the active clock configuration
 521:../Generated_Code/DrvI2c0.c **** ** ===================================================================
 522:../Generated_Code/DrvI2c0.c **** */
 523:../Generated_Code/DrvI2c0.c **** LDD_TError DrvI2c0_CheckBus(LDD_TDeviceData *DeviceDataPtr, LDD_I2C_TBusState *BusStatePtr)
 524:../Generated_Code/DrvI2c0.c **** {
 1022              		.loc 1 524 0
 1023              		.cfi_startproc
 1024 0000 80B5     		push	{r7, lr}
 1025              	.LCFI15:
 1026              		.cfi_def_cfa_offset 8
 1027              		.cfi_offset 7, -8
 1028              		.cfi_offset 14, -4
 1029 0002 84B0     		sub	sp, sp, #16
 1030              	.LCFI16:
 1031              		.cfi_def_cfa_offset 24
 1032 0004 00AF     		add	r7, sp, #0
 1033              	.LCFI17:
 1034              		.cfi_def_cfa_register 7
 1035 0006 7860     		str	r0, [r7, #4]
 1036 0008 3960     		str	r1, [r7]
 525:../Generated_Code/DrvI2c0.c ****   DrvI2c0_TDeviceData *DeviceDataPrv = (DrvI2c0_TDeviceData *)DeviceDataPtr;
 1037              		.loc 1 525 0
 1038 000a 7B68     		ldr	r3, [r7, #4]
 1039 000c FB60     		str	r3, [r7, #12]
 526:../Generated_Code/DrvI2c0.c **** 
 527:../Generated_Code/DrvI2c0.c ****   (void)DeviceDataPrv;                 /* Suppress unused variable warning if needed */
 528:../Generated_Code/DrvI2c0.c ****   *BusStatePtr = (LDD_I2C_TBusState)((I2C_PDD_GetBusStatus(I2C0_BASE_PTR) == I2C_PDD_BUS_BUSY)?LDD_
 1040              		.loc 1 528 0
 1041 000e 084B     		ldr	r3, .L48
 1042 0010 DB78     		ldrb	r3, [r3, #3]
 1043 0012 DBB2     		uxtb	r3, r3
 1044 0014 1A1C     		mov	r2, r3
 1045 0016 2023     		mov	r3, #32
 1046 0018 1340     		and	r3, r2
 1047 001a 5A42     		neg	r2, r3
 1048 001c 5341     		adc	r3, r3, r2
 1049 001e DBB2     		uxtb	r3, r3
 1050 0020 DAB2     		uxtb	r2, r3
 1051 0022 3B68     		ldr	r3, [r7]
 1052 0024 1A70     		strb	r2, [r3]
 529:../Generated_Code/DrvI2c0.c ****   return ERR_OK;
 1053              		.loc 1 529 0
 1054 0026 0023     		mov	r3, #0
 530:../Generated_Code/DrvI2c0.c **** }
 1055              		.loc 1 530 0
 1056 0028 181C     		mov	r0, r3
 1057 002a BD46     		mov	sp, r7
 1058 002c 04B0     		add	sp, sp, #16
 1059              		@ sp needed for prologue
 1060 002e 80BD     		pop	{r7, pc}
 1061              	.L49:
 1062              		.align	2
 1063              	.L48:
 1064 0030 00600640 		.word	1074159616
 1065              		.cfi_endproc
 1066              	.LFE5:
 1068              		.text
 1069              	.Letext0:
 1070              		.file 2 "C:/Freescale/CW MCU v10.3/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 1071              		.file 3 "E:/CW103_Work_Space/Mqx_Lite_Test/Generated_Code/IO_Map.h"
 1072              		.file 4 "E:/CW103_Work_Space/Mqx_Lite_Test/Generated_Code/PE_LDD.h"
 1073              		.file 5 "E:/CW103_Work_Space/Mqx_Lite_Test/MQXLITE/psp/cortex_m/psptypes.h"
DEFINED SYMBOLS
                            *ABS*:00000000 DrvI2c0.c
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccf6HGXC.s:18     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccf6HGXC.s:21     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccf6HGXC.s:24     .text.DrvI2c0_Interrupt:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccf6HGXC.s:29     .text.DrvI2c0_Interrupt:00000000 DrvI2c0_Interrupt
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccf6HGXC.s:391    .text.DrvI2c0_Interrupt:0000023c $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccf6HGXC.s:396    .text.DrvI2c0_Init:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccf6HGXC.s:401    .text.DrvI2c0_Init:00000000 DrvI2c0_Init
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccf6HGXC.s:570    .text.DrvI2c0_Init:00000104 $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccf6HGXC.s:583    .text.DrvI2c0_Deinit:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccf6HGXC.s:588    .text.DrvI2c0_Deinit:00000000 DrvI2c0_Deinit
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccf6HGXC.s:640    .text.DrvI2c0_Deinit:00000040 $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccf6HGXC.s:648    .text.DrvI2c0_MasterSendBlock:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccf6HGXC.s:653    .text.DrvI2c0_MasterSendBlock:00000000 DrvI2c0_MasterSendBlock
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccf6HGXC.s:822    .text.DrvI2c0_MasterSendBlock:000000f0 $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccf6HGXC.s:827    .text.DrvI2c0_MasterReceiveBlock:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccf6HGXC.s:832    .text.DrvI2c0_MasterReceiveBlock:00000000 DrvI2c0_MasterReceiveBlock
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccf6HGXC.s:1010   .text.DrvI2c0_MasterReceiveBlock:000000fc $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccf6HGXC.s:1015   .text.DrvI2c0_CheckBus:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccf6HGXC.s:1020   .text.DrvI2c0_CheckBus:00000000 DrvI2c0_CheckBus
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccf6HGXC.s:1064   .text.DrvI2c0_CheckBus:00000030 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
DrvI2c0_OnMasterBlockSent
DrvI2c0_OnMasterBlockReceived
DrvI2c0_OnError
_int_get_isr_data
_int_install_isr
PE_LDD_DeviceDataList
_int_disable
_int_enable
