   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"DrvI2c1.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  18              		.align	2
  21              	DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  22 0000 00000000 		.space	32
  22      00000000 
  22      00000000 
  22      00000000 
  22      00000000 
  23              		.section	.text.DrvI2c1_Interrupt,"ax",%progbits
  24              		.align	2
  25              		.global	DrvI2c1_Interrupt
  26              		.code	16
  27              		.thumb_func
  29              	DrvI2c1_Interrupt:
  30              	.LFB0:
  31              		.file 1 "../Generated_Code/DrvI2c1.c"
   1:../Generated_Code/DrvI2c1.c **** /** ###################################################################
   2:../Generated_Code/DrvI2c1.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/DrvI2c1.c **** **     Filename    : DrvI2c1.c
   4:../Generated_Code/DrvI2c1.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/DrvI2c1.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/DrvI2c1.c **** **     Component   : I2C_LDD
   7:../Generated_Code/DrvI2c1.c **** **     Version     : Component 01.011, Driver 01.06, CPU db: 3.00.000
   8:../Generated_Code/DrvI2c1.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/DrvI2c1.c **** **     Date/Time   : 2013-03-18, 11:48, # CodeGen: 66
  10:../Generated_Code/DrvI2c1.c **** **     Abstract    :
  11:../Generated_Code/DrvI2c1.c **** **          This component encapsulates the internal I2C communication
  12:../Generated_Code/DrvI2c1.c **** **          interface. The implementation of the interface is based
  13:../Generated_Code/DrvI2c1.c **** **          on the Philips I2C-bus specification version 2.0.
  14:../Generated_Code/DrvI2c1.c **** **          Interface features:
  15:../Generated_Code/DrvI2c1.c **** **          MASTER mode
  16:../Generated_Code/DrvI2c1.c **** **            - Multi master communication
  17:../Generated_Code/DrvI2c1.c **** **            - The combined format of communication possible
  18:../Generated_Code/DrvI2c1.c **** **              (see SendStop parameter in MasterSend/ReceiveBlock method)
  19:../Generated_Code/DrvI2c1.c **** **            - 7-bit slave addressing (10-bit addressing can be made as well)
  20:../Generated_Code/DrvI2c1.c **** **            - Acknowledge polling provided
  21:../Generated_Code/DrvI2c1.c **** **            - No wait state initiated when a slave device holds the SCL line low
  22:../Generated_Code/DrvI2c1.c **** **            - Holding of the SCL line low by slave device recognized as 'not available bus'
  23:../Generated_Code/DrvI2c1.c **** **            - Invalid start/stop condition detection provided
  24:../Generated_Code/DrvI2c1.c **** **          SLAVE mode
  25:../Generated_Code/DrvI2c1.c **** **            - 7-bit slave addressing
  26:../Generated_Code/DrvI2c1.c **** **            - General call address detection provided
  27:../Generated_Code/DrvI2c1.c **** **     Settings    :
  28:../Generated_Code/DrvI2c1.c **** **          Component name                                 : DrvI2c1
  29:../Generated_Code/DrvI2c1.c **** **          I2C channel                                    : I2C1
  30:../Generated_Code/DrvI2c1.c **** **          Interrupt service                              : Enabled
  31:../Generated_Code/DrvI2c1.c **** **            Interrupt                                    : INT_I2C1
  32:../Generated_Code/DrvI2c1.c **** **            Interrupt priority                           : medium priority
  33:../Generated_Code/DrvI2c1.c **** **          Settings                                       : 
  34:../Generated_Code/DrvI2c1.c **** **            Mode selection                               : MASTER
  35:../Generated_Code/DrvI2c1.c **** **            MASTER mode                                  : Enabled
  36:../Generated_Code/DrvI2c1.c **** **              Initialization                             : 
  37:../Generated_Code/DrvI2c1.c **** **                Address mode                             : 7-bit addressing
  38:../Generated_Code/DrvI2c1.c **** **                Target slave address init                : 48
  39:../Generated_Code/DrvI2c1.c **** **            SLAVE mode                                   : Disabled
  40:../Generated_Code/DrvI2c1.c **** **            Pins                                         : 
  41:../Generated_Code/DrvI2c1.c **** **              SDA pin                                    : 
  42:../Generated_Code/DrvI2c1.c **** **                SDA pin                                  : PTC11/I2C1_SDA
  43:../Generated_Code/DrvI2c1.c **** **                SDA pin signal                           : 
  44:../Generated_Code/DrvI2c1.c **** **              SCL pin                                    : 
  45:../Generated_Code/DrvI2c1.c **** **                SCL pin                                  : PTC10/I2C1_SCL
  46:../Generated_Code/DrvI2c1.c **** **                SCL pin signal                           : 
  47:../Generated_Code/DrvI2c1.c **** **              High drive select                          : Disabled
  48:../Generated_Code/DrvI2c1.c **** **              Input Glitch filter                        : 0
  49:../Generated_Code/DrvI2c1.c **** **            Internal frequency (multiplier factor)       : 24 MHz
  50:../Generated_Code/DrvI2c1.c **** **            Bits 0-2 of Frequency divider register       : 000
  51:../Generated_Code/DrvI2c1.c **** **            Bits 3-5 of Frequency divider register       : 010
  52:../Generated_Code/DrvI2c1.c **** **            SCL frequency                                : 500 kHz
  53:../Generated_Code/DrvI2c1.c **** **            SDA Hold                                     : 0.375 us
  54:../Generated_Code/DrvI2c1.c **** **            SCL start Hold                               : 0.75 us
  55:../Generated_Code/DrvI2c1.c **** **            SCL stop Hold                                : 1.042 us
  56:../Generated_Code/DrvI2c1.c **** **            Control acknowledge bit                      : Disabled
  57:../Generated_Code/DrvI2c1.c **** **            Low timeout                                  : Disabled
  58:../Generated_Code/DrvI2c1.c **** **          Initialization                                 : 
  59:../Generated_Code/DrvI2c1.c **** **            Enabled in init code                         : yes
  60:../Generated_Code/DrvI2c1.c **** **            Auto initialization                          : no
  61:../Generated_Code/DrvI2c1.c **** **            Event mask                                   : 
  62:../Generated_Code/DrvI2c1.c **** **              OnMasterBlockSent                          : Enabled
  63:../Generated_Code/DrvI2c1.c **** **              OnMasterBlockReceived                      : Enabled
  64:../Generated_Code/DrvI2c1.c **** **              OnMasterByteReceived                       : Disabled
  65:../Generated_Code/DrvI2c1.c **** **              OnSlaveBlockSent                           : Disabled
  66:../Generated_Code/DrvI2c1.c **** **              OnSlaveBlockReceived                       : Disabled
  67:../Generated_Code/DrvI2c1.c **** **              OnSlaveByteReceived                        : Disabled
  68:../Generated_Code/DrvI2c1.c **** **              OnSlaveRxRequest                           : Disabled
  69:../Generated_Code/DrvI2c1.c **** **              OnSlaveTxRequest                           : Disabled
  70:../Generated_Code/DrvI2c1.c **** **              OnSlaveGeneralCallAddr                     : Disabled
  71:../Generated_Code/DrvI2c1.c **** **              OnSlaveSmBusCallAddr                       : Disabled
  72:../Generated_Code/DrvI2c1.c **** **              OnSlaveSmBusAlertResponse                  : Disabled
  73:../Generated_Code/DrvI2c1.c **** **              OnError                                    : Enabled
  74:../Generated_Code/DrvI2c1.c **** **              OnBusStopDetected                          : Disabled
  75:../Generated_Code/DrvI2c1.c **** **          CPU clock/configuration selection              : 
  76:../Generated_Code/DrvI2c1.c **** **            Clock configuration 0                        : This component enabled
  77:../Generated_Code/DrvI2c1.c **** **            Clock configuration 1                        : This component disabled
  78:../Generated_Code/DrvI2c1.c **** **            Clock configuration 2                        : This component disabled
  79:../Generated_Code/DrvI2c1.c **** **            Clock configuration 3                        : This component disabled
  80:../Generated_Code/DrvI2c1.c **** **            Clock configuration 4                        : This component disabled
  81:../Generated_Code/DrvI2c1.c **** **            Clock configuration 5                        : This component disabled
  82:../Generated_Code/DrvI2c1.c **** **            Clock configuration 6                        : This component disabled
  83:../Generated_Code/DrvI2c1.c **** **            Clock configuration 7                        : This component disabled
  84:../Generated_Code/DrvI2c1.c **** **     Contents    :
  85:../Generated_Code/DrvI2c1.c **** **         Init               - LDD_TDeviceData* DrvI2c1_Init(LDD_TUserData *UserDataPtr);
  86:../Generated_Code/DrvI2c1.c **** **         Deinit             - void DrvI2c1_Deinit(LDD_TDeviceData *DeviceDataPtr);
  87:../Generated_Code/DrvI2c1.c **** **         MasterSendBlock    - LDD_TError DrvI2c1_MasterSendBlock(LDD_TDeviceData *DeviceDataPtr, 
  88:../Generated_Code/DrvI2c1.c **** **         MasterReceiveBlock - LDD_TError DrvI2c1_MasterReceiveBlock(LDD_TDeviceData *DeviceDataPt
  89:../Generated_Code/DrvI2c1.c **** **         SelectSlaveDevice  - LDD_TError DrvI2c1_SelectSlaveDevice(LDD_TDeviceData *DeviceDataPtr
  90:../Generated_Code/DrvI2c1.c **** **         CheckBus           - LDD_TError DrvI2c1_CheckBus(LDD_TDeviceData *DeviceDataPtr, LDD_I2C
  91:../Generated_Code/DrvI2c1.c **** **
  92:../Generated_Code/DrvI2c1.c **** **     Copyright : 1997 - 2012 Freescale, Inc. All Rights Reserved.
  93:../Generated_Code/DrvI2c1.c **** **     
  94:../Generated_Code/DrvI2c1.c **** **     http      : www.freescale.com
  95:../Generated_Code/DrvI2c1.c **** **     mail      : support@freescale.com
  96:../Generated_Code/DrvI2c1.c **** ** ###################################################################*/
  97:../Generated_Code/DrvI2c1.c **** 
  98:../Generated_Code/DrvI2c1.c **** /* MODULE DrvI2c1. */
  99:../Generated_Code/DrvI2c1.c **** 
 100:../Generated_Code/DrvI2c1.c **** #include "Events.h"
 101:../Generated_Code/DrvI2c1.c **** #include "DrvI2c1.h"
 102:../Generated_Code/DrvI2c1.c **** #include "PORT_PDD.h"
 103:../Generated_Code/DrvI2c1.c **** #include "I2C_PDD.h"
 104:../Generated_Code/DrvI2c1.c **** /* MQX Lite include files */
 105:../Generated_Code/DrvI2c1.c **** #include "mqxlite.h"
 106:../Generated_Code/DrvI2c1.c **** #include "mqxlite_prv.h"
 107:../Generated_Code/DrvI2c1.c **** #include "IO_Map.h"
 108:../Generated_Code/DrvI2c1.c **** 
 109:../Generated_Code/DrvI2c1.c **** 
 110:../Generated_Code/DrvI2c1.c **** /* SerFlag bits */
 111:../Generated_Code/DrvI2c1.c **** #define MASTER_IN_PROGRES       0x01U  /* Communication is in progress (Master) */
 112:../Generated_Code/DrvI2c1.c **** #define ADDR_COMPLETE           0x02U  /* 10-bit address transmission complete   */
 113:../Generated_Code/DrvI2c1.c **** #define REP_ADDR_COMPLETE       0x04U  /* repeated address transmission complete */
 114:../Generated_Code/DrvI2c1.c **** #define GENERAL_CALL            0x08U  /* General call flag */
 115:../Generated_Code/DrvI2c1.c **** #define ADDR_10                 0x10U  /* 10-bit addr flag */
 116:../Generated_Code/DrvI2c1.c **** #define ADDR_7                  0x20U  /* 7-bit addr flag */
 117:../Generated_Code/DrvI2c1.c **** 
 118:../Generated_Code/DrvI2c1.c **** typedef struct {
 119:../Generated_Code/DrvI2c1.c ****   uint8_t SerFlag;                     /* Flags for serial communication */
 120:../Generated_Code/DrvI2c1.c ****                                        /* Bits: 0 - Running int from TX */
 121:../Generated_Code/DrvI2c1.c ****                                        /*       1 - 10-bit address transmission complete   */
 122:../Generated_Code/DrvI2c1.c ****                                        /*       2 - repeated address transmission complete */
 123:../Generated_Code/DrvI2c1.c ****                                        /*       3 - General Call flag */
 124:../Generated_Code/DrvI2c1.c ****                                        /*       4 - 10-bit addr flag */
 125:../Generated_Code/DrvI2c1.c ****                                        /*       5 - 7-bit addr flag */
 126:../Generated_Code/DrvI2c1.c ****   LDD_I2C_TSendStop SendStop;          /* Enable/Disable generate send stop condition after transmi
 127:../Generated_Code/DrvI2c1.c ****   uint8_t SlaveAddr;                   /* Variable for Slave address */
 128:../Generated_Code/DrvI2c1.c ****   uint8_t SlaveAddrHigh;               /* Variable for High byte of the Slave address (10-bit addre
 129:../Generated_Code/DrvI2c1.c ****   LDD_I2C_TSize InpLenM;               /* The counter of input bufer's content */
 130:../Generated_Code/DrvI2c1.c ****   uint8_t *InpPtrM;                    /* Pointer to input buffer for Master mode */
 131:../Generated_Code/DrvI2c1.c ****   LDD_I2C_TSize OutLenM;               /* The counter of output bufer's content */
 132:../Generated_Code/DrvI2c1.c ****   uint8_t *OutPtrM;                    /* Pointer to output buffer for Master mode */
 133:../Generated_Code/DrvI2c1.c ****   LDD_RTOS_TISRVectorSettings SavedISRSettings; /* {MQXLite RTOS Adapter} Saved settings of allocat
 134:../Generated_Code/DrvI2c1.c ****   LDD_TUserData *UserData;             /* RTOS device data structure */
 135:../Generated_Code/DrvI2c1.c **** } DrvI2c1_TDeviceData;
 136:../Generated_Code/DrvI2c1.c **** 
 137:../Generated_Code/DrvI2c1.c **** typedef DrvI2c1_TDeviceData *DrvI2c1_TDeviceDataPtr; /* Pointer to the device data structure. */
 138:../Generated_Code/DrvI2c1.c **** 
 139:../Generated_Code/DrvI2c1.c **** /* {MQXLite RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
 140:../Generated_Code/DrvI2c1.c **** static DrvI2c1_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 141:../Generated_Code/DrvI2c1.c **** 
 142:../Generated_Code/DrvI2c1.c **** #define AVAILABLE_EVENTS_MASK (LDD_I2C_ON_MASTER_BLOCK_SENT | LDD_I2C_ON_MASTER_BLOCK_RECEIVED | LD
 143:../Generated_Code/DrvI2c1.c **** 
 144:../Generated_Code/DrvI2c1.c **** /*
 145:../Generated_Code/DrvI2c1.c **** ** ===================================================================
 146:../Generated_Code/DrvI2c1.c **** **     Method      :  DrvI2c1_Interrupt (component I2C_LDD)
 147:../Generated_Code/DrvI2c1.c **** **
 148:../Generated_Code/DrvI2c1.c **** **     Description :
 149:../Generated_Code/DrvI2c1.c **** **         The method services the interrupt of the selected peripheral(s)
 150:../Generated_Code/DrvI2c1.c **** **         and eventually invokes event(s) of the component.
 151:../Generated_Code/DrvI2c1.c **** **         This method is internal. It is used by Processor Expert only.
 152:../Generated_Code/DrvI2c1.c **** ** ===================================================================
 153:../Generated_Code/DrvI2c1.c **** */
 154:../Generated_Code/DrvI2c1.c **** 
 155:../Generated_Code/DrvI2c1.c **** void DrvI2c1_Interrupt(LDD_RTOS_TISRParameter _isrParameter)
 156:../Generated_Code/DrvI2c1.c **** {
  32              		.loc 1 156 0
  33              		.cfi_startproc
  34 0000 90B5     		push	{r4, r7, lr}
  35              	.LCFI0:
  36              		.cfi_def_cfa_offset 12
  37              		.cfi_offset 4, -12
  38              		.cfi_offset 7, -8
  39              		.cfi_offset 14, -4
  40 0002 85B0     		sub	sp, sp, #20
  41              	.LCFI1:
  42              		.cfi_def_cfa_offset 32
  43 0004 00AF     		add	r7, sp, #0
  44              	.LCFI2:
  45              		.cfi_def_cfa_register 7
  46 0006 7860     		str	r0, [r7, #4]
 157:../Generated_Code/DrvI2c1.c ****   /* {MQXLite RTOS Adapter} ISR parameter is passed as parameter from RTOS interrupt dispatcher */
 158:../Generated_Code/DrvI2c1.c ****   DrvI2c1_TDeviceDataPtr DeviceDataPrv = (DrvI2c1_TDeviceDataPtr)_isrParameter;
  47              		.loc 1 158 0
  48 0008 7B68     		ldr	r3, [r7, #4]
  49 000a BB60     		str	r3, [r7, #8]
 159:../Generated_Code/DrvI2c1.c ****   LDD_I2C_TErrorMask ErrorMask = 0x00U; /* Temporary variable for error mask */
  50              		.loc 1 159 0
  51 000c 3B1C     		mov	r3, r7
  52 000e 0E33     		add	r3, r3, #14
  53 0010 0022     		mov	r2, #0
  54 0012 1A80     		strh	r2, [r3]
 160:../Generated_Code/DrvI2c1.c ****   register uint8_t Status;             /* Temporary variable for status register */
 161:../Generated_Code/DrvI2c1.c **** 
 162:../Generated_Code/DrvI2c1.c ****   Status = I2C_PDD_ReadStatusReg(I2C1_BASE_PTR); /* Safe status register */
  55              		.loc 1 162 0
  56 0014 A54B     		ldr	r3, .L16
  57 0016 DB78     		ldrb	r3, [r3, #3]
  58 0018 DCB2     		uxtb	r4, r3
 163:../Generated_Code/DrvI2c1.c ****   I2C_PDD_ClearInterruptFlags(I2C1_BASE_PTR, (Status)); /* Clear interrupt flag */
  59              		.loc 1 163 0
  60 001a A44B     		ldr	r3, .L16
  61 001c A34A     		ldr	r2, .L16
  62 001e D278     		ldrb	r2, [r2, #3]
  63 0020 D2B2     		uxtb	r2, r2
  64 0022 D2B2     		uxtb	r2, r2
  65 0024 1221     		mov	r1, #18
  66 0026 8A43     		bic	r2, r1
  67 0028 D1B2     		uxtb	r1, r2
  68 002a E2B2     		uxtb	r2, r4
  69 002c 0A43     		orr	r2, r1
  70 002e D2B2     		uxtb	r2, r2
  71 0030 D2B2     		uxtb	r2, r2
  72 0032 DA70     		strb	r2, [r3, #3]
 164:../Generated_Code/DrvI2c1.c ****   if (I2C_PDD_GetMasterMode(I2C1_BASE_PTR) == I2C_PDD_MASTER_MODE) { /* Is device in master mode? *
  73              		.loc 1 164 0
  74 0034 9D4B     		ldr	r3, .L16
  75 0036 9B78     		ldrb	r3, [r3, #2]
  76 0038 DBB2     		uxtb	r3, r3
  77 003a 1A1C     		mov	r2, r3
  78 003c 2023     		mov	r3, #32
  79 003e 1340     		and	r3, r2
  80 0040 00D1     		bne	.LCB46
  81 0042 01E1     		b	.L2	@long jump
  82              	.LCB46:
 165:../Generated_Code/DrvI2c1.c ****     if (I2C_PDD_GetTransmitMode(I2C1_BASE_PTR) == I2C_PDD_TX_DIRECTION) { /* Is device in Tx mode? 
  83              		.loc 1 165 0
  84 0044 994B     		ldr	r3, .L16
  85 0046 9B78     		ldrb	r3, [r3, #2]
  86 0048 DBB2     		uxtb	r3, r3
  87 004a 1A1C     		mov	r2, r3
  88 004c 1023     		mov	r3, #16
  89 004e 1340     		and	r3, r2
  90 0050 00D1     		bne	.LCB54
  91 0052 B8E0     		b	.L3	@long jump
  92              	.LCB54:
 166:../Generated_Code/DrvI2c1.c ****       if ((Status & I2C_PDD_RX_ACKNOWLEDGE) != 0x00U){ /* NACK received? */
  93              		.loc 1 166 0
  94 0054 221C     		mov	r2, r4
  95 0056 0123     		mov	r3, #1
  96 0058 1340     		and	r3, r2
  97 005a 2CD0     		beq	.L4
 167:../Generated_Code/DrvI2c1.c ****         I2C_PDD_SetMasterMode(I2C1_BASE_PTR, I2C_PDD_SLAVE_MODE); /* Switch device to slave mode (s
  98              		.loc 1 167 0
  99 005c 934B     		ldr	r3, .L16
 100 005e 934A     		ldr	r2, .L16
 101 0060 9278     		ldrb	r2, [r2, #2]
 102 0062 D2B2     		uxtb	r2, r2
 103 0064 2021     		mov	r1, #32
 104 0066 8A43     		bic	r2, r1
 105 0068 D2B2     		uxtb	r2, r2
 106 006a 9A70     		strb	r2, [r3, #2]
 168:../Generated_Code/DrvI2c1.c ****         I2C_PDD_SetTransmitMode(I2C1_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode */
 107              		.loc 1 168 0
 108 006c 8F4B     		ldr	r3, .L16
 109 006e 8F4A     		ldr	r2, .L16
 110 0070 9278     		ldrb	r2, [r2, #2]
 111 0072 D2B2     		uxtb	r2, r2
 112 0074 1021     		mov	r1, #16
 113 0076 8A43     		bic	r2, r1
 114 0078 D2B2     		uxtb	r2, r2
 115 007a 9A70     		strb	r2, [r3, #2]
 169:../Generated_Code/DrvI2c1.c ****         DeviceDataPrv->OutLenM = 0x00U; /* No character for sending */
 116              		.loc 1 169 0
 117 007c BB68     		ldr	r3, [r7, #8]
 118 007e 0022     		mov	r2, #0
 119 0080 9A81     		strh	r2, [r3, #12]
 170:../Generated_Code/DrvI2c1.c ****         DeviceDataPrv->InpLenM = 0x00U; /* No character for reception */
 120              		.loc 1 170 0
 121 0082 BB68     		ldr	r3, [r7, #8]
 122 0084 0022     		mov	r2, #0
 123 0086 9A80     		strh	r2, [r3, #4]
 171:../Generated_Code/DrvI2c1.c ****         DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* No character for sending or rec
 124              		.loc 1 171 0
 125 0088 BB68     		ldr	r3, [r7, #8]
 126 008a 1B78     		ldrb	r3, [r3]
 127 008c 0122     		mov	r2, #1
 128 008e 9343     		bic	r3, r2
 129 0090 DAB2     		uxtb	r2, r3
 130 0092 BB68     		ldr	r3, [r7, #8]
 131 0094 1A70     		strb	r2, [r3]
 172:../Generated_Code/DrvI2c1.c ****         DeviceDataPrv->SerFlag |= (ADDR_COMPLETE | REP_ADDR_COMPLETE); /* Set the flag */
 132              		.loc 1 172 0
 133 0096 BB68     		ldr	r3, [r7, #8]
 134 0098 1B78     		ldrb	r3, [r3]
 135 009a 0622     		mov	r2, #6
 136 009c 1343     		orr	r3, r2
 137 009e DAB2     		uxtb	r2, r3
 138 00a0 BB68     		ldr	r3, [r7, #8]
 139 00a2 1A70     		strb	r2, [r3]
 173:../Generated_Code/DrvI2c1.c ****         ErrorMask |= LDD_I2C_MASTER_NACK; /* Set the Master Nack error mask */
 140              		.loc 1 173 0
 141 00a4 3B1C     		mov	r3, r7
 142 00a6 0E33     		add	r3, r3, #14
 143 00a8 3A1C     		mov	r2, r7
 144 00aa 0E32     		add	r2, r2, #14
 145 00ac 1288     		ldrh	r2, [r2]
 146 00ae 0821     		mov	r1, #8
 147 00b0 0A43     		orr	r2, r1
 148 00b2 1A80     		strh	r2, [r3]
 149 00b4 ECE0     		b	.L5
 150              	.L4:
 174:../Generated_Code/DrvI2c1.c ****       } else {
 175:../Generated_Code/DrvI2c1.c ****         if ((DeviceDataPrv->SerFlag & ADDR_COMPLETE) != 0x00U) { /* If 10-bit addr has been complet
 151              		.loc 1 175 0
 152 00b6 BB68     		ldr	r3, [r7, #8]
 153 00b8 1B78     		ldrb	r3, [r3]
 154 00ba 1A1C     		mov	r2, r3
 155 00bc 0223     		mov	r3, #2
 156 00be 1340     		and	r3, r2
 157 00c0 00D1     		bne	.LCB114
 158 00c2 74E0     		b	.L6	@long jump
 159              	.LCB114:
 176:../Generated_Code/DrvI2c1.c ****           if (DeviceDataPrv->OutLenM != 0x00U) { /* Is any char. for transmitting? */
 160              		.loc 1 176 0
 161 00c4 BB68     		ldr	r3, [r7, #8]
 162 00c6 9B89     		ldrh	r3, [r3, #12]
 163 00c8 002B     		cmp	r3, #0
 164 00ca 0ED0     		beq	.L7
 177:../Generated_Code/DrvI2c1.c ****             DeviceDataPrv->OutLenM--;  /* Decrease number of chars for the transmit */
 165              		.loc 1 177 0
 166 00cc BB68     		ldr	r3, [r7, #8]
 167 00ce 9B89     		ldrh	r3, [r3, #12]
 168 00d0 013B     		sub	r3, r3, #1
 169 00d2 9AB2     		uxth	r2, r3
 170 00d4 BB68     		ldr	r3, [r7, #8]
 171 00d6 9A81     		strh	r2, [r3, #12]
 178:../Generated_Code/DrvI2c1.c ****             I2C_PDD_WriteDataReg(I2C1_BASE_PTR, *(DeviceDataPrv->OutPtrM)++); /* Send character */
 172              		.loc 1 178 0
 173 00d8 744A     		ldr	r2, .L16
 174 00da BB68     		ldr	r3, [r7, #8]
 175 00dc 1B69     		ldr	r3, [r3, #16]
 176 00de 1978     		ldrb	r1, [r3]
 177 00e0 1171     		strb	r1, [r2, #4]
 178 00e2 5A1C     		add	r2, r3, #1
 179 00e4 BB68     		ldr	r3, [r7, #8]
 180 00e6 1A61     		str	r2, [r3, #16]
 181 00e8 D2E0     		b	.L5
 182              	.L7:
 179:../Generated_Code/DrvI2c1.c ****           }
 180:../Generated_Code/DrvI2c1.c ****           else {
 181:../Generated_Code/DrvI2c1.c ****             if (DeviceDataPrv->InpLenM != 0x00U) { /* Is any char. for reception? */
 183              		.loc 1 181 0
 184 00ea BB68     		ldr	r3, [r7, #8]
 185 00ec 9B88     		ldrh	r3, [r3, #4]
 186 00ee 002B     		cmp	r3, #0
 187 00f0 3CD0     		beq	.L8
 182:../Generated_Code/DrvI2c1.c ****               if ((DeviceDataPrv->SerFlag & REP_ADDR_COMPLETE) != 0x00U) { /* If repeated start and
 188              		.loc 1 182 0
 189 00f2 BB68     		ldr	r3, [r7, #8]
 190 00f4 1B78     		ldrb	r3, [r3]
 191 00f6 1A1C     		mov	r2, r3
 192 00f8 0423     		mov	r3, #4
 193 00fa 1340     		and	r3, r2
 194 00fc 1FD0     		beq	.L9
 183:../Generated_Code/DrvI2c1.c ****                 if (DeviceDataPrv->InpLenM == 0x01U) { /* If only one char to receive */
 195              		.loc 1 183 0
 196 00fe BB68     		ldr	r3, [r7, #8]
 197 0100 9B88     		ldrh	r3, [r3, #4]
 198 0102 012B     		cmp	r3, #1
 199 0104 08D1     		bne	.L10
 184:../Generated_Code/DrvI2c1.c ****                   I2C_PDD_EnableTransmitAcknowledge(I2C1_BASE_PTR, PDD_DISABLE); /* then transmit A
 200              		.loc 1 184 0
 201 0106 694B     		ldr	r3, .L16
 202 0108 684A     		ldr	r2, .L16
 203 010a 9278     		ldrb	r2, [r2, #2]
 204 010c D2B2     		uxtb	r2, r2
 205 010e 0821     		mov	r1, #8
 206 0110 0A43     		orr	r2, r1
 207 0112 D2B2     		uxtb	r2, r2
 208 0114 9A70     		strb	r2, [r3, #2]
 209 0116 07E0     		b	.L11
 210              	.L10:
 185:../Generated_Code/DrvI2c1.c ****                 } else {
 186:../Generated_Code/DrvI2c1.c ****                   I2C_PDD_EnableTransmitAcknowledge(I2C1_BASE_PTR, PDD_ENABLE); /* else transmit AC
 211              		.loc 1 186 0
 212 0118 644B     		ldr	r3, .L16
 213 011a 644A     		ldr	r2, .L16
 214 011c 9278     		ldrb	r2, [r2, #2]
 215 011e D2B2     		uxtb	r2, r2
 216 0120 0821     		mov	r1, #8
 217 0122 8A43     		bic	r2, r1
 218 0124 D2B2     		uxtb	r2, r2
 219 0126 9A70     		strb	r2, [r3, #2]
 220              	.L11:
 187:../Generated_Code/DrvI2c1.c ****                 }
 188:../Generated_Code/DrvI2c1.c ****                 I2C_PDD_SetTransmitMode(I2C1_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode 
 221              		.loc 1 188 0
 222 0128 604B     		ldr	r3, .L16
 223 012a 604A     		ldr	r2, .L16
 224 012c 9278     		ldrb	r2, [r2, #2]
 225 012e D2B2     		uxtb	r2, r2
 226 0130 1021     		mov	r1, #16
 227 0132 8A43     		bic	r2, r1
 228 0134 D2B2     		uxtb	r2, r2
 229 0136 9A70     		strb	r2, [r3, #2]
 189:../Generated_Code/DrvI2c1.c ****                 (void)I2C_PDD_ReadDataReg(I2C1_BASE_PTR); /* Dummy read character */
 230              		.loc 1 189 0
 231 0138 5C4B     		ldr	r3, .L16
 232 013a 1B79     		ldrb	r3, [r3, #4]
 233 013c A8E0     		b	.L5
 234              	.L9:
 190:../Generated_Code/DrvI2c1.c ****               } else {                 /* Repeated address has not been completed for 10-bit addres
 191:../Generated_Code/DrvI2c1.c ****                 I2C_PDD_RepeatStart(I2C1_BASE_PTR); /* Repeat start cycle generated */
 235              		.loc 1 191 0
 236 013e 5B4B     		ldr	r3, .L16
 237 0140 5A4A     		ldr	r2, .L16
 238 0142 9278     		ldrb	r2, [r2, #2]
 239 0144 D2B2     		uxtb	r2, r2
 240 0146 0421     		mov	r1, #4
 241 0148 0A43     		orr	r2, r1
 242 014a D2B2     		uxtb	r2, r2
 243 014c 9A70     		strb	r2, [r3, #2]
 192:../Generated_Code/DrvI2c1.c ****                 I2C_PDD_WriteDataReg(I2C1_BASE_PTR, (uint8_t)(DeviceDataPrv->SlaveAddrHigh | 0x01U)
 244              		.loc 1 192 0
 245 014e 574B     		ldr	r3, .L16
 246 0150 BA68     		ldr	r2, [r7, #8]
 247 0152 D278     		ldrb	r2, [r2, #3]
 248 0154 0121     		mov	r1, #1
 249 0156 0A43     		orr	r2, r1
 250 0158 D2B2     		uxtb	r2, r2
 251 015a 1A71     		strb	r2, [r3, #4]
 193:../Generated_Code/DrvI2c1.c ****                 DeviceDataPrv->SerFlag |= REP_ADDR_COMPLETE;
 252              		.loc 1 193 0
 253 015c BB68     		ldr	r3, [r7, #8]
 254 015e 1B78     		ldrb	r3, [r3]
 255 0160 0422     		mov	r2, #4
 256 0162 1343     		orr	r3, r2
 257 0164 DAB2     		uxtb	r2, r3
 258 0166 BB68     		ldr	r3, [r7, #8]
 259 0168 1A70     		strb	r2, [r3]
 260 016a 91E0     		b	.L5
 261              	.L8:
 194:../Generated_Code/DrvI2c1.c ****               }
 195:../Generated_Code/DrvI2c1.c ****             }
 196:../Generated_Code/DrvI2c1.c ****             else {
 197:../Generated_Code/DrvI2c1.c ****               DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* Clear flag "busy" */
 262              		.loc 1 197 0
 263 016c BB68     		ldr	r3, [r7, #8]
 264 016e 1B78     		ldrb	r3, [r3]
 265 0170 0122     		mov	r2, #1
 266 0172 9343     		bic	r3, r2
 267 0174 DAB2     		uxtb	r2, r3
 268 0176 BB68     		ldr	r3, [r7, #8]
 269 0178 1A70     		strb	r2, [r3]
 198:../Generated_Code/DrvI2c1.c ****               if (DeviceDataPrv->SendStop == LDD_I2C_SEND_STOP) {
 270              		.loc 1 198 0
 271 017a BB68     		ldr	r3, [r7, #8]
 272 017c 5B78     		ldrb	r3, [r3, #1]
 273 017e 012B     		cmp	r3, #1
 274 0180 0FD1     		bne	.L12
 199:../Generated_Code/DrvI2c1.c ****                 I2C_PDD_SetMasterMode(I2C1_BASE_PTR, I2C_PDD_SLAVE_MODE); /* Switch device to slave
 275              		.loc 1 199 0
 276 0182 4A4B     		ldr	r3, .L16
 277 0184 494A     		ldr	r2, .L16
 278 0186 9278     		ldrb	r2, [r2, #2]
 279 0188 D2B2     		uxtb	r2, r2
 280 018a 2021     		mov	r1, #32
 281 018c 8A43     		bic	r2, r1
 282 018e D2B2     		uxtb	r2, r2
 283 0190 9A70     		strb	r2, [r3, #2]
 200:../Generated_Code/DrvI2c1.c ****                 I2C_PDD_SetTransmitMode(I2C1_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode 
 284              		.loc 1 200 0
 285 0192 464B     		ldr	r3, .L16
 286 0194 454A     		ldr	r2, .L16
 287 0196 9278     		ldrb	r2, [r2, #2]
 288 0198 D2B2     		uxtb	r2, r2
 289 019a 1021     		mov	r1, #16
 290 019c 8A43     		bic	r2, r1
 291 019e D2B2     		uxtb	r2, r2
 292 01a0 9A70     		strb	r2, [r3, #2]
 293              	.L12:
 201:../Generated_Code/DrvI2c1.c ****               }
 202:../Generated_Code/DrvI2c1.c ****               DrvI2c1_OnMasterBlockSent(DeviceDataPrv->UserData); /* Invoke OnMasterBlockSent event
 294              		.loc 1 202 0
 295 01a2 BB68     		ldr	r3, [r7, #8]
 296 01a4 DB69     		ldr	r3, [r3, #28]
 297 01a6 181C     		mov	r0, r3
 298 01a8 FFF7FEFF 		bl	DrvI2c1_OnMasterBlockSent
 299 01ac 70E0     		b	.L5
 300              	.L6:
 203:../Generated_Code/DrvI2c1.c ****             }
 204:../Generated_Code/DrvI2c1.c ****           }
 205:../Generated_Code/DrvI2c1.c ****         } else {
 206:../Generated_Code/DrvI2c1.c ****           I2C_PDD_WriteDataReg(I2C1_BASE_PTR, DeviceDataPrv->SlaveAddr); /* Send second part of the
 301              		.loc 1 206 0
 302 01ae 3F4B     		ldr	r3, .L16
 303 01b0 BA68     		ldr	r2, [r7, #8]
 304 01b2 9278     		ldrb	r2, [r2, #2]
 305 01b4 1A71     		strb	r2, [r3, #4]
 207:../Generated_Code/DrvI2c1.c ****           DeviceDataPrv->SerFlag |= (ADDR_COMPLETE); /* Address complete */
 306              		.loc 1 207 0
 307 01b6 BB68     		ldr	r3, [r7, #8]
 308 01b8 1B78     		ldrb	r3, [r3]
 309 01ba 0222     		mov	r2, #2
 310 01bc 1343     		orr	r3, r2
 311 01be DAB2     		uxtb	r2, r3
 312 01c0 BB68     		ldr	r3, [r7, #8]
 313 01c2 1A70     		strb	r2, [r3]
 314 01c4 64E0     		b	.L5
 315              	.L3:
 208:../Generated_Code/DrvI2c1.c ****         }
 209:../Generated_Code/DrvI2c1.c ****       }
 210:../Generated_Code/DrvI2c1.c ****     }
 211:../Generated_Code/DrvI2c1.c ****     else {
 212:../Generated_Code/DrvI2c1.c ****       DeviceDataPrv->InpLenM--;        /* Decrease number of chars for the receive */
 316              		.loc 1 212 0
 317 01c6 BB68     		ldr	r3, [r7, #8]
 318 01c8 9B88     		ldrh	r3, [r3, #4]
 319 01ca 013B     		sub	r3, r3, #1
 320 01cc 9AB2     		uxth	r2, r3
 321 01ce BB68     		ldr	r3, [r7, #8]
 322 01d0 9A80     		strh	r2, [r3, #4]
 213:../Generated_Code/DrvI2c1.c ****       if (DeviceDataPrv->InpLenM != 0x00U) { /* Is any char. for reception? */
 323              		.loc 1 213 0
 324 01d2 BB68     		ldr	r3, [r7, #8]
 325 01d4 9B88     		ldrh	r3, [r3, #4]
 326 01d6 002B     		cmp	r3, #0
 327 01d8 0CD0     		beq	.L13
 214:../Generated_Code/DrvI2c1.c ****         if (DeviceDataPrv->InpLenM == 0x01U) {
 328              		.loc 1 214 0
 329 01da BB68     		ldr	r3, [r7, #8]
 330 01dc 9B88     		ldrh	r3, [r3, #4]
 331 01de 012B     		cmp	r3, #1
 332 01e0 1FD1     		bne	.L14
 215:../Generated_Code/DrvI2c1.c ****           I2C_PDD_EnableTransmitAcknowledge(I2C1_BASE_PTR, PDD_DISABLE); /* Transmit NACK */
 333              		.loc 1 215 0
 334 01e2 324B     		ldr	r3, .L16
 335 01e4 314A     		ldr	r2, .L16
 336 01e6 9278     		ldrb	r2, [r2, #2]
 337 01e8 D2B2     		uxtb	r2, r2
 338 01ea 0821     		mov	r1, #8
 339 01ec 0A43     		orr	r2, r1
 340 01ee D2B2     		uxtb	r2, r2
 341 01f0 9A70     		strb	r2, [r3, #2]
 342 01f2 16E0     		b	.L14
 343              	.L13:
 216:../Generated_Code/DrvI2c1.c ****         }
 217:../Generated_Code/DrvI2c1.c ****       } else {
 218:../Generated_Code/DrvI2c1.c ****         DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* Clear flag "busy" */
 344              		.loc 1 218 0
 345 01f4 BB68     		ldr	r3, [r7, #8]
 346 01f6 1B78     		ldrb	r3, [r3]
 347 01f8 0122     		mov	r2, #1
 348 01fa 9343     		bic	r3, r2
 349 01fc DAB2     		uxtb	r2, r3
 350 01fe BB68     		ldr	r3, [r7, #8]
 351 0200 1A70     		strb	r2, [r3]
 219:../Generated_Code/DrvI2c1.c ****         I2C_PDD_SetMasterMode(I2C1_BASE_PTR, I2C_PDD_SLAVE_MODE); /* If no, switch device to slave 
 352              		.loc 1 219 0
 353 0202 2A4B     		ldr	r3, .L16
 354 0204 294A     		ldr	r2, .L16
 355 0206 9278     		ldrb	r2, [r2, #2]
 356 0208 D2B2     		uxtb	r2, r2
 357 020a 2021     		mov	r1, #32
 358 020c 8A43     		bic	r2, r1
 359 020e D2B2     		uxtb	r2, r2
 360 0210 9A70     		strb	r2, [r3, #2]
 220:../Generated_Code/DrvI2c1.c ****         I2C_PDD_EnableTransmitAcknowledge(I2C1_BASE_PTR, PDD_ENABLE); /* Transmit ACK */
 361              		.loc 1 220 0
 362 0212 264B     		ldr	r3, .L16
 363 0214 254A     		ldr	r2, .L16
 364 0216 9278     		ldrb	r2, [r2, #2]
 365 0218 D2B2     		uxtb	r2, r2
 366 021a 0821     		mov	r1, #8
 367 021c 8A43     		bic	r2, r1
 368 021e D2B2     		uxtb	r2, r2
 369 0220 9A70     		strb	r2, [r3, #2]
 370              	.L14:
 221:../Generated_Code/DrvI2c1.c ****       }
 222:../Generated_Code/DrvI2c1.c ****       *(DeviceDataPrv->InpPtrM)++ = I2C_PDD_ReadDataReg(I2C1_BASE_PTR); /* Receive character */
 371              		.loc 1 222 0
 372 0222 BB68     		ldr	r3, [r7, #8]
 373 0224 9B68     		ldr	r3, [r3, #8]
 374 0226 214A     		ldr	r2, .L16
 375 0228 1279     		ldrb	r2, [r2, #4]
 376 022a D2B2     		uxtb	r2, r2
 377 022c 1A70     		strb	r2, [r3]
 378 022e 5A1C     		add	r2, r3, #1
 379 0230 BB68     		ldr	r3, [r7, #8]
 380 0232 9A60     		str	r2, [r3, #8]
 223:../Generated_Code/DrvI2c1.c ****       if (DeviceDataPrv->InpLenM == 0x00U) { /* Is any char. for reception? */
 381              		.loc 1 223 0
 382 0234 BB68     		ldr	r3, [r7, #8]
 383 0236 9B88     		ldrh	r3, [r3, #4]
 384 0238 002B     		cmp	r3, #0
 385 023a 29D1     		bne	.L5
 224:../Generated_Code/DrvI2c1.c ****         DrvI2c1_OnMasterBlockReceived(DeviceDataPrv->UserData); /* Invoke OnMasterBlockReceived eve
 386              		.loc 1 224 0
 387 023c BB68     		ldr	r3, [r7, #8]
 388 023e DB69     		ldr	r3, [r3, #28]
 389 0240 181C     		mov	r0, r3
 390 0242 FFF7FEFF 		bl	DrvI2c1_OnMasterBlockReceived
 391 0246 23E0     		b	.L5
 392              	.L2:
 225:../Generated_Code/DrvI2c1.c ****       }
 226:../Generated_Code/DrvI2c1.c ****     }
 227:../Generated_Code/DrvI2c1.c ****   } else {
 228:../Generated_Code/DrvI2c1.c ****     if ((Status & I2C_PDD_ARBIT_LOST) != 0x00U) { /* Arbitration lost? */
 393              		.loc 1 228 0
 394 0248 221C     		mov	r2, r4
 395 024a 1023     		mov	r3, #16
 396 024c 1340     		and	r3, r2
 397 024e 1FD0     		beq	.L5
 229:../Generated_Code/DrvI2c1.c ****       DeviceDataPrv->OutLenM = 0x00U;  /* Any character is not for sent */
 398              		.loc 1 229 0
 399 0250 BB68     		ldr	r3, [r7, #8]
 400 0252 0022     		mov	r2, #0
 401 0254 9A81     		strh	r2, [r3, #12]
 230:../Generated_Code/DrvI2c1.c ****       DeviceDataPrv->InpLenM = 0x00U;  /* Any character is not for reception */
 402              		.loc 1 230 0
 403 0256 BB68     		ldr	r3, [r7, #8]
 404 0258 0022     		mov	r2, #0
 405 025a 9A80     		strh	r2, [r3, #4]
 231:../Generated_Code/DrvI2c1.c ****       DeviceDataPrv->SendStop = LDD_I2C_SEND_STOP; /* Set variable for sending stop condition (for 
 406              		.loc 1 231 0
 407 025c BB68     		ldr	r3, [r7, #8]
 408 025e 0122     		mov	r2, #1
 409 0260 5A70     		strb	r2, [r3, #1]
 232:../Generated_Code/DrvI2c1.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* Any character is not for sent or 
 410              		.loc 1 232 0
 411 0262 BB68     		ldr	r3, [r7, #8]
 412 0264 1B78     		ldrb	r3, [r3]
 413 0266 0122     		mov	r2, #1
 414 0268 9343     		bic	r3, r2
 415 026a DAB2     		uxtb	r2, r3
 416 026c BB68     		ldr	r3, [r7, #8]
 417 026e 1A70     		strb	r2, [r3]
 233:../Generated_Code/DrvI2c1.c ****       I2C_PDD_SetTransmitMode(I2C1_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode */
 418              		.loc 1 233 0
 419 0270 0E4B     		ldr	r3, .L16
 420 0272 0E4A     		ldr	r2, .L16
 421 0274 9278     		ldrb	r2, [r2, #2]
 422 0276 D2B2     		uxtb	r2, r2
 423 0278 1021     		mov	r1, #16
 424 027a 8A43     		bic	r2, r1
 425 027c D2B2     		uxtb	r2, r2
 426 027e 9A70     		strb	r2, [r3, #2]
 234:../Generated_Code/DrvI2c1.c ****       ErrorMask |= LDD_I2C_ARBIT_LOST; /* Set the ArbitLost error mask */
 427              		.loc 1 234 0
 428 0280 3B1C     		mov	r3, r7
 429 0282 0E33     		add	r3, r3, #14
 430 0284 3A1C     		mov	r2, r7
 431 0286 0E32     		add	r2, r2, #14
 432 0288 1288     		ldrh	r2, [r2]
 433 028a 0421     		mov	r1, #4
 434 028c 0A43     		orr	r2, r1
 435 028e 1A80     		strh	r2, [r3]
 436              	.L5:
 235:../Generated_Code/DrvI2c1.c ****     }
 236:../Generated_Code/DrvI2c1.c ****   }
 237:../Generated_Code/DrvI2c1.c ****   if (ErrorMask != 0x00U) {            /* Is any error mask set? */
 437              		.loc 1 237 0
 438 0290 3B1C     		mov	r3, r7
 439 0292 0E33     		add	r3, r3, #14
 440 0294 1B88     		ldrh	r3, [r3]
 441 0296 002B     		cmp	r3, #0
 442 0298 04D0     		beq	.L1
 238:../Generated_Code/DrvI2c1.c ****     DrvI2c1_OnError(DeviceDataPrv->UserData); /* If yes then invoke user event */
 443              		.loc 1 238 0
 444 029a BB68     		ldr	r3, [r7, #8]
 445 029c DB69     		ldr	r3, [r3, #28]
 446 029e 181C     		mov	r0, r3
 447 02a0 FFF7FEFF 		bl	DrvI2c1_OnError
 448              	.L1:
 239:../Generated_Code/DrvI2c1.c ****   }
 240:../Generated_Code/DrvI2c1.c **** }
 449              		.loc 1 240 0
 450 02a4 BD46     		mov	sp, r7
 451 02a6 05B0     		add	sp, sp, #20
 452              		@ sp needed for prologue
 453 02a8 90BD     		pop	{r4, r7, pc}
 454              	.L17:
 455 02aa C046     		.align	2
 456              	.L16:
 457 02ac 00700640 		.word	1074163712
 458              		.cfi_endproc
 459              	.LFE0:
 461              		.section	.text.DrvI2c1_Init,"ax",%progbits
 462              		.align	2
 463              		.global	DrvI2c1_Init
 464              		.code	16
 465              		.thumb_func
 467              	DrvI2c1_Init:
 468              	.LFB1:
 241:../Generated_Code/DrvI2c1.c **** 
 242:../Generated_Code/DrvI2c1.c **** /*
 243:../Generated_Code/DrvI2c1.c **** ** ===================================================================
 244:../Generated_Code/DrvI2c1.c **** **     Method      :  DrvI2c1_Init (component I2C_LDD)
 245:../Generated_Code/DrvI2c1.c **** **
 246:../Generated_Code/DrvI2c1.c **** **     Description :
 247:../Generated_Code/DrvI2c1.c **** **         Initializes the device. Allocates memory for the device data
 248:../Generated_Code/DrvI2c1.c **** **         structure, allocates interrupt vectors and sets interrupt
 249:../Generated_Code/DrvI2c1.c **** **         priority, sets pin routing, sets timing, etc.
 250:../Generated_Code/DrvI2c1.c **** **         If the "Enable in init. code" is set to "yes" value then the
 251:../Generated_Code/DrvI2c1.c **** **         device is also enabled(see the description of the Enable()
 252:../Generated_Code/DrvI2c1.c **** **         method). In this case the Enable() method is not necessary
 253:../Generated_Code/DrvI2c1.c **** **         and needn't to be generated. 
 254:../Generated_Code/DrvI2c1.c **** **         This method can be called only once. Before the second call
 255:../Generated_Code/DrvI2c1.c **** **         of Init() the Deinit() must be called first.
 256:../Generated_Code/DrvI2c1.c **** **     Parameters  :
 257:../Generated_Code/DrvI2c1.c **** **         NAME            - DESCRIPTION
 258:../Generated_Code/DrvI2c1.c **** **       * UserDataPtr     - Pointer to the user or
 259:../Generated_Code/DrvI2c1.c **** **                           RTOS specific data. This pointer will be
 260:../Generated_Code/DrvI2c1.c **** **                           passed as an event or callback parameter.
 261:../Generated_Code/DrvI2c1.c **** **     Returns     :
 262:../Generated_Code/DrvI2c1.c **** **         ---             - Pointer to the device data structure. 
 263:../Generated_Code/DrvI2c1.c **** ** ===================================================================
 264:../Generated_Code/DrvI2c1.c **** */
 265:../Generated_Code/DrvI2c1.c **** LDD_TDeviceData* DrvI2c1_Init(LDD_TUserData *UserDataPtr)
 266:../Generated_Code/DrvI2c1.c **** {
 469              		.loc 1 266 0
 470              		.cfi_startproc
 471 0000 80B5     		push	{r7, lr}
 472              	.LCFI3:
 473              		.cfi_def_cfa_offset 8
 474              		.cfi_offset 7, -8
 475              		.cfi_offset 14, -4
 476 0002 84B0     		sub	sp, sp, #16
 477              	.LCFI4:
 478              		.cfi_def_cfa_offset 24
 479 0004 00AF     		add	r7, sp, #0
 480              	.LCFI5:
 481              		.cfi_def_cfa_register 7
 482 0006 7860     		str	r0, [r7, #4]
 267:../Generated_Code/DrvI2c1.c ****   /* Allocate HAL device structure */
 268:../Generated_Code/DrvI2c1.c ****   DrvI2c1_TDeviceData *DeviceDataPrv;
 269:../Generated_Code/DrvI2c1.c ****   /* {MQXLite RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer 
 270:../Generated_Code/DrvI2c1.c ****   DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 483              		.loc 1 270 0
 484 0008 404B     		ldr	r3, .L20
 485 000a FB60     		str	r3, [r7, #12]
 271:../Generated_Code/DrvI2c1.c **** 
 272:../Generated_Code/DrvI2c1.c ****   DeviceDataPrv->UserData = UserDataPtr; /* Store the RTOS device structure */
 486              		.loc 1 272 0
 487 000c FB68     		ldr	r3, [r7, #12]
 488 000e 7A68     		ldr	r2, [r7, #4]
 489 0010 DA61     		str	r2, [r3, #28]
 273:../Generated_Code/DrvI2c1.c **** 
 274:../Generated_Code/DrvI2c1.c ****   /* Allocate interrupt vector */
 275:../Generated_Code/DrvI2c1.c ****   /* {MQXLite RTOS Adapter} Save old and set new interrupt vector (function handler and ISR paramet
 276:../Generated_Code/DrvI2c1.c ****   /* Note: Exception handler for interrupt is not saved, because it is not modified */
 277:../Generated_Code/DrvI2c1.c ****   DeviceDataPrv->SavedISRSettings.isrData = _int_get_isr_data(LDD_ivIndex_INT_I2C1);
 490              		.loc 1 277 0
 491 0012 1920     		mov	r0, #25
 492 0014 FFF7FEFF 		bl	_int_get_isr_data
 493 0018 021C     		mov	r2, r0
 494 001a FB68     		ldr	r3, [r7, #12]
 495 001c 9A61     		str	r2, [r3, #24]
 278:../Generated_Code/DrvI2c1.c ****   DeviceDataPrv->SavedISRSettings.isrFunction = _int_install_isr(LDD_ivIndex_INT_I2C1, DrvI2c1_Inte
 496              		.loc 1 278 0
 497 001e 3C4A     		ldr	r2, .L20+4
 498 0020 FB68     		ldr	r3, [r7, #12]
 499 0022 1920     		mov	r0, #25
 500 0024 111C     		mov	r1, r2
 501 0026 1A1C     		mov	r2, r3
 502 0028 FFF7FEFF 		bl	_int_install_isr
 503 002c 021C     		mov	r2, r0
 504 002e FB68     		ldr	r3, [r7, #12]
 505 0030 5A61     		str	r2, [r3, #20]
 279:../Generated_Code/DrvI2c1.c ****   DeviceDataPrv->SerFlag = ADDR_7;     /* Reset all flags start with 7-bit address mode */
 506              		.loc 1 279 0
 507 0032 FB68     		ldr	r3, [r7, #12]
 508 0034 2022     		mov	r2, #32
 509 0036 1A70     		strb	r2, [r3]
 280:../Generated_Code/DrvI2c1.c ****   DeviceDataPrv->SlaveAddr = 0x90U;    /* Set variable for slave address */
 510              		.loc 1 280 0
 511 0038 FB68     		ldr	r3, [r7, #12]
 512 003a 9022     		mov	r2, #144
 513 003c 9A70     		strb	r2, [r3, #2]
 281:../Generated_Code/DrvI2c1.c ****   DeviceDataPrv->SendStop = LDD_I2C_SEND_STOP; /* Set variable for sending stop condition (for mast
 514              		.loc 1 281 0
 515 003e FB68     		ldr	r3, [r7, #12]
 516 0040 0122     		mov	r2, #1
 517 0042 5A70     		strb	r2, [r3, #1]
 282:../Generated_Code/DrvI2c1.c ****   DeviceDataPrv->InpLenM = 0x00U;      /* Set zero counter of data of reception */
 518              		.loc 1 282 0
 519 0044 FB68     		ldr	r3, [r7, #12]
 520 0046 0022     		mov	r2, #0
 521 0048 9A80     		strh	r2, [r3, #4]
 283:../Generated_Code/DrvI2c1.c ****   DeviceDataPrv->OutLenM = 0x00U;      /* Set zero counter of data of transmission */
 522              		.loc 1 283 0
 523 004a FB68     		ldr	r3, [r7, #12]
 524 004c 0022     		mov	r2, #0
 525 004e 9A81     		strh	r2, [r3, #12]
 284:../Generated_Code/DrvI2c1.c ****   /* SIM_SCGC4: I2C1=1 */
 285:../Generated_Code/DrvI2c1.c ****   SIM_SCGC4 |= SIM_SCGC4_I2C1_MASK;                                                   
 526              		.loc 1 285 0
 527 0050 304A     		ldr	r2, .L20+8
 528 0052 3049     		ldr	r1, .L20+8
 529 0054 304B     		ldr	r3, .L20+12
 530 0056 CB58     		ldr	r3, [r1, r3]
 531 0058 8021     		mov	r1, #128
 532 005a 1943     		orr	r1, r3
 533 005c 2E4B     		ldr	r3, .L20+12
 534 005e D150     		str	r1, [r2, r3]
 286:../Generated_Code/DrvI2c1.c ****   /* I2C1_C1: IICEN=0,IICIE=0,MST=0,TX=0,TXAK=0,RSTA=0,WUEN=0,DMAEN=0 */
 287:../Generated_Code/DrvI2c1.c ****   I2C1_C1 = 0x00U;                     /* Clear control register */
 535              		.loc 1 287 0
 536 0060 2E4B     		ldr	r3, .L20+16
 537 0062 0022     		mov	r2, #0
 538 0064 9A70     		strb	r2, [r3, #2]
 288:../Generated_Code/DrvI2c1.c ****   /* I2C1_FLT: SHEN=0,STOPF=1,STOPIE=0,FLT=0 */
 289:../Generated_Code/DrvI2c1.c ****   I2C1_FLT = I2C_FLT_STOPF_MASK;       /* Clear bus status interrupt flags */
 539              		.loc 1 289 0
 540 0066 2D4B     		ldr	r3, .L20+16
 541 0068 4022     		mov	r2, #64
 542 006a 9A71     		strb	r2, [r3, #6]
 290:../Generated_Code/DrvI2c1.c ****   /* I2C1_S: TCF=0,IAAS=0,BUSY=0,ARBL=0,RAM=0,SRW=0,IICIF=1,RXAK=0 */
 291:../Generated_Code/DrvI2c1.c ****   I2C1_S = I2C_S_IICIF_MASK;           /* Clear interrupt flag */
 543              		.loc 1 291 0
 544 006c 2B4B     		ldr	r3, .L20+16
 545 006e 0222     		mov	r2, #2
 546 0070 DA70     		strb	r2, [r3, #3]
 292:../Generated_Code/DrvI2c1.c ****   /* PORTC_PCR11: ISF=0,MUX=2 */
 293:../Generated_Code/DrvI2c1.c ****   PORTC_PCR11 = (uint32_t)((PORTC_PCR11 & (uint32_t)~(uint32_t)(
 547              		.loc 1 293 0
 548 0072 2B4B     		ldr	r3, .L20+20
 549 0074 2A4A     		ldr	r2, .L20+20
 550 0076 D16A     		ldr	r1, [r2, #44]
 551 0078 2A4A     		ldr	r2, .L20+24
 552 007a 0A40     		and	r2, r1
 553 007c 8021     		mov	r1, #128
 554 007e 8900     		lsl	r1, r1, #2
 555 0080 0A43     		orr	r2, r1
 556 0082 DA62     		str	r2, [r3, #44]
 294:../Generated_Code/DrvI2c1.c ****                  PORT_PCR_ISF_MASK |
 295:../Generated_Code/DrvI2c1.c ****                  PORT_PCR_MUX(0x05)
 296:../Generated_Code/DrvI2c1.c ****                 )) | (uint32_t)(
 297:../Generated_Code/DrvI2c1.c ****                  PORT_PCR_MUX(0x02)
 298:../Generated_Code/DrvI2c1.c ****                 ));                                                  
 299:../Generated_Code/DrvI2c1.c ****   /* PORTC_PCR10: ISF=0,MUX=2 */
 300:../Generated_Code/DrvI2c1.c ****   PORTC_PCR10 = (uint32_t)((PORTC_PCR10 & (uint32_t)~(uint32_t)(
 557              		.loc 1 300 0
 558 0084 264B     		ldr	r3, .L20+20
 559 0086 264A     		ldr	r2, .L20+20
 560 0088 916A     		ldr	r1, [r2, #40]
 561 008a 264A     		ldr	r2, .L20+24
 562 008c 0A40     		and	r2, r1
 563 008e 8021     		mov	r1, #128
 564 0090 8900     		lsl	r1, r1, #2
 565 0092 0A43     		orr	r2, r1
 566 0094 9A62     		str	r2, [r3, #40]
 301:../Generated_Code/DrvI2c1.c ****                  PORT_PCR_ISF_MASK |
 302:../Generated_Code/DrvI2c1.c ****                  PORT_PCR_MUX(0x05)
 303:../Generated_Code/DrvI2c1.c ****                 )) | (uint32_t)(
 304:../Generated_Code/DrvI2c1.c ****                  PORT_PCR_MUX(0x02)
 305:../Generated_Code/DrvI2c1.c ****                 ));                                                  
 306:../Generated_Code/DrvI2c1.c ****   /* NVIC_IPR2: PRI_9=0x80 */
 307:../Generated_Code/DrvI2c1.c ****   NVIC_IPR2 = (uint32_t)((NVIC_IPR2 & (uint32_t)~(uint32_t)(
 567              		.loc 1 307 0
 568 0096 244A     		ldr	r2, .L20+28
 569 0098 2349     		ldr	r1, .L20+28
 570 009a C223     		mov	r3, #194
 571 009c 9B00     		lsl	r3, r3, #2
 572 009e C958     		ldr	r1, [r1, r3]
 573 00a0 224B     		ldr	r3, .L20+32
 574 00a2 0B40     		and	r3, r1
 575 00a4 8021     		mov	r1, #128
 576 00a6 0902     		lsl	r1, r1, #8
 577 00a8 1943     		orr	r1, r3
 578 00aa C223     		mov	r3, #194
 579 00ac 9B00     		lsl	r3, r3, #2
 580 00ae D150     		str	r1, [r2, r3]
 308:../Generated_Code/DrvI2c1.c ****                NVIC_IP_PRI_9(0x7F)
 309:../Generated_Code/DrvI2c1.c ****               )) | (uint32_t)(
 310:../Generated_Code/DrvI2c1.c ****                NVIC_IP_PRI_9(0x80)
 311:../Generated_Code/DrvI2c1.c ****               ));                                                  
 312:../Generated_Code/DrvI2c1.c ****   /* NVIC_ISER: SETENA|=0x0200 */
 313:../Generated_Code/DrvI2c1.c ****   NVIC_ISER |= NVIC_ISER_SETENA(0x0200);                                                   
 581              		.loc 1 313 0
 582 00b0 1D4B     		ldr	r3, .L20+28
 583 00b2 1D4A     		ldr	r2, .L20+28
 584 00b4 1268     		ldr	r2, [r2]
 585 00b6 8021     		mov	r1, #128
 586 00b8 8900     		lsl	r1, r1, #2
 587 00ba 0A43     		orr	r2, r1
 588 00bc 1A60     		str	r2, [r3]
 314:../Generated_Code/DrvI2c1.c ****   /* I2C1_C2: GCAEN=0,ADEXT=0,HDRS=0,SBRC=0,RMEN=0,AD=0 */
 315:../Generated_Code/DrvI2c1.c ****   I2C1_C2 = 0x00U;                                                   
 589              		.loc 1 315 0
 590 00be 174B     		ldr	r3, .L20+16
 591 00c0 0022     		mov	r2, #0
 592 00c2 5A71     		strb	r2, [r3, #5]
 316:../Generated_Code/DrvI2c1.c ****   /* I2C1_FLT: SHEN=0,STOPF=0,STOPIE=0,FLT=0 */
 317:../Generated_Code/DrvI2c1.c ****   I2C1_FLT = 0x00U;                    /* Set glitch filter register */
 593              		.loc 1 317 0
 594 00c4 154B     		ldr	r3, .L20+16
 595 00c6 0022     		mov	r2, #0
 596 00c8 9A71     		strb	r2, [r3, #6]
 318:../Generated_Code/DrvI2c1.c ****   /* I2C1_SMB: FACK=0,ALERTEN=0,SIICAEN=0,TCKSEL=0,SLTF=1,SHTF1=0,SHTF2=0,SHTF2IE=0 */
 319:../Generated_Code/DrvI2c1.c ****   I2C1_SMB = I2C_SMB_SLTF_MASK;                                                   
 597              		.loc 1 319 0
 598 00ca 144B     		ldr	r3, .L20+16
 599 00cc 0822     		mov	r2, #8
 600 00ce 1A72     		strb	r2, [r3, #8]
 320:../Generated_Code/DrvI2c1.c ****   /* I2C1_F: MULT=0,ICR=0x10 */
 321:../Generated_Code/DrvI2c1.c ****   I2C1_F = I2C_F_ICR(0x10);            /* Set prescaler bits */
 601              		.loc 1 321 0
 602 00d0 124B     		ldr	r3, .L20+16
 603 00d2 1022     		mov	r2, #16
 604 00d4 5A70     		strb	r2, [r3, #1]
 322:../Generated_Code/DrvI2c1.c ****   I2C_PDD_EnableDevice(I2C1_BASE_PTR, PDD_ENABLE); /* Enable device */
 605              		.loc 1 322 0
 606 00d6 114B     		ldr	r3, .L20+16
 607 00d8 104A     		ldr	r2, .L20+16
 608 00da 9278     		ldrb	r2, [r2, #2]
 609 00dc D2B2     		uxtb	r2, r2
 610 00de D2B2     		uxtb	r2, r2
 611 00e0 8021     		mov	r1, #128
 612 00e2 4942     		neg	r1, r1
 613 00e4 0A43     		orr	r2, r1
 614 00e6 D2B2     		uxtb	r2, r2
 615 00e8 D2B2     		uxtb	r2, r2
 616 00ea 9A70     		strb	r2, [r3, #2]
 323:../Generated_Code/DrvI2c1.c ****   I2C_PDD_EnableInterrupt(I2C1_BASE_PTR); /* Enable interrupt */
 617              		.loc 1 323 0
 618 00ec 0B4B     		ldr	r3, .L20+16
 619 00ee 0B4A     		ldr	r2, .L20+16
 620 00f0 9278     		ldrb	r2, [r2, #2]
 621 00f2 D2B2     		uxtb	r2, r2
 622 00f4 4021     		mov	r1, #64
 623 00f6 0A43     		orr	r2, r1
 624 00f8 D2B2     		uxtb	r2, r2
 625 00fa 9A70     		strb	r2, [r3, #2]
 324:../Generated_Code/DrvI2c1.c ****   /* Registration of the device structure */
 325:../Generated_Code/DrvI2c1.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_DrvI2c1_ID,DeviceDataPrv);
 626              		.loc 1 325 0
 627 00fc 0C4B     		ldr	r3, .L20+36
 628 00fe FA68     		ldr	r2, [r7, #12]
 629 0100 5A61     		str	r2, [r3, #20]
 326:../Generated_Code/DrvI2c1.c ****   return ((LDD_TDeviceData *)DeviceDataPrv); /* Return pointer to the data data structure */
 630              		.loc 1 326 0
 631 0102 FB68     		ldr	r3, [r7, #12]
 327:../Generated_Code/DrvI2c1.c **** }
 632              		.loc 1 327 0
 633 0104 181C     		mov	r0, r3
 634 0106 BD46     		mov	sp, r7
 635 0108 04B0     		add	sp, sp, #16
 636              		@ sp needed for prologue
 637 010a 80BD     		pop	{r7, pc}
 638              	.L21:
 639              		.align	2
 640              	.L20:
 641 010c 00000000 		.word	DeviceDataPrv__DEFAULT_RTOS_ALLOC
 642 0110 00000000 		.word	DrvI2c1_Interrupt
 643 0114 00700440 		.word	1074032640
 644 0118 34100000 		.word	4148
 645 011c 00700640 		.word	1074163712
 646 0120 00B00440 		.word	1074049024
 647 0124 FFF8FFFE 		.word	-16779009
 648 0128 00E100E0 		.word	-536813312
 649 012c FF00FFFF 		.word	-65281
 650 0130 00000000 		.word	PE_LDD_DeviceDataList
 651              		.cfi_endproc
 652              	.LFE1:
 654              		.section	.text.DrvI2c1_Deinit,"ax",%progbits
 655              		.align	2
 656              		.global	DrvI2c1_Deinit
 657              		.code	16
 658              		.thumb_func
 660              	DrvI2c1_Deinit:
 661              	.LFB2:
 328:../Generated_Code/DrvI2c1.c **** 
 329:../Generated_Code/DrvI2c1.c **** /*
 330:../Generated_Code/DrvI2c1.c **** ** ===================================================================
 331:../Generated_Code/DrvI2c1.c **** **     Method      :  DrvI2c1_Deinit (component I2C_LDD)
 332:../Generated_Code/DrvI2c1.c **** **
 333:../Generated_Code/DrvI2c1.c **** **     Description :
 334:../Generated_Code/DrvI2c1.c **** **         Deinitializes the device. Switches off the device, frees the
 335:../Generated_Code/DrvI2c1.c **** **         device data structure memory, interrupts vectors, etc.
 336:../Generated_Code/DrvI2c1.c **** **     Parameters  :
 337:../Generated_Code/DrvI2c1.c **** **         NAME            - DESCRIPTION
 338:../Generated_Code/DrvI2c1.c **** **       * DeviceDataPtr   - Device data structure
 339:../Generated_Code/DrvI2c1.c **** **                           pointer returned by <Init> method.
 340:../Generated_Code/DrvI2c1.c **** **     Returns     : Nothing
 341:../Generated_Code/DrvI2c1.c **** ** ===================================================================
 342:../Generated_Code/DrvI2c1.c **** */
 343:../Generated_Code/DrvI2c1.c **** void DrvI2c1_Deinit(LDD_TDeviceData *DeviceDataPtr)
 344:../Generated_Code/DrvI2c1.c **** {
 662              		.loc 1 344 0
 663              		.cfi_startproc
 664 0000 80B5     		push	{r7, lr}
 665              	.LCFI6:
 666              		.cfi_def_cfa_offset 8
 667              		.cfi_offset 7, -8
 668              		.cfi_offset 14, -4
 669 0002 82B0     		sub	sp, sp, #8
 670              	.LCFI7:
 671              		.cfi_def_cfa_offset 16
 672 0004 00AF     		add	r7, sp, #0
 673              	.LCFI8:
 674              		.cfi_def_cfa_register 7
 675 0006 7860     		str	r0, [r7, #4]
 345:../Generated_Code/DrvI2c1.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 346:../Generated_Code/DrvI2c1.c **** 
 347:../Generated_Code/DrvI2c1.c ****   /* I2C1_C1: IICEN=0,IICIE=0,MST=0,TX=0,TXAK=0,RSTA=0,WUEN=0,DMAEN=0 */
 348:../Generated_Code/DrvI2c1.c ****   I2C1_C1 = 0x00U;                     /* Reset I2C Control register */
 676              		.loc 1 348 0
 677 0008 0D4B     		ldr	r3, .L23
 678 000a 0022     		mov	r2, #0
 679 000c 9A70     		strb	r2, [r3, #2]
 349:../Generated_Code/DrvI2c1.c ****   /* Restoring the interrupt vector */
 350:../Generated_Code/DrvI2c1.c ****   /* {MQXLite RTOS Adapter} Restore interrupt vector (function handler and ISR parameter) */
 351:../Generated_Code/DrvI2c1.c ****   /* Note: Exception handler for interrupt is not restored, because it was not modified */
 352:../Generated_Code/DrvI2c1.c ****   (void)_int_install_isr(LDD_ivIndex_INT_I2C1, ((DrvI2c1_TDeviceDataPtr)DeviceDataPtr)->SavedISRSet
 680              		.loc 1 352 0
 681 000e 7B68     		ldr	r3, [r7, #4]
 682 0010 5A69     		ldr	r2, [r3, #20]
 683 0012 7B68     		ldr	r3, [r7, #4]
 684 0014 9B69     		ldr	r3, [r3, #24]
 685 0016 1920     		mov	r0, #25
 686 0018 111C     		mov	r1, r2
 687 001a 1A1C     		mov	r2, r3
 688 001c FFF7FEFF 		bl	_int_install_isr
 353:../Generated_Code/DrvI2c1.c ****   /* Unregistration of the device structure */
 354:../Generated_Code/DrvI2c1.c ****   PE_LDD_UnregisterDeviceStructure(PE_LDD_COMPONENT_DrvI2c1_ID);
 689              		.loc 1 354 0
 690 0020 084B     		ldr	r3, .L23+4
 691 0022 0022     		mov	r2, #0
 692 0024 5A61     		str	r2, [r3, #20]
 355:../Generated_Code/DrvI2c1.c ****   /* Deallocation of the device structure */
 356:../Generated_Code/DrvI2c1.c ****   /* {MQXLite RTOS Adapter} Driver memory deallocation: Dynamic allocation is simulated, no dealloc
 357:../Generated_Code/DrvI2c1.c ****   /* SIM_SCGC4: I2C1=0 */
 358:../Generated_Code/DrvI2c1.c ****   SIM_SCGC4 &= (uint32_t)~(uint32_t)(SIM_SCGC4_I2C1_MASK);                                         
 693              		.loc 1 358 0
 694 0026 084A     		ldr	r2, .L23+8
 695 0028 0749     		ldr	r1, .L23+8
 696 002a 084B     		ldr	r3, .L23+12
 697 002c CB58     		ldr	r3, [r1, r3]
 698 002e 8021     		mov	r1, #128
 699 0030 181C     		mov	r0, r3
 700 0032 8843     		bic	r0, r1
 701 0034 011C     		mov	r1, r0
 702 0036 054B     		ldr	r3, .L23+12
 703 0038 D150     		str	r1, [r2, r3]
 359:../Generated_Code/DrvI2c1.c **** }
 704              		.loc 1 359 0
 705 003a BD46     		mov	sp, r7
 706 003c 02B0     		add	sp, sp, #8
 707              		@ sp needed for prologue
 708 003e 80BD     		pop	{r7, pc}
 709              	.L24:
 710              		.align	2
 711              	.L23:
 712 0040 00700640 		.word	1074163712
 713 0044 00000000 		.word	PE_LDD_DeviceDataList
 714 0048 00700440 		.word	1074032640
 715 004c 34100000 		.word	4148
 716              		.cfi_endproc
 717              	.LFE2:
 719              		.section	.text.DrvI2c1_MasterSendBlock,"ax",%progbits
 720              		.align	2
 721              		.global	DrvI2c1_MasterSendBlock
 722              		.code	16
 723              		.thumb_func
 725              	DrvI2c1_MasterSendBlock:
 726              	.LFB3:
 360:../Generated_Code/DrvI2c1.c **** 
 361:../Generated_Code/DrvI2c1.c **** /*
 362:../Generated_Code/DrvI2c1.c **** ** ===================================================================
 363:../Generated_Code/DrvI2c1.c **** **     Method      :  DrvI2c1_MasterSendBlock (component I2C_LDD)
 364:../Generated_Code/DrvI2c1.c **** **
 365:../Generated_Code/DrvI2c1.c **** **     Description :
 366:../Generated_Code/DrvI2c1.c **** **         This method writes one (7-bit addressing) or two (10-bit
 367:../Generated_Code/DrvI2c1.c **** **         addressing) slave address bytes inclusive of R/W bit = 0 to
 368:../Generated_Code/DrvI2c1.c **** **         the I2C bus and then writes the block of characters to the
 369:../Generated_Code/DrvI2c1.c **** **         bus. The slave address must be specified before, by the
 370:../Generated_Code/DrvI2c1.c **** **         "SelectSlaveDevice" method or in component initialization
 371:../Generated_Code/DrvI2c1.c **** **         section, "Target slave address init" property. If the method
 372:../Generated_Code/DrvI2c1.c **** **         returns ERR_OK, it doesn't mean that transmission was
 373:../Generated_Code/DrvI2c1.c **** **         successful. The state of transmission is detectable by means
 374:../Generated_Code/DrvI2c1.c **** **         of events (OnMasterSendComplete or OnError). Data to be sent
 375:../Generated_Code/DrvI2c1.c **** **         are not copied to an internal buffer and remains in the
 376:../Generated_Code/DrvI2c1.c **** **         original location. Therefore the content of the buffer
 377:../Generated_Code/DrvI2c1.c **** **         should not be changed until the transmission is complete.
 378:../Generated_Code/DrvI2c1.c **** **         Event "OnMasterBlockSent"can be used to detect the end of
 379:../Generated_Code/DrvI2c1.c **** **         the transmission. This method is available only for the
 380:../Generated_Code/DrvI2c1.c **** **         MASTER or MASTER - SLAVE mode.
 381:../Generated_Code/DrvI2c1.c **** **     Parameters  :
 382:../Generated_Code/DrvI2c1.c **** **         NAME            - DESCRIPTION
 383:../Generated_Code/DrvI2c1.c **** **       * DeviceDataPtr   - Device data structure
 384:../Generated_Code/DrvI2c1.c **** **                           pointer returned by <Init> method.
 385:../Generated_Code/DrvI2c1.c **** **       * BufferPtr       - Pointer to the block of data
 386:../Generated_Code/DrvI2c1.c **** **                           to send.
 387:../Generated_Code/DrvI2c1.c **** **         Size            - Size of the data block.
 388:../Generated_Code/DrvI2c1.c **** **         SendStop        - Parameter for generating I2C
 389:../Generated_Code/DrvI2c1.c **** **                           Stop condition
 390:../Generated_Code/DrvI2c1.c **** **                           LDD_I2C_SEND_STOP - Stop condition is
 391:../Generated_Code/DrvI2c1.c **** **                           generated on end transmission.
 392:../Generated_Code/DrvI2c1.c **** **                           LDD_I2C_NO_SEND_STOP - Stop condition isn't
 393:../Generated_Code/DrvI2c1.c **** **                           generated on end transmission.
 394:../Generated_Code/DrvI2c1.c **** **     Returns     :
 395:../Generated_Code/DrvI2c1.c **** **         ---             - Error code, possible codes:
 396:../Generated_Code/DrvI2c1.c **** **                           ERR_OK - OK
 397:../Generated_Code/DrvI2c1.c **** **                           ERR_DISABLED -  Device is disabled
 398:../Generated_Code/DrvI2c1.c **** **                           ERR_SPEED - This device does not work in
 399:../Generated_Code/DrvI2c1.c **** **                           the active clock configuration
 400:../Generated_Code/DrvI2c1.c **** **                           ERR_BUSY - The I2C device is now running
 401:../Generated_Code/DrvI2c1.c **** ** ===================================================================
 402:../Generated_Code/DrvI2c1.c **** */
 403:../Generated_Code/DrvI2c1.c **** LDD_TError DrvI2c1_MasterSendBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, LDD_I2C_TS
 404:../Generated_Code/DrvI2c1.c **** {
 727              		.loc 1 404 0
 728              		.cfi_startproc
 729 0000 80B5     		push	{r7, lr}
 730              	.LCFI9:
 731              		.cfi_def_cfa_offset 8
 732              		.cfi_offset 7, -8
 733              		.cfi_offset 14, -4
 734 0002 86B0     		sub	sp, sp, #24
 735              	.LCFI10:
 736              		.cfi_def_cfa_offset 32
 737 0004 00AF     		add	r7, sp, #0
 738              	.LCFI11:
 739              		.cfi_def_cfa_register 7
 740 0006 F860     		str	r0, [r7, #12]
 741 0008 B960     		str	r1, [r7, #8]
 742 000a 111C     		mov	r1, r2
 743 000c 1A1C     		mov	r2, r3
 744 000e BB1D     		add	r3, r7, #6
 745 0010 1980     		strh	r1, [r3]
 746 0012 7B1D     		add	r3, r7, #5
 747 0014 1A70     		strb	r2, [r3]
 405:../Generated_Code/DrvI2c1.c ****   DrvI2c1_TDeviceData *DeviceDataPrv = (DrvI2c1_TDeviceData *)DeviceDataPtr;
 748              		.loc 1 405 0
 749 0016 FB68     		ldr	r3, [r7, #12]
 750 0018 7B61     		str	r3, [r7, #20]
 406:../Generated_Code/DrvI2c1.c **** 
 407:../Generated_Code/DrvI2c1.c ****   if (Size == 0x00U) {                 /* Test variable Size on zero */
 751              		.loc 1 407 0
 752 001a BB1D     		add	r3, r7, #6
 753 001c 1B88     		ldrh	r3, [r3]
 754 001e 002B     		cmp	r3, #0
 755 0020 01D1     		bne	.L26
 408:../Generated_Code/DrvI2c1.c ****     return ERR_OK;                     /* If zero then OK */
 756              		.loc 1 408 0
 757 0022 0023     		mov	r3, #0
 758 0024 91E0     		b	.L27
 759              	.L26:
 409:../Generated_Code/DrvI2c1.c ****   }
 410:../Generated_Code/DrvI2c1.c ****   if (DeviceDataPrv->SendStop == LDD_I2C_SEND_STOP) {
 760              		.loc 1 410 0
 761 0026 7B69     		ldr	r3, [r7, #20]
 762 0028 5B78     		ldrb	r3, [r3, #1]
 763 002a 012B     		cmp	r3, #1
 764 002c 12D1     		bne	.L28
 411:../Generated_Code/DrvI2c1.c ****     if ((I2C_PDD_GetBusStatus(I2C1_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 765              		.loc 1 411 0
 766 002e 494B     		ldr	r3, .L37
 767 0030 DB78     		ldrb	r3, [r3, #3]
 768 0032 DBB2     		uxtb	r3, r3
 769 0034 1A1C     		mov	r2, r3
 770 0036 2023     		mov	r3, #32
 771 0038 1340     		and	r3, r2
 772 003a 09D1     		bne	.L29
 412:../Generated_Code/DrvI2c1.c ****        ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 773              		.loc 1 412 0
 774 003c 7B69     		ldr	r3, [r7, #20]
 775 003e 1B78     		ldrb	r3, [r3]
 776 0040 1A1C     		mov	r2, r3
 777 0042 0123     		mov	r3, #1
 778 0044 1340     		and	r3, r2
 411:../Generated_Code/DrvI2c1.c ****     if ((I2C_PDD_GetBusStatus(I2C1_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 779              		.loc 1 411 0
 780 0046 03D1     		bne	.L29
 413:../Generated_Code/DrvI2c1.c ****        (DeviceDataPrv->OutLenM != 0x00U))  {
 781              		.loc 1 413 0
 782 0048 7B69     		ldr	r3, [r7, #20]
 783 004a 9B89     		ldrh	r3, [r3, #12]
 412:../Generated_Code/DrvI2c1.c ****        ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 784              		.loc 1 412 0
 785 004c 002B     		cmp	r3, #0
 786 004e 0DD0     		beq	.L30
 787              	.L29:
 414:../Generated_Code/DrvI2c1.c ****       return ERR_BUSY;                 /* If yes then error */
 788              		.loc 1 414 0
 789 0050 0823     		mov	r3, #8
 790 0052 7AE0     		b	.L27
 791              	.L28:
 415:../Generated_Code/DrvI2c1.c ****     }
 416:../Generated_Code/DrvI2c1.c ****   } else {
 417:../Generated_Code/DrvI2c1.c ****     if (((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 792              		.loc 1 417 0
 793 0054 7B69     		ldr	r3, [r7, #20]
 794 0056 1B78     		ldrb	r3, [r3]
 795 0058 1A1C     		mov	r2, r3
 796 005a 0123     		mov	r3, #1
 797 005c 1340     		and	r3, r2
 798 005e 03D1     		bne	.L31
 418:../Generated_Code/DrvI2c1.c ****       (DeviceDataPrv->OutLenM != 0x00U))  {
 799              		.loc 1 418 0
 800 0060 7B69     		ldr	r3, [r7, #20]
 801 0062 9B89     		ldrh	r3, [r3, #12]
 417:../Generated_Code/DrvI2c1.c ****     if (((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 802              		.loc 1 417 0
 803 0064 002B     		cmp	r3, #0
 804 0066 01D0     		beq	.L30
 805              	.L31:
 419:../Generated_Code/DrvI2c1.c ****       return ERR_BUSY;                 /* If yes then error */
 806              		.loc 1 419 0
 807 0068 0823     		mov	r3, #8
 808 006a 6EE0     		b	.L27
 809              	.L30:
 420:../Generated_Code/DrvI2c1.c ****     }
 421:../Generated_Code/DrvI2c1.c ****   }
 422:../Generated_Code/DrvI2c1.c ****   /* {MQXLite RTOS Adapter} Critical section begin (RTOS function call is defined by MQXLite RTOS A
 423:../Generated_Code/DrvI2c1.c ****   _int_disable();
 810              		.loc 1 423 0
 811 006c FFF7FEFF 		bl	_int_disable
 424:../Generated_Code/DrvI2c1.c ****   DeviceDataPrv->SerFlag |= MASTER_IN_PROGRES; /* Set flag "busy" */
 812              		.loc 1 424 0
 813 0070 7B69     		ldr	r3, [r7, #20]
 814 0072 1B78     		ldrb	r3, [r3]
 815 0074 0122     		mov	r2, #1
 816 0076 1343     		orr	r3, r2
 817 0078 DAB2     		uxtb	r2, r3
 818 007a 7B69     		ldr	r3, [r7, #20]
 819 007c 1A70     		strb	r2, [r3]
 425:../Generated_Code/DrvI2c1.c ****   DeviceDataPrv->OutPtrM = (uint8_t *)BufferPtr; /* Save pointer to data for transmitting */
 820              		.loc 1 425 0
 821 007e 7B69     		ldr	r3, [r7, #20]
 822 0080 BA68     		ldr	r2, [r7, #8]
 823 0082 1A61     		str	r2, [r3, #16]
 426:../Generated_Code/DrvI2c1.c ****   DeviceDataPrv->OutLenM = Size;       /* Set the counter of output bufer's content */
 824              		.loc 1 426 0
 825 0084 7B69     		ldr	r3, [r7, #20]
 826 0086 BA1D     		add	r2, r7, #6
 827 0088 1288     		ldrh	r2, [r2]
 828 008a 9A81     		strh	r2, [r3, #12]
 427:../Generated_Code/DrvI2c1.c ****   DeviceDataPrv->SendStop = SendStop;  /* Set generating stop condition */
 829              		.loc 1 427 0
 830 008c 7B69     		ldr	r3, [r7, #20]
 831 008e 7A1D     		add	r2, r7, #5
 832 0090 1278     		ldrb	r2, [r2]
 833 0092 5A70     		strb	r2, [r3, #1]
 428:../Generated_Code/DrvI2c1.c ****   I2C_PDD_SetTransmitMode(I2C1_BASE_PTR, I2C_PDD_TX_DIRECTION); /* Set TX mode */
 834              		.loc 1 428 0
 835 0094 2F4B     		ldr	r3, .L37
 836 0096 2F4A     		ldr	r2, .L37
 837 0098 9278     		ldrb	r2, [r2, #2]
 838 009a D2B2     		uxtb	r2, r2
 839 009c D2B2     		uxtb	r2, r2
 840 009e 1021     		mov	r1, #16
 841 00a0 0A43     		orr	r2, r1
 842 00a2 D2B2     		uxtb	r2, r2
 843 00a4 D2B2     		uxtb	r2, r2
 844 00a6 9A70     		strb	r2, [r3, #2]
 429:../Generated_Code/DrvI2c1.c ****   if (I2C_PDD_GetMasterMode(I2C1_BASE_PTR) == I2C_PDD_MASTER_MODE) { /* Is device in master mode? *
 845              		.loc 1 429 0
 846 00a8 2A4B     		ldr	r3, .L37
 847 00aa 9B78     		ldrb	r3, [r3, #2]
 848 00ac DBB2     		uxtb	r3, r3
 849 00ae 1A1C     		mov	r2, r3
 850 00b0 2023     		mov	r3, #32
 851 00b2 1340     		and	r3, r2
 852 00b4 08D0     		beq	.L32
 430:../Generated_Code/DrvI2c1.c ****     I2C_PDD_RepeatStart(I2C1_BASE_PTR); /* If yes then repeat start cycle generated */
 853              		.loc 1 430 0
 854 00b6 274B     		ldr	r3, .L37
 855 00b8 264A     		ldr	r2, .L37
 856 00ba 9278     		ldrb	r2, [r2, #2]
 857 00bc D2B2     		uxtb	r2, r2
 858 00be 0421     		mov	r1, #4
 859 00c0 0A43     		orr	r2, r1
 860 00c2 D2B2     		uxtb	r2, r2
 861 00c4 9A70     		strb	r2, [r3, #2]
 862 00c6 09E0     		b	.L33
 863              	.L32:
 431:../Generated_Code/DrvI2c1.c ****   } else {
 432:../Generated_Code/DrvI2c1.c ****     I2C_PDD_SetMasterMode(I2C1_BASE_PTR, I2C_PDD_MASTER_MODE); /* If no then start signal generated
 864              		.loc 1 432 0
 865 00c8 224B     		ldr	r3, .L37
 866 00ca 224A     		ldr	r2, .L37
 867 00cc 9278     		ldrb	r2, [r2, #2]
 868 00ce D2B2     		uxtb	r2, r2
 869 00d0 D2B2     		uxtb	r2, r2
 870 00d2 2021     		mov	r1, #32
 871 00d4 0A43     		orr	r2, r1
 872 00d6 D2B2     		uxtb	r2, r2
 873 00d8 D2B2     		uxtb	r2, r2
 874 00da 9A70     		strb	r2, [r3, #2]
 875              	.L33:
 433:../Generated_Code/DrvI2c1.c ****   }
 434:../Generated_Code/DrvI2c1.c ****   if ((DeviceDataPrv->SerFlag & ADDR_7) != 0x00U) { /* Is 7-bit addressing set ? */
 876              		.loc 1 434 0
 877 00dc 7B69     		ldr	r3, [r7, #20]
 878 00de 1B78     		ldrb	r3, [r3]
 879 00e0 1A1C     		mov	r2, r3
 880 00e2 2023     		mov	r3, #32
 881 00e4 1340     		and	r3, r2
 882 00e6 0BD0     		beq	.L34
 435:../Generated_Code/DrvI2c1.c ****     DeviceDataPrv->SerFlag |= (ADDR_COMPLETE | REP_ADDR_COMPLETE); /* Only one byte of address will
 883              		.loc 1 435 0
 884 00e8 7B69     		ldr	r3, [r7, #20]
 885 00ea 1B78     		ldrb	r3, [r3]
 886 00ec 0622     		mov	r2, #6
 887 00ee 1343     		orr	r3, r2
 888 00f0 DAB2     		uxtb	r2, r3
 889 00f2 7B69     		ldr	r3, [r7, #20]
 890 00f4 1A70     		strb	r2, [r3]
 436:../Generated_Code/DrvI2c1.c ****     I2C_PDD_WriteDataReg(I2C1_BASE_PTR, DeviceDataPrv->SlaveAddr); /* Send slave address */
 891              		.loc 1 436 0
 892 00f6 174B     		ldr	r3, .L37
 893 00f8 7A69     		ldr	r2, [r7, #20]
 894 00fa 9278     		ldrb	r2, [r2, #2]
 895 00fc 1A71     		strb	r2, [r3, #4]
 896 00fe 21E0     		b	.L35
 897              	.L34:
 437:../Generated_Code/DrvI2c1.c ****   } else {
 438:../Generated_Code/DrvI2c1.c ****     if ((DeviceDataPrv->SerFlag & ADDR_10) != 0x00U) { /* Is 10-bit addressing set ? */
 898              		.loc 1 438 0
 899 0100 7B69     		ldr	r3, [r7, #20]
 900 0102 1B78     		ldrb	r3, [r3]
 901 0104 1A1C     		mov	r2, r3
 902 0106 1023     		mov	r3, #16
 903 0108 1340     		and	r3, r2
 904 010a 0BD0     		beq	.L36
 439:../Generated_Code/DrvI2c1.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(ADDR_COMPLETE | REP_ADDR_COMPLETE); /* Second byte of ad
 905              		.loc 1 439 0
 906 010c 7B69     		ldr	r3, [r7, #20]
 907 010e 1B78     		ldrb	r3, [r3]
 908 0110 0622     		mov	r2, #6
 909 0112 9343     		bic	r3, r2
 910 0114 DAB2     		uxtb	r2, r3
 911 0116 7B69     		ldr	r3, [r7, #20]
 912 0118 1A70     		strb	r2, [r3]
 440:../Generated_Code/DrvI2c1.c ****       I2C_PDD_WriteDataReg(I2C1_BASE_PTR, DeviceDataPrv->SlaveAddrHigh); /* Send slave address - hi
 913              		.loc 1 440 0
 914 011a 0E4B     		ldr	r3, .L37
 915 011c 7A69     		ldr	r2, [r7, #20]
 916 011e D278     		ldrb	r2, [r2, #3]
 917 0120 1A71     		strb	r2, [r3, #4]
 918 0122 0FE0     		b	.L35
 919              	.L36:
 441:../Generated_Code/DrvI2c1.c ****     } else {
 442:../Generated_Code/DrvI2c1.c ****       if ((DeviceDataPrv->SerFlag & GENERAL_CALL) != 0x00U) { /* Is general call command required ?
 920              		.loc 1 442 0
 921 0124 7B69     		ldr	r3, [r7, #20]
 922 0126 1B78     		ldrb	r3, [r3]
 923 0128 1A1C     		mov	r2, r3
 924 012a 0823     		mov	r3, #8
 925 012c 1340     		and	r3, r2
 926 012e 09D0     		beq	.L35
 443:../Generated_Code/DrvI2c1.c ****         DeviceDataPrv->SerFlag |= ADDR_COMPLETE; /* Only one byte of address will be sent in genera
 927              		.loc 1 443 0
 928 0130 7B69     		ldr	r3, [r7, #20]
 929 0132 1B78     		ldrb	r3, [r3]
 930 0134 0222     		mov	r2, #2
 931 0136 1343     		orr	r3, r2
 932 0138 DAB2     		uxtb	r2, r3
 933 013a 7B69     		ldr	r3, [r7, #20]
 934 013c 1A70     		strb	r2, [r3]
 444:../Generated_Code/DrvI2c1.c ****         I2C_PDD_WriteDataReg(I2C1_BASE_PTR, 0x00U); /* Send general call address */
 935              		.loc 1 444 0
 936 013e 054B     		ldr	r3, .L37
 937 0140 0022     		mov	r2, #0
 938 0142 1A71     		strb	r2, [r3, #4]
 939              	.L35:
 445:../Generated_Code/DrvI2c1.c ****       }
 446:../Generated_Code/DrvI2c1.c ****     }
 447:../Generated_Code/DrvI2c1.c ****   }
 448:../Generated_Code/DrvI2c1.c ****   /* {MQXLite RTOS Adapter} Critical section ends (RTOS function call is defined by MQXLite RTOS Ad
 449:../Generated_Code/DrvI2c1.c ****   _int_enable();
 940              		.loc 1 449 0
 941 0144 FFF7FEFF 		bl	_int_enable
 450:../Generated_Code/DrvI2c1.c ****   return ERR_OK;                       /* OK */
 942              		.loc 1 450 0
 943 0148 0023     		mov	r3, #0
 944              	.L27:
 451:../Generated_Code/DrvI2c1.c **** }
 945              		.loc 1 451 0
 946 014a 181C     		mov	r0, r3
 947 014c BD46     		mov	sp, r7
 948 014e 06B0     		add	sp, sp, #24
 949              		@ sp needed for prologue
 950 0150 80BD     		pop	{r7, pc}
 951              	.L38:
 952 0152 C046     		.align	2
 953              	.L37:
 954 0154 00700640 		.word	1074163712
 955              		.cfi_endproc
 956              	.LFE3:
 958              		.section	.text.DrvI2c1_MasterReceiveBlock,"ax",%progbits
 959              		.align	2
 960              		.global	DrvI2c1_MasterReceiveBlock
 961              		.code	16
 962              		.thumb_func
 964              	DrvI2c1_MasterReceiveBlock:
 965              	.LFB4:
 452:../Generated_Code/DrvI2c1.c **** 
 453:../Generated_Code/DrvI2c1.c **** /*
 454:../Generated_Code/DrvI2c1.c **** ** ===================================================================
 455:../Generated_Code/DrvI2c1.c **** **     Method      :  DrvI2c1_MasterReceiveBlock (component I2C_LDD)
 456:../Generated_Code/DrvI2c1.c **** **
 457:../Generated_Code/DrvI2c1.c **** **     Description :
 458:../Generated_Code/DrvI2c1.c **** **         This method writes one (7-bit addressing) or two (10-bit
 459:../Generated_Code/DrvI2c1.c **** **         addressing) slave address bytes inclusive of R/W bit = 1 to
 460:../Generated_Code/DrvI2c1.c **** **         the I2C bus and then receives the block of characters from
 461:../Generated_Code/DrvI2c1.c **** **         the bus. The slave address must be specified before, by the
 462:../Generated_Code/DrvI2c1.c **** **         "SelectSlaveDevice" method or in component initialization
 463:../Generated_Code/DrvI2c1.c **** **         section, "Target slave address init" property. If the method
 464:../Generated_Code/DrvI2c1.c **** **         returns ERR_OK, it doesn't mean that reception was
 465:../Generated_Code/DrvI2c1.c **** **         successful. The state of reception is detectable by means of
 466:../Generated_Code/DrvI2c1.c **** **         events (OnMasterSendComplete  or OnError). Data to be
 467:../Generated_Code/DrvI2c1.c **** **         received are not copied to an internal buffer and remains in
 468:../Generated_Code/DrvI2c1.c **** **         the original location. Therefore the content of the buffer
 469:../Generated_Code/DrvI2c1.c **** **         should not be changed until the transmission is complete.
 470:../Generated_Code/DrvI2c1.c **** **         Event "OnMasterBlockReceived"can be used to detect the end
 471:../Generated_Code/DrvI2c1.c **** **         of the reception. This method is available only for the
 472:../Generated_Code/DrvI2c1.c **** **         MASTER or MASTER - SLAVE mode.
 473:../Generated_Code/DrvI2c1.c **** **     Parameters  :
 474:../Generated_Code/DrvI2c1.c **** **         NAME            - DESCRIPTION
 475:../Generated_Code/DrvI2c1.c **** **       * DeviceDataPtr   - Device data structure
 476:../Generated_Code/DrvI2c1.c **** **                           pointer returned by <Init> method.
 477:../Generated_Code/DrvI2c1.c **** **       * BufferPtr       - Pointer to a buffer where
 478:../Generated_Code/DrvI2c1.c **** **                           received characters will be stored.
 479:../Generated_Code/DrvI2c1.c **** **         Size            - The size of the block.
 480:../Generated_Code/DrvI2c1.c **** **         SendStop        - Parameter for generating I2C
 481:../Generated_Code/DrvI2c1.c **** **                           Stop condition
 482:../Generated_Code/DrvI2c1.c **** **                           LDD_I2C_SEND_STOP - Stop condition is
 483:../Generated_Code/DrvI2c1.c **** **                           generated on end transmission.
 484:../Generated_Code/DrvI2c1.c **** **                           LDD_I2C_NO_SEND_STOP - Stop condition isn't
 485:../Generated_Code/DrvI2c1.c **** **                           generated on end transmission.
 486:../Generated_Code/DrvI2c1.c **** **     Returns     :
 487:../Generated_Code/DrvI2c1.c **** **         ---             - Error code, possible codes:
 488:../Generated_Code/DrvI2c1.c **** **                           ERR_OK - OK
 489:../Generated_Code/DrvI2c1.c **** **                           ERR_DISABLED -  Device is disabled
 490:../Generated_Code/DrvI2c1.c **** **                           ERR_SPEED - This device does not work in
 491:../Generated_Code/DrvI2c1.c **** **                           the active clock configuration
 492:../Generated_Code/DrvI2c1.c **** **                           ERR_BUSY - The master device is busy
 493:../Generated_Code/DrvI2c1.c **** **                           ERR_NOTAVAIL - It is not possible to
 494:../Generated_Code/DrvI2c1.c **** **                           receive data if general call address is set.
 495:../Generated_Code/DrvI2c1.c **** **                           ERR_PARAM_MODE -  Stop condition isn't
 496:../Generated_Code/DrvI2c1.c **** **                           possible generated on end transmission.
 497:../Generated_Code/DrvI2c1.c **** ** ===================================================================
 498:../Generated_Code/DrvI2c1.c **** */
 499:../Generated_Code/DrvI2c1.c **** LDD_TError DrvI2c1_MasterReceiveBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, LDD_I2C
 500:../Generated_Code/DrvI2c1.c **** {
 966              		.loc 1 500 0
 967              		.cfi_startproc
 968 0000 80B5     		push	{r7, lr}
 969              	.LCFI12:
 970              		.cfi_def_cfa_offset 8
 971              		.cfi_offset 7, -8
 972              		.cfi_offset 14, -4
 973 0002 86B0     		sub	sp, sp, #24
 974              	.LCFI13:
 975              		.cfi_def_cfa_offset 32
 976 0004 00AF     		add	r7, sp, #0
 977              	.LCFI14:
 978              		.cfi_def_cfa_register 7
 979 0006 F860     		str	r0, [r7, #12]
 980 0008 B960     		str	r1, [r7, #8]
 981 000a 111C     		mov	r1, r2
 982 000c 1A1C     		mov	r2, r3
 983 000e BB1D     		add	r3, r7, #6
 984 0010 1980     		strh	r1, [r3]
 985 0012 7B1D     		add	r3, r7, #5
 986 0014 1A70     		strb	r2, [r3]
 501:../Generated_Code/DrvI2c1.c ****   DrvI2c1_TDeviceData *DeviceDataPrv = (DrvI2c1_TDeviceData *)DeviceDataPtr;
 987              		.loc 1 501 0
 988 0016 FB68     		ldr	r3, [r7, #12]
 989 0018 7B61     		str	r3, [r7, #20]
 502:../Generated_Code/DrvI2c1.c **** 
 503:../Generated_Code/DrvI2c1.c ****   if (Size == 0x00U) {                 /* Test variable Size on zero */
 990              		.loc 1 503 0
 991 001a BB1D     		add	r3, r7, #6
 992 001c 1B88     		ldrh	r3, [r3]
 993 001e 002B     		cmp	r3, #0
 994 0020 01D1     		bne	.L40
 504:../Generated_Code/DrvI2c1.c ****     return ERR_OK;                     /* If zero then OK */
 995              		.loc 1 504 0
 996 0022 0023     		mov	r3, #0
 997 0024 91E0     		b	.L41
 998              	.L40:
 505:../Generated_Code/DrvI2c1.c ****   }
 506:../Generated_Code/DrvI2c1.c ****   if (SendStop == LDD_I2C_NO_SEND_STOP) { /* Test variable SendStop on supported value */
 999              		.loc 1 506 0
 1000 0026 7B1D     		add	r3, r7, #5
 1001 0028 1B78     		ldrb	r3, [r3]
 1002 002a 002B     		cmp	r3, #0
 1003 002c 01D1     		bne	.L42
 507:../Generated_Code/DrvI2c1.c ****     return ERR_PARAM_MODE;             /* If not supported value then error */
 1004              		.loc 1 507 0
 1005 002e 8123     		mov	r3, #129
 1006 0030 8BE0     		b	.L41
 1007              	.L42:
 508:../Generated_Code/DrvI2c1.c ****   }
 509:../Generated_Code/DrvI2c1.c ****   if ((DeviceDataPrv->SerFlag & GENERAL_CALL) != 0x00U) { /* Is the general call flag set (SelectSl
 1008              		.loc 1 509 0
 1009 0032 7B69     		ldr	r3, [r7, #20]
 1010 0034 1B78     		ldrb	r3, [r3]
 1011 0036 1A1C     		mov	r2, r3
 1012 0038 0823     		mov	r3, #8
 1013 003a 1340     		and	r3, r2
 1014 003c 01D0     		beq	.L43
 510:../Generated_Code/DrvI2c1.c ****     return ERR_NOTAVAIL;               /* It is not possible to receive data - Call SelectSlaveDevi
 1015              		.loc 1 510 0
 1016 003e 0923     		mov	r3, #9
 1017 0040 83E0     		b	.L41
 1018              	.L43:
 511:../Generated_Code/DrvI2c1.c ****   }
 512:../Generated_Code/DrvI2c1.c ****   if (DeviceDataPrv->SendStop == LDD_I2C_SEND_STOP) {
 1019              		.loc 1 512 0
 1020 0042 7B69     		ldr	r3, [r7, #20]
 1021 0044 5B78     		ldrb	r3, [r3, #1]
 1022 0046 012B     		cmp	r3, #1
 1023 0048 12D1     		bne	.L44
 513:../Generated_Code/DrvI2c1.c ****     if ((I2C_PDD_GetBusStatus(I2C1_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 1024              		.loc 1 513 0
 1025 004a 424B     		ldr	r3, .L52
 1026 004c DB78     		ldrb	r3, [r3, #3]
 1027 004e DBB2     		uxtb	r3, r3
 1028 0050 1A1C     		mov	r2, r3
 1029 0052 2023     		mov	r3, #32
 1030 0054 1340     		and	r3, r2
 1031 0056 09D1     		bne	.L45
 514:../Generated_Code/DrvI2c1.c ****       ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 1032              		.loc 1 514 0
 1033 0058 7B69     		ldr	r3, [r7, #20]
 1034 005a 1B78     		ldrb	r3, [r3]
 1035 005c 1A1C     		mov	r2, r3
 1036 005e 0123     		mov	r3, #1
 1037 0060 1340     		and	r3, r2
 513:../Generated_Code/DrvI2c1.c ****     if ((I2C_PDD_GetBusStatus(I2C1_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 1038              		.loc 1 513 0
 1039 0062 03D1     		bne	.L45
 515:../Generated_Code/DrvI2c1.c ****       (DeviceDataPrv->InpLenM != 0x00U)) {
 1040              		.loc 1 515 0
 1041 0064 7B69     		ldr	r3, [r7, #20]
 1042 0066 9B88     		ldrh	r3, [r3, #4]
 514:../Generated_Code/DrvI2c1.c ****       ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 1043              		.loc 1 514 0
 1044 0068 002B     		cmp	r3, #0
 1045 006a 0DD0     		beq	.L46
 1046              	.L45:
 516:../Generated_Code/DrvI2c1.c ****       return ERR_BUSY;                 /* If yes then error */
 1047              		.loc 1 516 0
 1048 006c 0823     		mov	r3, #8
 1049 006e 6CE0     		b	.L41
 1050              	.L44:
 517:../Generated_Code/DrvI2c1.c ****     }
 518:../Generated_Code/DrvI2c1.c ****   } else {
 519:../Generated_Code/DrvI2c1.c ****     if(((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 1051              		.loc 1 519 0
 1052 0070 7B69     		ldr	r3, [r7, #20]
 1053 0072 1B78     		ldrb	r3, [r3]
 1054 0074 1A1C     		mov	r2, r3
 1055 0076 0123     		mov	r3, #1
 1056 0078 1340     		and	r3, r2
 1057 007a 03D1     		bne	.L47
 520:../Generated_Code/DrvI2c1.c ****       (DeviceDataPrv->InpLenM != 0x00U)) {
 1058              		.loc 1 520 0
 1059 007c 7B69     		ldr	r3, [r7, #20]
 1060 007e 9B88     		ldrh	r3, [r3, #4]
 519:../Generated_Code/DrvI2c1.c ****     if(((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 1061              		.loc 1 519 0
 1062 0080 002B     		cmp	r3, #0
 1063 0082 01D0     		beq	.L46
 1064              	.L47:
 521:../Generated_Code/DrvI2c1.c ****       return ERR_BUSY;               /* If yes then error */
 1065              		.loc 1 521 0
 1066 0084 0823     		mov	r3, #8
 1067 0086 60E0     		b	.L41
 1068              	.L46:
 522:../Generated_Code/DrvI2c1.c ****     }
 523:../Generated_Code/DrvI2c1.c ****   }
 524:../Generated_Code/DrvI2c1.c ****   /* {MQXLite RTOS Adapter} Critical section begin (RTOS function call is defined by MQXLite RTOS A
 525:../Generated_Code/DrvI2c1.c ****   _int_disable();
 1069              		.loc 1 525 0
 1070 0088 FFF7FEFF 		bl	_int_disable
 526:../Generated_Code/DrvI2c1.c ****   DeviceDataPrv->SerFlag |= MASTER_IN_PROGRES; /* Set flag "busy" */
 1071              		.loc 1 526 0
 1072 008c 7B69     		ldr	r3, [r7, #20]
 1073 008e 1B78     		ldrb	r3, [r3]
 1074 0090 0122     		mov	r2, #1
 1075 0092 1343     		orr	r3, r2
 1076 0094 DAB2     		uxtb	r2, r3
 1077 0096 7B69     		ldr	r3, [r7, #20]
 1078 0098 1A70     		strb	r2, [r3]
 527:../Generated_Code/DrvI2c1.c ****   DeviceDataPrv->InpPtrM = (uint8_t *)BufferPtr; /* Save pointer to data for reception */
 1079              		.loc 1 527 0
 1080 009a 7B69     		ldr	r3, [r7, #20]
 1081 009c BA68     		ldr	r2, [r7, #8]
 1082 009e 9A60     		str	r2, [r3, #8]
 528:../Generated_Code/DrvI2c1.c ****   DeviceDataPrv->InpLenM = Size;       /* Set the counter of input bufer's content */
 1083              		.loc 1 528 0
 1084 00a0 7B69     		ldr	r3, [r7, #20]
 1085 00a2 BA1D     		add	r2, r7, #6
 1086 00a4 1288     		ldrh	r2, [r2]
 1087 00a6 9A80     		strh	r2, [r3, #4]
 529:../Generated_Code/DrvI2c1.c ****   DeviceDataPrv->SendStop = SendStop;  /* Set generating stop condition */
 1088              		.loc 1 529 0
 1089 00a8 7B69     		ldr	r3, [r7, #20]
 1090 00aa 7A1D     		add	r2, r7, #5
 1091 00ac 1278     		ldrb	r2, [r2]
 1092 00ae 5A70     		strb	r2, [r3, #1]
 530:../Generated_Code/DrvI2c1.c ****   I2C_PDD_SetTransmitMode(I2C1_BASE_PTR, I2C_PDD_TX_DIRECTION); /* Set TX mode */
 1093              		.loc 1 530 0
 1094 00b0 284B     		ldr	r3, .L52
 1095 00b2 284A     		ldr	r2, .L52
 1096 00b4 9278     		ldrb	r2, [r2, #2]
 1097 00b6 D2B2     		uxtb	r2, r2
 1098 00b8 D2B2     		uxtb	r2, r2
 1099 00ba 1021     		mov	r1, #16
 1100 00bc 0A43     		orr	r2, r1
 1101 00be D2B2     		uxtb	r2, r2
 1102 00c0 D2B2     		uxtb	r2, r2
 1103 00c2 9A70     		strb	r2, [r3, #2]
 531:../Generated_Code/DrvI2c1.c ****   if (I2C_PDD_GetMasterMode(I2C1_BASE_PTR) == I2C_PDD_MASTER_MODE) { /* Is device in master mode? *
 1104              		.loc 1 531 0
 1105 00c4 234B     		ldr	r3, .L52
 1106 00c6 9B78     		ldrb	r3, [r3, #2]
 1107 00c8 DBB2     		uxtb	r3, r3
 1108 00ca 1A1C     		mov	r2, r3
 1109 00cc 2023     		mov	r3, #32
 1110 00ce 1340     		and	r3, r2
 1111 00d0 08D0     		beq	.L48
 532:../Generated_Code/DrvI2c1.c ****     I2C_PDD_RepeatStart(I2C1_BASE_PTR); /* If yes then repeat start cycle generated */
 1112              		.loc 1 532 0
 1113 00d2 204B     		ldr	r3, .L52
 1114 00d4 1F4A     		ldr	r2, .L52
 1115 00d6 9278     		ldrb	r2, [r2, #2]
 1116 00d8 D2B2     		uxtb	r2, r2
 1117 00da 0421     		mov	r1, #4
 1118 00dc 0A43     		orr	r2, r1
 1119 00de D2B2     		uxtb	r2, r2
 1120 00e0 9A70     		strb	r2, [r3, #2]
 1121 00e2 09E0     		b	.L49
 1122              	.L48:
 533:../Generated_Code/DrvI2c1.c ****   } else {
 534:../Generated_Code/DrvI2c1.c ****     I2C_PDD_SetMasterMode(I2C1_BASE_PTR, I2C_PDD_MASTER_MODE); /* If no then start signal generated
 1123              		.loc 1 534 0
 1124 00e4 1B4B     		ldr	r3, .L52
 1125 00e6 1B4A     		ldr	r2, .L52
 1126 00e8 9278     		ldrb	r2, [r2, #2]
 1127 00ea D2B2     		uxtb	r2, r2
 1128 00ec D2B2     		uxtb	r2, r2
 1129 00ee 2021     		mov	r1, #32
 1130 00f0 0A43     		orr	r2, r1
 1131 00f2 D2B2     		uxtb	r2, r2
 1132 00f4 D2B2     		uxtb	r2, r2
 1133 00f6 9A70     		strb	r2, [r3, #2]
 1134              	.L49:
 535:../Generated_Code/DrvI2c1.c ****   }
 536:../Generated_Code/DrvI2c1.c ****   if ((DeviceDataPrv->SerFlag & ADDR_7) != 0x00U) { /* Is 7-bit addressing set ? */
 1135              		.loc 1 536 0
 1136 00f8 7B69     		ldr	r3, [r7, #20]
 1137 00fa 1B78     		ldrb	r3, [r3]
 1138 00fc 1A1C     		mov	r2, r3
 1139 00fe 2023     		mov	r3, #32
 1140 0100 1340     		and	r3, r2
 1141 0102 0ED0     		beq	.L50
 537:../Generated_Code/DrvI2c1.c ****     DeviceDataPrv->SerFlag |= (ADDR_COMPLETE|REP_ADDR_COMPLETE); /* Only one byte of address will b
 1142              		.loc 1 537 0
 1143 0104 7B69     		ldr	r3, [r7, #20]
 1144 0106 1B78     		ldrb	r3, [r3]
 1145 0108 0622     		mov	r2, #6
 1146 010a 1343     		orr	r3, r2
 1147 010c DAB2     		uxtb	r2, r3
 1148 010e 7B69     		ldr	r3, [r7, #20]
 1149 0110 1A70     		strb	r2, [r3]
 538:../Generated_Code/DrvI2c1.c ****     I2C_PDD_WriteDataReg(I2C1_BASE_PTR, (uint8_t)(DeviceDataPrv->SlaveAddr | 0x01U)); /* Send slave
 1150              		.loc 1 538 0
 1151 0112 104B     		ldr	r3, .L52
 1152 0114 7A69     		ldr	r2, [r7, #20]
 1153 0116 9278     		ldrb	r2, [r2, #2]
 1154 0118 0121     		mov	r1, #1
 1155 011a 0A43     		orr	r2, r1
 1156 011c D2B2     		uxtb	r2, r2
 1157 011e 1A71     		strb	r2, [r3, #4]
 1158 0120 10E0     		b	.L51
 1159              	.L50:
 539:../Generated_Code/DrvI2c1.c ****   } else {
 540:../Generated_Code/DrvI2c1.c ****     if ((DeviceDataPrv->SerFlag & ADDR_10) != 0x00U) { /* Is 10-bit addressing set ? */
 1160              		.loc 1 540 0
 1161 0122 7B69     		ldr	r3, [r7, #20]
 1162 0124 1B78     		ldrb	r3, [r3]
 1163 0126 1A1C     		mov	r2, r3
 1164 0128 1023     		mov	r3, #16
 1165 012a 1340     		and	r3, r2
 1166 012c 0AD0     		beq	.L51
 541:../Generated_Code/DrvI2c1.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(ADDR_COMPLETE | REP_ADDR_COMPLETE); /* Second byte of ad
 1167              		.loc 1 541 0
 1168 012e 7B69     		ldr	r3, [r7, #20]
 1169 0130 1B78     		ldrb	r3, [r3]
 1170 0132 0622     		mov	r2, #6
 1171 0134 9343     		bic	r3, r2
 1172 0136 DAB2     		uxtb	r2, r3
 1173 0138 7B69     		ldr	r3, [r7, #20]
 1174 013a 1A70     		strb	r2, [r3]
 542:../Generated_Code/DrvI2c1.c ****       I2C_PDD_WriteDataReg(I2C1_BASE_PTR, DeviceDataPrv->SlaveAddrHigh); /* Send slave address - hi
 1175              		.loc 1 542 0
 1176 013c 054B     		ldr	r3, .L52
 1177 013e 7A69     		ldr	r2, [r7, #20]
 1178 0140 D278     		ldrb	r2, [r2, #3]
 1179 0142 1A71     		strb	r2, [r3, #4]
 1180              	.L51:
 543:../Generated_Code/DrvI2c1.c ****     }
 544:../Generated_Code/DrvI2c1.c ****   }
 545:../Generated_Code/DrvI2c1.c ****   /* {MQXLite RTOS Adapter} Critical section ends (RTOS function call is defined by MQXLite RTOS Ad
 546:../Generated_Code/DrvI2c1.c ****   _int_enable();
 1181              		.loc 1 546 0
 1182 0144 FFF7FEFF 		bl	_int_enable
 547:../Generated_Code/DrvI2c1.c ****   return ERR_OK;                       /* OK */
 1183              		.loc 1 547 0
 1184 0148 0023     		mov	r3, #0
 1185              	.L41:
 548:../Generated_Code/DrvI2c1.c **** }
 1186              		.loc 1 548 0
 1187 014a 181C     		mov	r0, r3
 1188 014c BD46     		mov	sp, r7
 1189 014e 06B0     		add	sp, sp, #24
 1190              		@ sp needed for prologue
 1191 0150 80BD     		pop	{r7, pc}
 1192              	.L53:
 1193 0152 C046     		.align	2
 1194              	.L52:
 1195 0154 00700640 		.word	1074163712
 1196              		.cfi_endproc
 1197              	.LFE4:
 1199              		.section	.text.DrvI2c1_SelectSlaveDevice,"ax",%progbits
 1200              		.align	2
 1201              		.global	DrvI2c1_SelectSlaveDevice
 1202              		.code	16
 1203              		.thumb_func
 1205              	DrvI2c1_SelectSlaveDevice:
 1206              	.LFB5:
 549:../Generated_Code/DrvI2c1.c **** 
 550:../Generated_Code/DrvI2c1.c **** /*
 551:../Generated_Code/DrvI2c1.c **** ** ===================================================================
 552:../Generated_Code/DrvI2c1.c **** **     Method      :  DrvI2c1_SelectSlaveDevice (component I2C_LDD)
 553:../Generated_Code/DrvI2c1.c **** **
 554:../Generated_Code/DrvI2c1.c **** **     Description :
 555:../Generated_Code/DrvI2c1.c **** **         This method selects a new slave for communication by its
 556:../Generated_Code/DrvI2c1.c **** **         7-bit slave, 10-bit address or general call value. Any send
 557:../Generated_Code/DrvI2c1.c **** **         or receive method directs to or from selected device, until
 558:../Generated_Code/DrvI2c1.c **** **         a new slave device is selected by this method. This method
 559:../Generated_Code/DrvI2c1.c **** **         is available for the MASTER mode.
 560:../Generated_Code/DrvI2c1.c **** **     Parameters  :
 561:../Generated_Code/DrvI2c1.c **** **         NAME            - DESCRIPTION
 562:../Generated_Code/DrvI2c1.c **** **       * DeviceDataPtr   - Device data structure
 563:../Generated_Code/DrvI2c1.c **** **                           pointer returned by <Init> method.
 564:../Generated_Code/DrvI2c1.c **** **         AddrType        - Specify type of slave address
 565:../Generated_Code/DrvI2c1.c **** **                           (7bit, 10bit or general call address), e.g.
 566:../Generated_Code/DrvI2c1.c **** **                           LDD_I2C_ADDRTYPE_7BITS.
 567:../Generated_Code/DrvI2c1.c **** **         Addr            - 7bit or 10bit slave address value.
 568:../Generated_Code/DrvI2c1.c **** **     Returns     :
 569:../Generated_Code/DrvI2c1.c **** **         ---             - Error code, possible codes:
 570:../Generated_Code/DrvI2c1.c **** **                           ERR_OK - OK
 571:../Generated_Code/DrvI2c1.c **** **                           ERR_BUSY - The device is busy, wait until
 572:../Generated_Code/DrvI2c1.c **** **                           the current operation is finished.
 573:../Generated_Code/DrvI2c1.c **** **                           ERR_DISABLED -  The device is disabled.
 574:../Generated_Code/DrvI2c1.c **** **                           ERR_SPEED - This device does not work in
 575:../Generated_Code/DrvI2c1.c **** **                           the active clock configuration
 576:../Generated_Code/DrvI2c1.c **** **                           ERR_PARAM_ADDRESS_TYPE -  Invalid address
 577:../Generated_Code/DrvI2c1.c **** **                           type.
 578:../Generated_Code/DrvI2c1.c **** **                           ERR_PARAM_ADDRESS -  Invalid address value.
 579:../Generated_Code/DrvI2c1.c **** ** ===================================================================
 580:../Generated_Code/DrvI2c1.c **** */
 581:../Generated_Code/DrvI2c1.c **** LDD_TError DrvI2c1_SelectSlaveDevice(LDD_TDeviceData *DeviceDataPtr, LDD_I2C_TAddrType AddrType, LD
 582:../Generated_Code/DrvI2c1.c **** {
 1207              		.loc 1 582 0
 1208              		.cfi_startproc
 1209 0000 80B5     		push	{r7, lr}
 1210              	.LCFI15:
 1211              		.cfi_def_cfa_offset 8
 1212              		.cfi_offset 7, -8
 1213              		.cfi_offset 14, -4
 1214 0002 84B0     		sub	sp, sp, #16
 1215              	.LCFI16:
 1216              		.cfi_def_cfa_offset 24
 1217 0004 00AF     		add	r7, sp, #0
 1218              	.LCFI17:
 1219              		.cfi_def_cfa_register 7
 1220 0006 7860     		str	r0, [r7, #4]
 1221 0008 FB1C     		add	r3, r7, #3
 1222 000a 1970     		strb	r1, [r3]
 1223 000c 3B1C     		mov	r3, r7
 1224 000e 1A80     		strh	r2, [r3]
 583:../Generated_Code/DrvI2c1.c ****   DrvI2c1_TDeviceData *DeviceDataPrv = (DrvI2c1_TDeviceData *)DeviceDataPtr;
 1225              		.loc 1 583 0
 1226 0010 7B68     		ldr	r3, [r7, #4]
 1227 0012 FB60     		str	r3, [r7, #12]
 584:../Generated_Code/DrvI2c1.c **** 
 585:../Generated_Code/DrvI2c1.c ****   if ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) { /* Is the device in the active state
 1228              		.loc 1 585 0
 1229 0014 FB68     		ldr	r3, [r7, #12]
 1230 0016 1B78     		ldrb	r3, [r3]
 1231 0018 1A1C     		mov	r2, r3
 1232 001a 0123     		mov	r3, #1
 1233 001c 1340     		and	r3, r2
 1234 001e 01D0     		beq	.L55
 586:../Generated_Code/DrvI2c1.c ****     return ERR_BUSY;                   /* If yes then error */
 1235              		.loc 1 586 0
 1236 0020 0823     		mov	r3, #8
 1237 0022 66E0     		b	.L56
 1238              	.L55:
 587:../Generated_Code/DrvI2c1.c ****   }
 588:../Generated_Code/DrvI2c1.c ****   switch (AddrType) {
 1239              		.loc 1 588 0
 1240 0024 FB1C     		add	r3, r7, #3
 1241 0026 1B78     		ldrb	r3, [r3]
 1242 0028 012B     		cmp	r3, #1
 1243 002a 1FD0     		beq	.L59
 1244 002c 022B     		cmp	r3, #2
 1245 002e 4ED0     		beq	.L60
 1246 0030 002B     		cmp	r3, #0
 1247 0032 5BD1     		bne	.L64
 1248              	.L58:
 589:../Generated_Code/DrvI2c1.c ****     case LDD_I2C_ADDRTYPE_7BITS:
 590:../Generated_Code/DrvI2c1.c ****       if (Addr > 0x7FU) {              /* Test address value */
 1249              		.loc 1 590 0
 1250 0034 3B1C     		mov	r3, r7
 1251 0036 1B88     		ldrh	r3, [r3]
 1252 0038 7F2B     		cmp	r3, #127
 1253 003a 01D9     		bls	.L61
 591:../Generated_Code/DrvI2c1.c ****         return ERR_PARAM_ADDRESS;      /* If value of address is invalid, return error */
 1254              		.loc 1 591 0
 1255 003c 8923     		mov	r3, #137
 1256 003e 58E0     		b	.L56
 1257              	.L61:
 592:../Generated_Code/DrvI2c1.c ****       }
 593:../Generated_Code/DrvI2c1.c ****       DeviceDataPrv->SlaveAddr = (uint8_t)((uint8_t)Addr << 0x01U); /* Set slave address */
 1258              		.loc 1 593 0
 1259 0040 3B1C     		mov	r3, r7
 1260 0042 1B88     		ldrh	r3, [r3]
 1261 0044 DBB2     		uxtb	r3, r3
 1262 0046 5B00     		lsl	r3, r3, #1
 1263 0048 DAB2     		uxtb	r2, r3
 1264 004a FB68     		ldr	r3, [r7, #12]
 1265 004c 9A70     		strb	r2, [r3, #2]
 594:../Generated_Code/DrvI2c1.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(GENERAL_CALL | ADDR_10); /* Clear the general call flag 
 1266              		.loc 1 594 0
 1267 004e FB68     		ldr	r3, [r7, #12]
 1268 0050 1B78     		ldrb	r3, [r3]
 1269 0052 1822     		mov	r2, #24
 1270 0054 9343     		bic	r3, r2
 1271 0056 DAB2     		uxtb	r2, r3
 1272 0058 FB68     		ldr	r3, [r7, #12]
 1273 005a 1A70     		strb	r2, [r3]
 595:../Generated_Code/DrvI2c1.c ****       DeviceDataPrv->SerFlag |= ADDR_7; /* Set 7-bit address mode flag */
 1274              		.loc 1 595 0
 1275 005c FB68     		ldr	r3, [r7, #12]
 1276 005e 1B78     		ldrb	r3, [r3]
 1277 0060 2022     		mov	r2, #32
 1278 0062 1343     		orr	r3, r2
 1279 0064 DAB2     		uxtb	r2, r3
 1280 0066 FB68     		ldr	r3, [r7, #12]
 1281 0068 1A70     		strb	r2, [r3]
 596:../Generated_Code/DrvI2c1.c ****     break;
 1282              		.loc 1 596 0
 1283 006a 41E0     		b	.L62
 1284              	.L59:
 597:../Generated_Code/DrvI2c1.c ****     case LDD_I2C_ADDRTYPE_10BITS:
 598:../Generated_Code/DrvI2c1.c ****       if (Addr > 0x03FFU) {            /* Test address value */
 1285              		.loc 1 598 0
 1286 006c 3B1C     		mov	r3, r7
 1287 006e 1A88     		ldrh	r2, [r3]
 1288 0070 224B     		ldr	r3, .L65
 1289 0072 9A42     		cmp	r2, r3
 1290 0074 01D9     		bls	.L63
 599:../Generated_Code/DrvI2c1.c ****         return ERR_PARAM_ADDRESS;      /* If value of address is invalid, return error */
 1291              		.loc 1 599 0
 1292 0076 8923     		mov	r3, #137
 1293 0078 3BE0     		b	.L56
 1294              	.L63:
 600:../Generated_Code/DrvI2c1.c ****       }
 601:../Generated_Code/DrvI2c1.c ****       DeviceDataPrv->SlaveAddr = (uint8_t)Addr; /* Set slave address - low byte */
 1295              		.loc 1 601 0
 1296 007a 3B1C     		mov	r3, r7
 1297 007c 1B88     		ldrh	r3, [r3]
 1298 007e DAB2     		uxtb	r2, r3
 1299 0080 FB68     		ldr	r3, [r7, #12]
 1300 0082 9A70     		strb	r2, [r3, #2]
 602:../Generated_Code/DrvI2c1.c ****       DeviceDataPrv->SlaveAddrHigh = (uint8_t)((uint16_t)Addr >> 0x07U); /* Set slave address - hig
 1301              		.loc 1 602 0
 1302 0084 3B1C     		mov	r3, r7
 1303 0086 1B88     		ldrh	r3, [r3]
 1304 0088 DB09     		lsr	r3, r3, #7
 1305 008a 9BB2     		uxth	r3, r3
 1306 008c DAB2     		uxtb	r2, r3
 1307 008e FB68     		ldr	r3, [r7, #12]
 1308 0090 DA70     		strb	r2, [r3, #3]
 603:../Generated_Code/DrvI2c1.c ****       DeviceDataPrv->SlaveAddrHigh &= 0x06U; /* Format address to 11110xx0 */
 1309              		.loc 1 603 0
 1310 0092 FB68     		ldr	r3, [r7, #12]
 1311 0094 DA78     		ldrb	r2, [r3, #3]
 1312 0096 0623     		mov	r3, #6
 1313 0098 1340     		and	r3, r2
 1314 009a DAB2     		uxtb	r2, r3
 1315 009c FB68     		ldr	r3, [r7, #12]
 1316 009e DA70     		strb	r2, [r3, #3]
 604:../Generated_Code/DrvI2c1.c ****       DeviceDataPrv->SlaveAddrHigh |= 0xF0U;
 1317              		.loc 1 604 0
 1318 00a0 FB68     		ldr	r3, [r7, #12]
 1319 00a2 DB78     		ldrb	r3, [r3, #3]
 1320 00a4 1022     		mov	r2, #16
 1321 00a6 5242     		neg	r2, r2
 1322 00a8 1343     		orr	r3, r2
 1323 00aa DAB2     		uxtb	r2, r3
 1324 00ac FB68     		ldr	r3, [r7, #12]
 1325 00ae DA70     		strb	r2, [r3, #3]
 605:../Generated_Code/DrvI2c1.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(GENERAL_CALL | ADDR_7); /* Clear the general call flag a
 1326              		.loc 1 605 0
 1327 00b0 FB68     		ldr	r3, [r7, #12]
 1328 00b2 1B78     		ldrb	r3, [r3]
 1329 00b4 2822     		mov	r2, #40
 1330 00b6 9343     		bic	r3, r2
 1331 00b8 DAB2     		uxtb	r2, r3
 1332 00ba FB68     		ldr	r3, [r7, #12]
 1333 00bc 1A70     		strb	r2, [r3]
 606:../Generated_Code/DrvI2c1.c ****       DeviceDataPrv->SerFlag |= ADDR_10; /* Set 10-bit address mode flag */
 1334              		.loc 1 606 0
 1335 00be FB68     		ldr	r3, [r7, #12]
 1336 00c0 1B78     		ldrb	r3, [r3]
 1337 00c2 1022     		mov	r2, #16
 1338 00c4 1343     		orr	r3, r2
 1339 00c6 DAB2     		uxtb	r2, r3
 1340 00c8 FB68     		ldr	r3, [r7, #12]
 1341 00ca 1A70     		strb	r2, [r3]
 607:../Generated_Code/DrvI2c1.c ****     break;
 1342              		.loc 1 607 0
 1343 00cc 10E0     		b	.L62
 1344              	.L60:
 608:../Generated_Code/DrvI2c1.c ****     case LDD_I2C_ADDRTYPE_GENERAL_CALL:
 609:../Generated_Code/DrvI2c1.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(ADDR_7 | ADDR_10); /* Clear the 7-bit address flag and 1
 1345              		.loc 1 609 0
 1346 00ce FB68     		ldr	r3, [r7, #12]
 1347 00d0 1B78     		ldrb	r3, [r3]
 1348 00d2 3022     		mov	r2, #48
 1349 00d4 9343     		bic	r3, r2
 1350 00d6 DAB2     		uxtb	r2, r3
 1351 00d8 FB68     		ldr	r3, [r7, #12]
 1352 00da 1A70     		strb	r2, [r3]
 610:../Generated_Code/DrvI2c1.c ****       DeviceDataPrv->SerFlag |= GENERAL_CALL; /* Set general call mode flag */
 1353              		.loc 1 610 0
 1354 00dc FB68     		ldr	r3, [r7, #12]
 1355 00de 1B78     		ldrb	r3, [r3]
 1356 00e0 0822     		mov	r2, #8
 1357 00e2 1343     		orr	r3, r2
 1358 00e4 DAB2     		uxtb	r2, r3
 1359 00e6 FB68     		ldr	r3, [r7, #12]
 1360 00e8 1A70     		strb	r2, [r3]
 611:../Generated_Code/DrvI2c1.c ****     break;
 1361              		.loc 1 611 0
 1362 00ea 01E0     		b	.L62
 1363              	.L64:
 612:../Generated_Code/DrvI2c1.c ****     default:
 613:../Generated_Code/DrvI2c1.c ****       return ERR_PARAM_ADDRESS_TYPE;   /* If value of address type is invalid, return error */
 1364              		.loc 1 613 0
 1365 00ec 8D23     		mov	r3, #141
 1366 00ee 00E0     		b	.L56
 1367              	.L62:
 614:../Generated_Code/DrvI2c1.c ****   }
 615:../Generated_Code/DrvI2c1.c ****   return ERR_OK;                       /* OK */
 1368              		.loc 1 615 0
 1369 00f0 0023     		mov	r3, #0
 1370              	.L56:
 616:../Generated_Code/DrvI2c1.c **** }
 1371              		.loc 1 616 0
 1372 00f2 181C     		mov	r0, r3
 1373 00f4 BD46     		mov	sp, r7
 1374 00f6 04B0     		add	sp, sp, #16
 1375              		@ sp needed for prologue
 1376 00f8 80BD     		pop	{r7, pc}
 1377              	.L66:
 1378 00fa C046     		.align	2
 1379              	.L65:
 1380 00fc FF030000 		.word	1023
 1381              		.cfi_endproc
 1382              	.LFE5:
 1384              		.section	.text.DrvI2c1_CheckBus,"ax",%progbits
 1385              		.align	2
 1386              		.global	DrvI2c1_CheckBus
 1387              		.code	16
 1388              		.thumb_func
 1390              	DrvI2c1_CheckBus:
 1391              	.LFB6:
 617:../Generated_Code/DrvI2c1.c **** 
 618:../Generated_Code/DrvI2c1.c **** /*
 619:../Generated_Code/DrvI2c1.c **** ** ===================================================================
 620:../Generated_Code/DrvI2c1.c **** **     Method      :  DrvI2c1_CheckBus (component I2C_LDD)
 621:../Generated_Code/DrvI2c1.c **** **
 622:../Generated_Code/DrvI2c1.c **** **     Description :
 623:../Generated_Code/DrvI2c1.c **** **         This method returns the status of the bus. If the START
 624:../Generated_Code/DrvI2c1.c **** **         condition has been detected, the method returns LDD_I2C_BUSY.
 625:../Generated_Code/DrvI2c1.c **** **         If the STOP condition has been detected, the method returns
 626:../Generated_Code/DrvI2c1.c **** **         LDD_I2C_IDLE.
 627:../Generated_Code/DrvI2c1.c **** **     Parameters  :
 628:../Generated_Code/DrvI2c1.c **** **         NAME            - DESCRIPTION
 629:../Generated_Code/DrvI2c1.c **** **       * DeviceDataPtr   - Device data structure
 630:../Generated_Code/DrvI2c1.c **** **                           pointer returned by <Init> method.
 631:../Generated_Code/DrvI2c1.c **** **       * BusStatePtr     - Pointer to a variable,
 632:../Generated_Code/DrvI2c1.c **** **                           where value of status is stored.
 633:../Generated_Code/DrvI2c1.c **** **     Returns     :
 634:../Generated_Code/DrvI2c1.c **** **         ---             - Error code, possible codes:
 635:../Generated_Code/DrvI2c1.c **** **                           ERR_OK - OK
 636:../Generated_Code/DrvI2c1.c **** **                           ERR_DISABLED -  Device is disabled
 637:../Generated_Code/DrvI2c1.c **** **                           ERR_SPEED - This device does not work in
 638:../Generated_Code/DrvI2c1.c **** **                           the active clock configuration
 639:../Generated_Code/DrvI2c1.c **** ** ===================================================================
 640:../Generated_Code/DrvI2c1.c **** */
 641:../Generated_Code/DrvI2c1.c **** LDD_TError DrvI2c1_CheckBus(LDD_TDeviceData *DeviceDataPtr, LDD_I2C_TBusState *BusStatePtr)
 642:../Generated_Code/DrvI2c1.c **** {
 1392              		.loc 1 642 0
 1393              		.cfi_startproc
 1394 0000 80B5     		push	{r7, lr}
 1395              	.LCFI18:
 1396              		.cfi_def_cfa_offset 8
 1397              		.cfi_offset 7, -8
 1398              		.cfi_offset 14, -4
 1399 0002 84B0     		sub	sp, sp, #16
 1400              	.LCFI19:
 1401              		.cfi_def_cfa_offset 24
 1402 0004 00AF     		add	r7, sp, #0
 1403              	.LCFI20:
 1404              		.cfi_def_cfa_register 7
 1405 0006 7860     		str	r0, [r7, #4]
 1406 0008 3960     		str	r1, [r7]
 643:../Generated_Code/DrvI2c1.c ****   DrvI2c1_TDeviceData *DeviceDataPrv = (DrvI2c1_TDeviceData *)DeviceDataPtr;
 1407              		.loc 1 643 0
 1408 000a 7B68     		ldr	r3, [r7, #4]
 1409 000c FB60     		str	r3, [r7, #12]
 644:../Generated_Code/DrvI2c1.c **** 
 645:../Generated_Code/DrvI2c1.c ****   (void)DeviceDataPrv;                 /* Suppress unused variable warning if needed */
 646:../Generated_Code/DrvI2c1.c ****   *BusStatePtr = (LDD_I2C_TBusState)((I2C_PDD_GetBusStatus(I2C1_BASE_PTR) == I2C_PDD_BUS_BUSY)?LDD_
 1410              		.loc 1 646 0
 1411 000e 084B     		ldr	r3, .L69
 1412 0010 DB78     		ldrb	r3, [r3, #3]
 1413 0012 DBB2     		uxtb	r3, r3
 1414 0014 1A1C     		mov	r2, r3
 1415 0016 2023     		mov	r3, #32
 1416 0018 1340     		and	r3, r2
 1417 001a 5A42     		neg	r2, r3
 1418 001c 5341     		adc	r3, r3, r2
 1419 001e DBB2     		uxtb	r3, r3
 1420 0020 DAB2     		uxtb	r2, r3
 1421 0022 3B68     		ldr	r3, [r7]
 1422 0024 1A70     		strb	r2, [r3]
 647:../Generated_Code/DrvI2c1.c ****   return ERR_OK;
 1423              		.loc 1 647 0
 1424 0026 0023     		mov	r3, #0
 648:../Generated_Code/DrvI2c1.c **** }
 1425              		.loc 1 648 0
 1426 0028 181C     		mov	r0, r3
 1427 002a BD46     		mov	sp, r7
 1428 002c 04B0     		add	sp, sp, #16
 1429              		@ sp needed for prologue
 1430 002e 80BD     		pop	{r7, pc}
 1431              	.L70:
 1432              		.align	2
 1433              	.L69:
 1434 0030 00700640 		.word	1074163712
 1435              		.cfi_endproc
 1436              	.LFE6:
 1438              		.text
 1439              	.Letext0:
 1440              		.file 2 "C:/Freescale/CW MCU v10.3/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 1441              		.file 3 "E:/CW103_Work_Space/Mqx_Lite_Test/Generated_Code/IO_Map.h"
 1442              		.file 4 "E:/CW103_Work_Space/Mqx_Lite_Test/Generated_Code/PE_LDD.h"
 1443              		.file 5 "E:/CW103_Work_Space/Mqx_Lite_Test/MQXLITE/psp/cortex_m/psptypes.h"
DEFINED SYMBOLS
                            *ABS*:00000000 DrvI2c1.c
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccfy4NWL.s:18     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccfy4NWL.s:21     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccfy4NWL.s:24     .text.DrvI2c1_Interrupt:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccfy4NWL.s:29     .text.DrvI2c1_Interrupt:00000000 DrvI2c1_Interrupt
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccfy4NWL.s:457    .text.DrvI2c1_Interrupt:000002ac $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccfy4NWL.s:462    .text.DrvI2c1_Init:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccfy4NWL.s:467    .text.DrvI2c1_Init:00000000 DrvI2c1_Init
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccfy4NWL.s:641    .text.DrvI2c1_Init:0000010c $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccfy4NWL.s:655    .text.DrvI2c1_Deinit:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccfy4NWL.s:660    .text.DrvI2c1_Deinit:00000000 DrvI2c1_Deinit
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccfy4NWL.s:712    .text.DrvI2c1_Deinit:00000040 $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccfy4NWL.s:720    .text.DrvI2c1_MasterSendBlock:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccfy4NWL.s:725    .text.DrvI2c1_MasterSendBlock:00000000 DrvI2c1_MasterSendBlock
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccfy4NWL.s:954    .text.DrvI2c1_MasterSendBlock:00000154 $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccfy4NWL.s:959    .text.DrvI2c1_MasterReceiveBlock:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccfy4NWL.s:964    .text.DrvI2c1_MasterReceiveBlock:00000000 DrvI2c1_MasterReceiveBlock
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccfy4NWL.s:1195   .text.DrvI2c1_MasterReceiveBlock:00000154 $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccfy4NWL.s:1200   .text.DrvI2c1_SelectSlaveDevice:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccfy4NWL.s:1205   .text.DrvI2c1_SelectSlaveDevice:00000000 DrvI2c1_SelectSlaveDevice
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccfy4NWL.s:1380   .text.DrvI2c1_SelectSlaveDevice:000000fc $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccfy4NWL.s:1385   .text.DrvI2c1_CheckBus:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccfy4NWL.s:1390   .text.DrvI2c1_CheckBus:00000000 DrvI2c1_CheckBus
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccfy4NWL.s:1434   .text.DrvI2c1_CheckBus:00000030 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
DrvI2c1_OnMasterBlockSent
DrvI2c1_OnMasterBlockReceived
DrvI2c1_OnError
_int_get_isr_data
_int_install_isr
PE_LDD_DeviceDataList
_int_disable
_int_enable
