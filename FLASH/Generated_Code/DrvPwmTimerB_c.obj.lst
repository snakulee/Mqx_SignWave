   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"DrvPwmTimerB.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.rodata.ChannelDevice,"a",%progbits
  18              		.align	2
  21              	ChannelDevice:
  22 0000 01       		.byte	1
  23 0001 000000   		.section	.rodata.ChannelMode,"a",%progbits
  24              		.align	2
  27              	ChannelMode:
  28 0000 00       		.space	1
  29 0001 000000   		.section	.bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  30              		.align	2
  33              	DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  34 0000 00000000 		.space	8
  34      00000000 
  35              		.section	.text.DrvPwmTimerB_Init,"ax",%progbits
  36              		.align	2
  37              		.global	DrvPwmTimerB_Init
  38              		.code	16
  39              		.thumb_func
  41              	DrvPwmTimerB_Init:
  42              	.LFB0:
  43              		.file 1 "../Generated_Code/DrvPwmTimerB.c"
   1:../Generated_Code/DrvPwmTimerB.c **** /** ###################################################################
   2:../Generated_Code/DrvPwmTimerB.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/DrvPwmTimerB.c **** **     Filename    : DrvPwmTimerB.c
   4:../Generated_Code/DrvPwmTimerB.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/DrvPwmTimerB.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/DrvPwmTimerB.c **** **     Component   : TimerUnit_LDD
   7:../Generated_Code/DrvPwmTimerB.c **** **     Version     : Component 01.139, Driver 01.09, CPU db: 3.00.000
   8:../Generated_Code/DrvPwmTimerB.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/DrvPwmTimerB.c **** **     Date/Time   : 2013-02-21, 14:56, # CodeGen: 9
  10:../Generated_Code/DrvPwmTimerB.c **** **     Abstract    :
  11:../Generated_Code/DrvPwmTimerB.c **** **          This TimerUnit component provides a low level API for unified hardware access across
  12:../Generated_Code/DrvPwmTimerB.c **** **          various timer devices using the Prescaler-Counter-Compare-Capture timer structure.
  13:../Generated_Code/DrvPwmTimerB.c **** **     Settings    :
  14:../Generated_Code/DrvPwmTimerB.c **** **          Component name                                 : DrvPwmTimerB
  15:../Generated_Code/DrvPwmTimerB.c **** **          Module name                                    : TPM0
  16:../Generated_Code/DrvPwmTimerB.c **** **          Counter                                        : TPM0_CNT
  17:../Generated_Code/DrvPwmTimerB.c **** **          Counter direction                              : Up
  18:../Generated_Code/DrvPwmTimerB.c **** **          Counter width                                  : 16 bits
  19:../Generated_Code/DrvPwmTimerB.c **** **          Value type                                     : Optimal
  20:../Generated_Code/DrvPwmTimerB.c **** **          Input clock source                             : Internal
  21:../Generated_Code/DrvPwmTimerB.c **** **            Counter frequency                            : 24 MHz
  22:../Generated_Code/DrvPwmTimerB.c **** **          Counter restart                                : On-overrun
  23:../Generated_Code/DrvPwmTimerB.c **** **            Overrun period                               : 2.730667 ms
  24:../Generated_Code/DrvPwmTimerB.c **** **            Interrupt                                    : Disabled
  25:../Generated_Code/DrvPwmTimerB.c **** **          Channel list                                   : 1
  26:../Generated_Code/DrvPwmTimerB.c **** **            Channel 0                                    : 
  27:../Generated_Code/DrvPwmTimerB.c **** **              Mode                                       : Compare
  28:../Generated_Code/DrvPwmTimerB.c **** **                Compare                                  : TPM0_C1V
  29:../Generated_Code/DrvPwmTimerB.c **** **                Offset                                   : 43690 timer-ticks
  30:../Generated_Code/DrvPwmTimerB.c **** **                Output on compare                        : Set
  31:../Generated_Code/DrvPwmTimerB.c **** **                  Output on overrun                      : Clear
  32:../Generated_Code/DrvPwmTimerB.c **** **                  Initial state                          : Low
  33:../Generated_Code/DrvPwmTimerB.c **** **                  Output pin                             : ADC0_SE5b/PTD1/SPI0_SCK/TPM0_CH1
  34:../Generated_Code/DrvPwmTimerB.c **** **                  Output pin signal                      : 
  35:../Generated_Code/DrvPwmTimerB.c **** **                Interrupt                                : Disabled
  36:../Generated_Code/DrvPwmTimerB.c **** **          Initialization                                 : 
  37:../Generated_Code/DrvPwmTimerB.c **** **            Enabled in init. code                        : yes
  38:../Generated_Code/DrvPwmTimerB.c **** **            Auto initialization                          : no
  39:../Generated_Code/DrvPwmTimerB.c **** **            Event mask                                   : 
  40:../Generated_Code/DrvPwmTimerB.c **** **              OnCounterRestart                           : Disabled
  41:../Generated_Code/DrvPwmTimerB.c **** **              OnChannel0                                 : Disabled
  42:../Generated_Code/DrvPwmTimerB.c **** **              OnChannel1                                 : Disabled
  43:../Generated_Code/DrvPwmTimerB.c **** **              OnChannel2                                 : Disabled
  44:../Generated_Code/DrvPwmTimerB.c **** **              OnChannel3                                 : Disabled
  45:../Generated_Code/DrvPwmTimerB.c **** **              OnChannel4                                 : Disabled
  46:../Generated_Code/DrvPwmTimerB.c **** **              OnChannel5                                 : Disabled
  47:../Generated_Code/DrvPwmTimerB.c **** **              OnChannel6                                 : Disabled
  48:../Generated_Code/DrvPwmTimerB.c **** **              OnChannel7                                 : Disabled
  49:../Generated_Code/DrvPwmTimerB.c **** **          CPU clock/configuration selection              : 
  50:../Generated_Code/DrvPwmTimerB.c **** **            Clock configuration 0                        : This component enabled
  51:../Generated_Code/DrvPwmTimerB.c **** **            Clock configuration 1                        : This component disabled
  52:../Generated_Code/DrvPwmTimerB.c **** **            Clock configuration 2                        : This component disabled
  53:../Generated_Code/DrvPwmTimerB.c **** **            Clock configuration 3                        : This component disabled
  54:../Generated_Code/DrvPwmTimerB.c **** **            Clock configuration 4                        : This component disabled
  55:../Generated_Code/DrvPwmTimerB.c **** **            Clock configuration 5                        : This component disabled
  56:../Generated_Code/DrvPwmTimerB.c **** **            Clock configuration 6                        : This component disabled
  57:../Generated_Code/DrvPwmTimerB.c **** **            Clock configuration 7                        : This component disabled
  58:../Generated_Code/DrvPwmTimerB.c **** **     Contents    :
  59:../Generated_Code/DrvPwmTimerB.c **** **         Init            - LDD_TDeviceData* DrvPwmTimerB_Init(LDD_TUserData *UserDataPtr);
  60:../Generated_Code/DrvPwmTimerB.c **** **         Deinit          - void DrvPwmTimerB_Deinit(LDD_TDeviceData *DeviceDataPtr);
  61:../Generated_Code/DrvPwmTimerB.c **** **         Enable          - LDD_TError DrvPwmTimerB_Enable(LDD_TDeviceData *DeviceDataPtr);
  62:../Generated_Code/DrvPwmTimerB.c **** **         Disable         - LDD_TError DrvPwmTimerB_Disable(LDD_TDeviceData *DeviceDataPtr);
  63:../Generated_Code/DrvPwmTimerB.c **** **         GetCounterValue - DrvPwmTimerB_TValueType DrvPwmTimerB_GetCounterValue(LDD_TDeviceData..
  64:../Generated_Code/DrvPwmTimerB.c **** **         SetOffsetTicks  - LDD_TError DrvPwmTimerB_SetOffsetTicks(LDD_TDeviceData *DeviceDataPtr,
  65:../Generated_Code/DrvPwmTimerB.c **** **         GetOffsetTicks  - LDD_TError DrvPwmTimerB_GetOffsetTicks(LDD_TDeviceData *DeviceDataPtr,
  66:../Generated_Code/DrvPwmTimerB.c **** **
  67:../Generated_Code/DrvPwmTimerB.c **** **     Copyright : 1997 - 2012 Freescale, Inc. All Rights Reserved.
  68:../Generated_Code/DrvPwmTimerB.c **** **     
  69:../Generated_Code/DrvPwmTimerB.c **** **     http      : www.freescale.com
  70:../Generated_Code/DrvPwmTimerB.c **** **     mail      : support@freescale.com
  71:../Generated_Code/DrvPwmTimerB.c **** ** ###################################################################*/
  72:../Generated_Code/DrvPwmTimerB.c **** 
  73:../Generated_Code/DrvPwmTimerB.c **** /* MODULE DrvPwmTimerB. */
  74:../Generated_Code/DrvPwmTimerB.c **** 
  75:../Generated_Code/DrvPwmTimerB.c **** #include "DrvPwmTimerB.h"
  76:../Generated_Code/DrvPwmTimerB.c **** /* MQX Lite include files */
  77:../Generated_Code/DrvPwmTimerB.c **** #include "mqxlite.h"
  78:../Generated_Code/DrvPwmTimerB.c **** #include "mqxlite_prv.h"
  79:../Generated_Code/DrvPwmTimerB.c **** #include "IO_Map.h"
  80:../Generated_Code/DrvPwmTimerB.c **** 
  81:../Generated_Code/DrvPwmTimerB.c **** /* List of channels used by component */
  82:../Generated_Code/DrvPwmTimerB.c **** static const uint8_t ChannelDevice[DrvPwmTimerB_NUMBER_OF_CHANNELS] = {0x01U};
  83:../Generated_Code/DrvPwmTimerB.c **** 
  84:../Generated_Code/DrvPwmTimerB.c **** /* Table of channels mode / 0 - compare mode, 1 - capture mode */
  85:../Generated_Code/DrvPwmTimerB.c **** static const uint8_t ChannelMode[DrvPwmTimerB_NUMBER_OF_CHANNELS] = {0x00U};
  86:../Generated_Code/DrvPwmTimerB.c **** 
  87:../Generated_Code/DrvPwmTimerB.c **** 
  88:../Generated_Code/DrvPwmTimerB.c **** typedef struct {
  89:../Generated_Code/DrvPwmTimerB.c ****   uint32_t Source;                     /* Current source clock */
  90:../Generated_Code/DrvPwmTimerB.c ****   LDD_TUserData *UserDataPtr;          /* RTOS device data structure */
  91:../Generated_Code/DrvPwmTimerB.c **** } DrvPwmTimerB_TDeviceData;
  92:../Generated_Code/DrvPwmTimerB.c **** 
  93:../Generated_Code/DrvPwmTimerB.c **** typedef DrvPwmTimerB_TDeviceData *DrvPwmTimerB_TDeviceDataPtr; /* Pointer to the device data struct
  94:../Generated_Code/DrvPwmTimerB.c **** 
  95:../Generated_Code/DrvPwmTimerB.c **** /* {MQXLite RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
  96:../Generated_Code/DrvPwmTimerB.c **** static DrvPwmTimerB_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
  97:../Generated_Code/DrvPwmTimerB.c **** 
  98:../Generated_Code/DrvPwmTimerB.c **** #define AVAILABLE_PIN_MASK (LDD_TPinMask)(DrvPwmTimerB_CHANNEL_0_PIN)
  99:../Generated_Code/DrvPwmTimerB.c **** #define LAST_CHANNEL 0x00U
 100:../Generated_Code/DrvPwmTimerB.c **** 
 101:../Generated_Code/DrvPwmTimerB.c **** /* Internal method prototypes */
 102:../Generated_Code/DrvPwmTimerB.c **** /*
 103:../Generated_Code/DrvPwmTimerB.c **** ** ===================================================================
 104:../Generated_Code/DrvPwmTimerB.c **** **     Method      :  DrvPwmTimerB_Init (component TimerUnit_LDD)
 105:../Generated_Code/DrvPwmTimerB.c **** **
 106:../Generated_Code/DrvPwmTimerB.c **** **     Description :
 107:../Generated_Code/DrvPwmTimerB.c **** **         Initializes the device. Allocates memory for the device data
 108:../Generated_Code/DrvPwmTimerB.c **** **         structure, allocates interrupt vectors and sets interrupt
 109:../Generated_Code/DrvPwmTimerB.c **** **         priority, sets pin routing, sets timing, etc. If the
 110:../Generated_Code/DrvPwmTimerB.c **** **         property <"Enable in init. code"> is set to "yes" value then
 111:../Generated_Code/DrvPwmTimerB.c **** **         the device is also enabled (see the description of the
 112:../Generated_Code/DrvPwmTimerB.c **** **         <Enable> method). In this case the <Enable> method is not
 113:../Generated_Code/DrvPwmTimerB.c **** **         necessary and needn't to be generated. This method can be
 114:../Generated_Code/DrvPwmTimerB.c **** **         called only once. Before the second call of Init the <Deinit>
 115:../Generated_Code/DrvPwmTimerB.c **** **         must be called first.
 116:../Generated_Code/DrvPwmTimerB.c **** **     Parameters  :
 117:../Generated_Code/DrvPwmTimerB.c **** **         NAME            - DESCRIPTION
 118:../Generated_Code/DrvPwmTimerB.c **** **       * UserDataPtr     - Pointer to the user or
 119:../Generated_Code/DrvPwmTimerB.c **** **                           RTOS specific data. This pointer will be
 120:../Generated_Code/DrvPwmTimerB.c **** **                           passed as an event or callback parameter.
 121:../Generated_Code/DrvPwmTimerB.c **** **     Returns     :
 122:../Generated_Code/DrvPwmTimerB.c **** **         ---             - Pointer to the dynamically allocated
 123:../Generated_Code/DrvPwmTimerB.c **** **                           private structure or NULL if there was an
 124:../Generated_Code/DrvPwmTimerB.c **** **                           error.
 125:../Generated_Code/DrvPwmTimerB.c **** ** ===================================================================
 126:../Generated_Code/DrvPwmTimerB.c **** */
 127:../Generated_Code/DrvPwmTimerB.c **** LDD_TDeviceData* DrvPwmTimerB_Init(LDD_TUserData *UserDataPtr)
 128:../Generated_Code/DrvPwmTimerB.c **** {
  44              		.loc 1 128 0
  45              		.cfi_startproc
  46 0000 80B5     		push	{r7, lr}
  47              	.LCFI0:
  48              		.cfi_def_cfa_offset 8
  49              		.cfi_offset 7, -8
  50              		.cfi_offset 14, -4
  51 0002 84B0     		sub	sp, sp, #16
  52              	.LCFI1:
  53              		.cfi_def_cfa_offset 24
  54 0004 00AF     		add	r7, sp, #0
  55              	.LCFI2:
  56              		.cfi_def_cfa_register 7
  57 0006 7860     		str	r0, [r7, #4]
 129:../Generated_Code/DrvPwmTimerB.c ****   /* Allocate device structure */
 130:../Generated_Code/DrvPwmTimerB.c ****   DrvPwmTimerB_TDeviceData *DeviceDataPrv;
 131:../Generated_Code/DrvPwmTimerB.c ****   /* {MQXLite RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer 
 132:../Generated_Code/DrvPwmTimerB.c ****   DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
  58              		.loc 1 132 0
  59 0008 224B     		ldr	r3, .L3
  60 000a FB60     		str	r3, [r7, #12]
 133:../Generated_Code/DrvPwmTimerB.c ****   DeviceDataPrv->UserDataPtr = UserDataPtr; /* Store the RTOS device structure */
  61              		.loc 1 133 0
  62 000c FB68     		ldr	r3, [r7, #12]
  63 000e 7A68     		ldr	r2, [r7, #4]
  64 0010 5A60     		str	r2, [r3, #4]
 134:../Generated_Code/DrvPwmTimerB.c ****   /* SIM_SCGC6: TPM0=1 */
 135:../Generated_Code/DrvPwmTimerB.c ****   SIM_SCGC6 |= SIM_SCGC6_TPM0_MASK;                                                   
  65              		.loc 1 135 0
  66 0012 214A     		ldr	r2, .L3+4
  67 0014 2049     		ldr	r1, .L3+4
  68 0016 214B     		ldr	r3, .L3+8
  69 0018 CB58     		ldr	r3, [r1, r3]
  70 001a 8021     		mov	r1, #128
  71 001c 4904     		lsl	r1, r1, #17
  72 001e 1943     		orr	r1, r3
  73 0020 1E4B     		ldr	r3, .L3+8
  74 0022 D150     		str	r1, [r2, r3]
 136:../Generated_Code/DrvPwmTimerB.c ****   /* TPM0_SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,
 137:../Generated_Code/DrvPwmTimerB.c ****   TPM0_SC = 0x00U;                     /* Clear status and control register */
  75              		.loc 1 137 0
  76 0024 1E4B     		ldr	r3, .L3+12
  77 0026 0022     		mov	r2, #0
  78 0028 1A60     		str	r2, [r3]
 138:../Generated_Code/DrvPwmTimerB.c ****   /* TPM0_CNT: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,COUN
 139:../Generated_Code/DrvPwmTimerB.c ****   TPM0_CNT = 0x00U;                    /* Reset counter register */
  79              		.loc 1 139 0
  80 002a 1D4B     		ldr	r3, .L3+12
  81 002c 0022     		mov	r2, #0
  82 002e 5A60     		str	r2, [r3, #4]
 140:../Generated_Code/DrvPwmTimerB.c ****   /* TPM0_C0SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 141:../Generated_Code/DrvPwmTimerB.c ****   TPM0_C0SC = 0x00U;                   /* Clear channel status and control register */
  83              		.loc 1 141 0
  84 0030 1B4B     		ldr	r3, .L3+12
  85 0032 0022     		mov	r2, #0
  86 0034 DA60     		str	r2, [r3, #12]
 142:../Generated_Code/DrvPwmTimerB.c ****   /* TPM0_C1SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 143:../Generated_Code/DrvPwmTimerB.c ****   TPM0_C1SC = 0x00U;                   /* Clear channel status and control register */
  87              		.loc 1 143 0
  88 0036 1A4B     		ldr	r3, .L3+12
  89 0038 0022     		mov	r2, #0
  90 003a 5A61     		str	r2, [r3, #20]
 144:../Generated_Code/DrvPwmTimerB.c ****   /* TPM0_C2SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 145:../Generated_Code/DrvPwmTimerB.c ****   TPM0_C2SC = 0x00U;                   /* Clear channel status and control register */
  91              		.loc 1 145 0
  92 003c 184B     		ldr	r3, .L3+12
  93 003e 0022     		mov	r2, #0
  94 0040 DA61     		str	r2, [r3, #28]
 146:../Generated_Code/DrvPwmTimerB.c ****   /* TPM0_C3SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 147:../Generated_Code/DrvPwmTimerB.c ****   TPM0_C3SC = 0x00U;                   /* Clear channel status and control register */
  95              		.loc 1 147 0
  96 0042 174B     		ldr	r3, .L3+12
  97 0044 0022     		mov	r2, #0
  98 0046 5A62     		str	r2, [r3, #36]
 148:../Generated_Code/DrvPwmTimerB.c ****   /* TPM0_C4SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 149:../Generated_Code/DrvPwmTimerB.c ****   TPM0_C4SC = 0x00U;                   /* Clear channel status and control register */
  99              		.loc 1 149 0
 100 0048 154B     		ldr	r3, .L3+12
 101 004a 0022     		mov	r2, #0
 102 004c DA62     		str	r2, [r3, #44]
 150:../Generated_Code/DrvPwmTimerB.c ****   /* TPM0_C5SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 151:../Generated_Code/DrvPwmTimerB.c ****   TPM0_C5SC = 0x00U;                   /* Clear channel status and control register */
 103              		.loc 1 151 0
 104 004e 144B     		ldr	r3, .L3+12
 105 0050 0022     		mov	r2, #0
 106 0052 5A63     		str	r2, [r3, #52]
 152:../Generated_Code/DrvPwmTimerB.c ****   /* TPM0_MOD: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,MOD=
 153:../Generated_Code/DrvPwmTimerB.c ****   TPM0_MOD = TPM_MOD_MOD(0xFFFF);      /* Set up modulo register */
 107              		.loc 1 153 0
 108 0054 124B     		ldr	r3, .L3+12
 109 0056 134A     		ldr	r2, .L3+16
 110 0058 9A60     		str	r2, [r3, #8]
 154:../Generated_Code/DrvPwmTimerB.c ****   /* TPM0_C1SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 155:../Generated_Code/DrvPwmTimerB.c ****   TPM0_C1SC = (TPM_CnSC_MSB_MASK | TPM_CnSC_ELSB_MASK | TPM_CnSC_ELSA_MASK); /* Set up channel stat
 111              		.loc 1 155 0
 112 005a 114B     		ldr	r3, .L3+12
 113 005c 2C22     		mov	r2, #44
 114 005e 5A61     		str	r2, [r3, #20]
 156:../Generated_Code/DrvPwmTimerB.c ****   /* TPM0_C1V: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,VAL=
 157:../Generated_Code/DrvPwmTimerB.c ****   TPM0_C1V = TPM_CnV_VAL(0xAAAA);      /* Set up channel value register */
 115              		.loc 1 157 0
 116 0060 0F4B     		ldr	r3, .L3+12
 117 0062 114A     		ldr	r2, .L3+20
 118 0064 9A61     		str	r2, [r3, #24]
 158:../Generated_Code/DrvPwmTimerB.c ****   /* PORTD_PCR1: ISF=0,MUX=4 */
 159:../Generated_Code/DrvPwmTimerB.c ****   PORTD_PCR1 = (uint32_t)((PORTD_PCR1 & (uint32_t)~(uint32_t)(
 119              		.loc 1 159 0
 120 0066 114B     		ldr	r3, .L3+24
 121 0068 104A     		ldr	r2, .L3+24
 122 006a 5168     		ldr	r1, [r2, #4]
 123 006c 104A     		ldr	r2, .L3+28
 124 006e 0A40     		and	r2, r1
 125 0070 8021     		mov	r1, #128
 126 0072 C900     		lsl	r1, r1, #3
 127 0074 0A43     		orr	r2, r1
 128 0076 5A60     		str	r2, [r3, #4]
 160:../Generated_Code/DrvPwmTimerB.c ****                 PORT_PCR_ISF_MASK |
 161:../Generated_Code/DrvPwmTimerB.c ****                 PORT_PCR_MUX(0x03)
 162:../Generated_Code/DrvPwmTimerB.c ****                )) | (uint32_t)(
 163:../Generated_Code/DrvPwmTimerB.c ****                 PORT_PCR_MUX(0x04)
 164:../Generated_Code/DrvPwmTimerB.c ****                ));                                                  
 165:../Generated_Code/DrvPwmTimerB.c ****   DeviceDataPrv->Source = TPM_PDD_SYSTEM; /* Store clock source */
 129              		.loc 1 165 0
 130 0078 FB68     		ldr	r3, [r7, #12]
 131 007a 0822     		mov	r2, #8
 132 007c 1A60     		str	r2, [r3]
 166:../Generated_Code/DrvPwmTimerB.c ****   /* TPM0_SC: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,
 167:../Generated_Code/DrvPwmTimerB.c ****   TPM0_SC = (TPM_SC_CMOD(0x01) | TPM_SC_PS(0x01)); /* Set up status and control register */
 133              		.loc 1 167 0
 134 007e 084B     		ldr	r3, .L3+12
 135 0080 0922     		mov	r2, #9
 136 0082 1A60     		str	r2, [r3]
 168:../Generated_Code/DrvPwmTimerB.c ****   /* Registration of the device structure */
 169:../Generated_Code/DrvPwmTimerB.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_DrvPwmTimerB_ID,DeviceDataPrv);
 137              		.loc 1 169 0
 138 0084 0B4B     		ldr	r3, .L3+32
 139 0086 FA68     		ldr	r2, [r7, #12]
 140 0088 DA60     		str	r2, [r3, #12]
 170:../Generated_Code/DrvPwmTimerB.c ****   return ((LDD_TDeviceData *)DeviceDataPrv); /* Return pointer to the device data structure */
 141              		.loc 1 170 0
 142 008a FB68     		ldr	r3, [r7, #12]
 171:../Generated_Code/DrvPwmTimerB.c **** }
 143              		.loc 1 171 0
 144 008c 181C     		mov	r0, r3
 145 008e BD46     		mov	sp, r7
 146 0090 04B0     		add	sp, sp, #16
 147              		@ sp needed for prologue
 148 0092 80BD     		pop	{r7, pc}
 149              	.L4:
 150              		.align	2
 151              	.L3:
 152 0094 00000000 		.word	DeviceDataPrv__DEFAULT_RTOS_ALLOC
 153 0098 00700440 		.word	1074032640
 154 009c 3C100000 		.word	4156
 155 00a0 00800340 		.word	1073971200
 156 00a4 FFFF0000 		.word	65535
 157 00a8 AAAA0000 		.word	43690
 158 00ac 00C00440 		.word	1074053120
 159 00b0 FFF8FFFE 		.word	-16779009
 160 00b4 00000000 		.word	PE_LDD_DeviceDataList
 161              		.cfi_endproc
 162              	.LFE0:
 164              		.section	.text.DrvPwmTimerB_Deinit,"ax",%progbits
 165              		.align	2
 166              		.global	DrvPwmTimerB_Deinit
 167              		.code	16
 168              		.thumb_func
 170              	DrvPwmTimerB_Deinit:
 171              	.LFB1:
 172:../Generated_Code/DrvPwmTimerB.c **** 
 173:../Generated_Code/DrvPwmTimerB.c **** /*
 174:../Generated_Code/DrvPwmTimerB.c **** ** ===================================================================
 175:../Generated_Code/DrvPwmTimerB.c **** **     Method      :  DrvPwmTimerB_Deinit (component TimerUnit_LDD)
 176:../Generated_Code/DrvPwmTimerB.c **** **
 177:../Generated_Code/DrvPwmTimerB.c **** **     Description :
 178:../Generated_Code/DrvPwmTimerB.c **** **         Deinitializes the device. Switches off the device, frees the
 179:../Generated_Code/DrvPwmTimerB.c **** **         device data structure memory, interrupts vectors, etc.
 180:../Generated_Code/DrvPwmTimerB.c **** **     Parameters  :
 181:../Generated_Code/DrvPwmTimerB.c **** **         NAME            - DESCRIPTION
 182:../Generated_Code/DrvPwmTimerB.c **** **       * DeviceDataPtr   - Device data structure
 183:../Generated_Code/DrvPwmTimerB.c **** **                           pointer returned by Init method
 184:../Generated_Code/DrvPwmTimerB.c **** **     Returns     : Nothing
 185:../Generated_Code/DrvPwmTimerB.c **** ** ===================================================================
 186:../Generated_Code/DrvPwmTimerB.c **** */
 187:../Generated_Code/DrvPwmTimerB.c **** void DrvPwmTimerB_Deinit(LDD_TDeviceData *DeviceDataPtr)
 188:../Generated_Code/DrvPwmTimerB.c **** {
 172              		.loc 1 188 0
 173              		.cfi_startproc
 174 0000 80B5     		push	{r7, lr}
 175              	.LCFI3:
 176              		.cfi_def_cfa_offset 8
 177              		.cfi_offset 7, -8
 178              		.cfi_offset 14, -4
 179 0002 84B0     		sub	sp, sp, #16
 180              	.LCFI4:
 181              		.cfi_def_cfa_offset 24
 182 0004 00AF     		add	r7, sp, #0
 183              	.LCFI5:
 184              		.cfi_def_cfa_register 7
 185 0006 7860     		str	r0, [r7, #4]
 189:../Generated_Code/DrvPwmTimerB.c ****   DrvPwmTimerB_TDeviceData *DeviceDataPrv = (DrvPwmTimerB_TDeviceData *)DeviceDataPtr;
 186              		.loc 1 189 0
 187 0008 7B68     		ldr	r3, [r7, #4]
 188 000a FB60     		str	r3, [r7, #12]
 190:../Generated_Code/DrvPwmTimerB.c **** 
 191:../Generated_Code/DrvPwmTimerB.c ****   (void)DeviceDataPrv;
 192:../Generated_Code/DrvPwmTimerB.c ****   TPM_PDD_SelectPrescalerSource(TPM0_BASE_PTR, TPM_PDD_DISABLED);
 189              		.loc 1 192 0
 190 000c 054B     		ldr	r3, .L6
 191 000e 054A     		ldr	r2, .L6
 192 0010 1268     		ldr	r2, [r2]
 193 0012 9821     		mov	r1, #152
 194 0014 8A43     		bic	r2, r1
 195 0016 1A60     		str	r2, [r3]
 193:../Generated_Code/DrvPwmTimerB.c ****   /* Unregistration of the device structure */
 194:../Generated_Code/DrvPwmTimerB.c ****   PE_LDD_UnregisterDeviceStructure(PE_LDD_COMPONENT_DrvPwmTimerB_ID);
 196              		.loc 1 194 0
 197 0018 034B     		ldr	r3, .L6+4
 198 001a 0022     		mov	r2, #0
 199 001c DA60     		str	r2, [r3, #12]
 195:../Generated_Code/DrvPwmTimerB.c ****   /* Deallocation of the device structure */
 196:../Generated_Code/DrvPwmTimerB.c ****   /* {MQXLite RTOS Adapter} Driver memory deallocation: Dynamic allocation is simulated, no dealloc
 197:../Generated_Code/DrvPwmTimerB.c **** }
 200              		.loc 1 197 0
 201 001e BD46     		mov	sp, r7
 202 0020 04B0     		add	sp, sp, #16
 203              		@ sp needed for prologue
 204 0022 80BD     		pop	{r7, pc}
 205              	.L7:
 206              		.align	2
 207              	.L6:
 208 0024 00800340 		.word	1073971200
 209 0028 00000000 		.word	PE_LDD_DeviceDataList
 210              		.cfi_endproc
 211              	.LFE1:
 213              		.section	.text.DrvPwmTimerB_Enable,"ax",%progbits
 214              		.align	2
 215              		.global	DrvPwmTimerB_Enable
 216              		.code	16
 217              		.thumb_func
 219              	DrvPwmTimerB_Enable:
 220              	.LFB2:
 198:../Generated_Code/DrvPwmTimerB.c **** 
 199:../Generated_Code/DrvPwmTimerB.c **** /*
 200:../Generated_Code/DrvPwmTimerB.c **** ** ===================================================================
 201:../Generated_Code/DrvPwmTimerB.c **** **     Method      :  DrvPwmTimerB_Enable (component TimerUnit_LDD)
 202:../Generated_Code/DrvPwmTimerB.c **** **
 203:../Generated_Code/DrvPwmTimerB.c **** **     Description :
 204:../Generated_Code/DrvPwmTimerB.c **** **         Enables the component - it starts the signal generation.
 205:../Generated_Code/DrvPwmTimerB.c **** **         Events may be generated (see SetEventMask). The method is
 206:../Generated_Code/DrvPwmTimerB.c **** **         not available if the counter can't be disabled/enabled by HW.
 207:../Generated_Code/DrvPwmTimerB.c **** **     Parameters  :
 208:../Generated_Code/DrvPwmTimerB.c **** **         NAME            - DESCRIPTION
 209:../Generated_Code/DrvPwmTimerB.c **** **       * DeviceDataPtr   - Device data structure
 210:../Generated_Code/DrvPwmTimerB.c **** **                           pointer returned by <Init> method.
 211:../Generated_Code/DrvPwmTimerB.c **** **     Returns     :
 212:../Generated_Code/DrvPwmTimerB.c **** **         ---             - Error code, possible codes:
 213:../Generated_Code/DrvPwmTimerB.c **** **                           ERR_OK - OK
 214:../Generated_Code/DrvPwmTimerB.c **** **                           ERR_SPEED - The component does not work in
 215:../Generated_Code/DrvPwmTimerB.c **** **                           the active clock configuration
 216:../Generated_Code/DrvPwmTimerB.c **** ** ===================================================================
 217:../Generated_Code/DrvPwmTimerB.c **** */
 218:../Generated_Code/DrvPwmTimerB.c **** LDD_TError DrvPwmTimerB_Enable(LDD_TDeviceData *DeviceDataPtr)
 219:../Generated_Code/DrvPwmTimerB.c **** {
 221              		.loc 1 219 0
 222              		.cfi_startproc
 223 0000 80B5     		push	{r7, lr}
 224              	.LCFI6:
 225              		.cfi_def_cfa_offset 8
 226              		.cfi_offset 7, -8
 227              		.cfi_offset 14, -4
 228 0002 84B0     		sub	sp, sp, #16
 229              	.LCFI7:
 230              		.cfi_def_cfa_offset 24
 231 0004 00AF     		add	r7, sp, #0
 232              	.LCFI8:
 233              		.cfi_def_cfa_register 7
 234 0006 7860     		str	r0, [r7, #4]
 220:../Generated_Code/DrvPwmTimerB.c ****   DrvPwmTimerB_TDeviceData *DeviceDataPrv = (DrvPwmTimerB_TDeviceData *)DeviceDataPtr;
 235              		.loc 1 220 0
 236 0008 7B68     		ldr	r3, [r7, #4]
 237 000a FB60     		str	r3, [r7, #12]
 221:../Generated_Code/DrvPwmTimerB.c **** 
 222:../Generated_Code/DrvPwmTimerB.c ****   TPM_PDD_SelectPrescalerSource(TPM0_BASE_PTR, DeviceDataPrv->Source); /* Enable the device */
 238              		.loc 1 222 0
 239 000c 074B     		ldr	r3, .L10
 240 000e 074A     		ldr	r2, .L10
 241 0010 1268     		ldr	r2, [r2]
 242 0012 9821     		mov	r1, #152
 243 0014 101C     		mov	r0, r2
 244 0016 8843     		bic	r0, r1
 245 0018 011C     		mov	r1, r0
 246 001a FA68     		ldr	r2, [r7, #12]
 247 001c 1268     		ldr	r2, [r2]
 248 001e 0A43     		orr	r2, r1
 249 0020 1A60     		str	r2, [r3]
 223:../Generated_Code/DrvPwmTimerB.c ****   return ERR_OK;
 250              		.loc 1 223 0
 251 0022 0023     		mov	r3, #0
 224:../Generated_Code/DrvPwmTimerB.c **** }
 252              		.loc 1 224 0
 253 0024 181C     		mov	r0, r3
 254 0026 BD46     		mov	sp, r7
 255 0028 04B0     		add	sp, sp, #16
 256              		@ sp needed for prologue
 257 002a 80BD     		pop	{r7, pc}
 258              	.L11:
 259              		.align	2
 260              	.L10:
 261 002c 00800340 		.word	1073971200
 262              		.cfi_endproc
 263              	.LFE2:
 265              		.section	.text.DrvPwmTimerB_Disable,"ax",%progbits
 266              		.align	2
 267              		.global	DrvPwmTimerB_Disable
 268              		.code	16
 269              		.thumb_func
 271              	DrvPwmTimerB_Disable:
 272              	.LFB3:
 225:../Generated_Code/DrvPwmTimerB.c **** 
 226:../Generated_Code/DrvPwmTimerB.c **** /*
 227:../Generated_Code/DrvPwmTimerB.c **** ** ===================================================================
 228:../Generated_Code/DrvPwmTimerB.c **** **     Method      :  DrvPwmTimerB_Disable (component TimerUnit_LDD)
 229:../Generated_Code/DrvPwmTimerB.c **** **
 230:../Generated_Code/DrvPwmTimerB.c **** **     Description :
 231:../Generated_Code/DrvPwmTimerB.c **** **         Disables the component - it stops signal generation and
 232:../Generated_Code/DrvPwmTimerB.c **** **         events calling. The method is not available if the counter
 233:../Generated_Code/DrvPwmTimerB.c **** **         can't be disabled/enabled by HW.
 234:../Generated_Code/DrvPwmTimerB.c **** **     Parameters  :
 235:../Generated_Code/DrvPwmTimerB.c **** **         NAME            - DESCRIPTION
 236:../Generated_Code/DrvPwmTimerB.c **** **       * DeviceDataPtr   - Device data structure
 237:../Generated_Code/DrvPwmTimerB.c **** **                           pointer returned by <Init> method.
 238:../Generated_Code/DrvPwmTimerB.c **** **     Returns     :
 239:../Generated_Code/DrvPwmTimerB.c **** **         ---             - Error code, possible codes:
 240:../Generated_Code/DrvPwmTimerB.c **** **                           ERR_OK - OK
 241:../Generated_Code/DrvPwmTimerB.c **** **                           ERR_SPEED - The component does not work in
 242:../Generated_Code/DrvPwmTimerB.c **** **                           the active clock configuration
 243:../Generated_Code/DrvPwmTimerB.c **** ** ===================================================================
 244:../Generated_Code/DrvPwmTimerB.c **** */
 245:../Generated_Code/DrvPwmTimerB.c **** LDD_TError DrvPwmTimerB_Disable(LDD_TDeviceData *DeviceDataPtr)
 246:../Generated_Code/DrvPwmTimerB.c **** {
 273              		.loc 1 246 0
 274              		.cfi_startproc
 275 0000 80B5     		push	{r7, lr}
 276              	.LCFI9:
 277              		.cfi_def_cfa_offset 8
 278              		.cfi_offset 7, -8
 279              		.cfi_offset 14, -4
 280 0002 82B0     		sub	sp, sp, #8
 281              	.LCFI10:
 282              		.cfi_def_cfa_offset 16
 283 0004 00AF     		add	r7, sp, #0
 284              	.LCFI11:
 285              		.cfi_def_cfa_register 7
 286 0006 7860     		str	r0, [r7, #4]
 247:../Generated_Code/DrvPwmTimerB.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 248:../Generated_Code/DrvPwmTimerB.c ****   TPM_PDD_SelectPrescalerSource(TPM0_BASE_PTR, TPM_PDD_DISABLED);
 287              		.loc 1 248 0
 288 0008 054B     		ldr	r3, .L14
 289 000a 054A     		ldr	r2, .L14
 290 000c 1268     		ldr	r2, [r2]
 291 000e 9821     		mov	r1, #152
 292 0010 8A43     		bic	r2, r1
 293 0012 1A60     		str	r2, [r3]
 249:../Generated_Code/DrvPwmTimerB.c ****   return ERR_OK;
 294              		.loc 1 249 0
 295 0014 0023     		mov	r3, #0
 250:../Generated_Code/DrvPwmTimerB.c **** }
 296              		.loc 1 250 0
 297 0016 181C     		mov	r0, r3
 298 0018 BD46     		mov	sp, r7
 299 001a 02B0     		add	sp, sp, #8
 300              		@ sp needed for prologue
 301 001c 80BD     		pop	{r7, pc}
 302              	.L15:
 303 001e C046     		.align	2
 304              	.L14:
 305 0020 00800340 		.word	1073971200
 306              		.cfi_endproc
 307              	.LFE3:
 309              		.section	.text.DrvPwmTimerB_GetCounterValue,"ax",%progbits
 310              		.align	2
 311              		.global	DrvPwmTimerB_GetCounterValue
 312              		.code	16
 313              		.thumb_func
 315              	DrvPwmTimerB_GetCounterValue:
 316              	.LFB4:
 251:../Generated_Code/DrvPwmTimerB.c **** 
 252:../Generated_Code/DrvPwmTimerB.c **** /*
 253:../Generated_Code/DrvPwmTimerB.c **** ** ===================================================================
 254:../Generated_Code/DrvPwmTimerB.c **** **     Method      :  DrvPwmTimerB_GetCounterValue (component TimerUnit_LDD)
 255:../Generated_Code/DrvPwmTimerB.c **** **
 256:../Generated_Code/DrvPwmTimerB.c **** **     Description :
 257:../Generated_Code/DrvPwmTimerB.c **** **         Returns the content of counter register. This method can be
 258:../Generated_Code/DrvPwmTimerB.c **** **         used both if counter is enabled and if counter is disabled.
 259:../Generated_Code/DrvPwmTimerB.c **** **         The method is not available if HW doesn't allow reading of
 260:../Generated_Code/DrvPwmTimerB.c **** **         the counter.
 261:../Generated_Code/DrvPwmTimerB.c **** **     Parameters  :
 262:../Generated_Code/DrvPwmTimerB.c **** **         NAME            - DESCRIPTION
 263:../Generated_Code/DrvPwmTimerB.c **** **       * DeviceDataPtr   - Device data structure
 264:../Generated_Code/DrvPwmTimerB.c **** **                           pointer returned by <Init> method.
 265:../Generated_Code/DrvPwmTimerB.c **** **     Returns     :
 266:../Generated_Code/DrvPwmTimerB.c **** **         ---             - Counter value (number of counted ticks).
 267:../Generated_Code/DrvPwmTimerB.c **** ** ===================================================================
 268:../Generated_Code/DrvPwmTimerB.c **** */
 269:../Generated_Code/DrvPwmTimerB.c **** DrvPwmTimerB_TValueType DrvPwmTimerB_GetCounterValue(LDD_TDeviceData *DeviceDataPtr)
 270:../Generated_Code/DrvPwmTimerB.c **** {
 317              		.loc 1 270 0
 318              		.cfi_startproc
 319 0000 80B5     		push	{r7, lr}
 320              	.LCFI12:
 321              		.cfi_def_cfa_offset 8
 322              		.cfi_offset 7, -8
 323              		.cfi_offset 14, -4
 324 0002 82B0     		sub	sp, sp, #8
 325              	.LCFI13:
 326              		.cfi_def_cfa_offset 16
 327 0004 00AF     		add	r7, sp, #0
 328              	.LCFI14:
 329              		.cfi_def_cfa_register 7
 330 0006 7860     		str	r0, [r7, #4]
 271:../Generated_Code/DrvPwmTimerB.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 272:../Generated_Code/DrvPwmTimerB.c ****   return (DrvPwmTimerB_TValueType)TPM_PDD_ReadCounterReg(TPM0_BASE_PTR);
 331              		.loc 1 272 0
 332 0008 024B     		ldr	r3, .L18
 333 000a 5B68     		ldr	r3, [r3, #4]
 273:../Generated_Code/DrvPwmTimerB.c **** }
 334              		.loc 1 273 0
 335 000c 181C     		mov	r0, r3
 336 000e BD46     		mov	sp, r7
 337 0010 02B0     		add	sp, sp, #8
 338              		@ sp needed for prologue
 339 0012 80BD     		pop	{r7, pc}
 340              	.L19:
 341              		.align	2
 342              	.L18:
 343 0014 00800340 		.word	1073971200
 344              		.cfi_endproc
 345              	.LFE4:
 347              		.section	.text.DrvPwmTimerB_SetOffsetTicks,"ax",%progbits
 348              		.align	2
 349              		.global	DrvPwmTimerB_SetOffsetTicks
 350              		.code	16
 351              		.thumb_func
 353              	DrvPwmTimerB_SetOffsetTicks:
 354              	.LFB5:
 274:../Generated_Code/DrvPwmTimerB.c **** 
 275:../Generated_Code/DrvPwmTimerB.c **** /*
 276:../Generated_Code/DrvPwmTimerB.c **** ** ===================================================================
 277:../Generated_Code/DrvPwmTimerB.c **** **     Method      :  DrvPwmTimerB_SetOffsetTicks (component TimerUnit_LDD)
 278:../Generated_Code/DrvPwmTimerB.c **** **
 279:../Generated_Code/DrvPwmTimerB.c **** **     Description :
 280:../Generated_Code/DrvPwmTimerB.c **** **         Sets the new offset value to channel specified by the
 281:../Generated_Code/DrvPwmTimerB.c **** **         parameter ChannelIdx. It is user responsibility to use value
 282:../Generated_Code/DrvPwmTimerB.c **** **         below selected period. This method is available when at
 283:../Generated_Code/DrvPwmTimerB.c **** **         least one channel is configured.
 284:../Generated_Code/DrvPwmTimerB.c **** **     Parameters  :
 285:../Generated_Code/DrvPwmTimerB.c **** **         NAME            - DESCRIPTION
 286:../Generated_Code/DrvPwmTimerB.c **** **       * DeviceDataPtr   - Device data structure
 287:../Generated_Code/DrvPwmTimerB.c **** **                           pointer returned by <Init> method.
 288:../Generated_Code/DrvPwmTimerB.c **** **         ChannelIdx      - Index of the component
 289:../Generated_Code/DrvPwmTimerB.c **** **                           channel.
 290:../Generated_Code/DrvPwmTimerB.c **** **         Ticks           - Number of counter ticks to compare
 291:../Generated_Code/DrvPwmTimerB.c **** **                           match.
 292:../Generated_Code/DrvPwmTimerB.c **** **     Returns     :
 293:../Generated_Code/DrvPwmTimerB.c **** **         ---             - Error code, possible codes:
 294:../Generated_Code/DrvPwmTimerB.c **** **                           ERR_OK - OK 
 295:../Generated_Code/DrvPwmTimerB.c **** **                           ERR_PARAM_INDEX - ChannelIdx parameter is
 296:../Generated_Code/DrvPwmTimerB.c **** **                           out of possible range.
 297:../Generated_Code/DrvPwmTimerB.c **** **                           ERR_NOTAVAIL -  The compare mode is not
 298:../Generated_Code/DrvPwmTimerB.c **** **                           selected for selected channel
 299:../Generated_Code/DrvPwmTimerB.c **** **                           ERR_PARAM_TICKS - Ticks parameter is out of
 300:../Generated_Code/DrvPwmTimerB.c **** **                           possible range.
 301:../Generated_Code/DrvPwmTimerB.c **** **                           ERR_SPEED - The component does not work in
 302:../Generated_Code/DrvPwmTimerB.c **** **                           the active clock configuration
 303:../Generated_Code/DrvPwmTimerB.c **** ** ===================================================================
 304:../Generated_Code/DrvPwmTimerB.c **** */
 305:../Generated_Code/DrvPwmTimerB.c **** LDD_TError DrvPwmTimerB_SetOffsetTicks(LDD_TDeviceData *DeviceDataPtr, uint8_t ChannelIdx, DrvPwmTi
 306:../Generated_Code/DrvPwmTimerB.c **** {
 355              		.loc 1 306 0
 356              		.cfi_startproc
 357 0000 80B5     		push	{r7, lr}
 358              	.LCFI15:
 359              		.cfi_def_cfa_offset 8
 360              		.cfi_offset 7, -8
 361              		.cfi_offset 14, -4
 362 0002 84B0     		sub	sp, sp, #16
 363              	.LCFI16:
 364              		.cfi_def_cfa_offset 24
 365 0004 00AF     		add	r7, sp, #0
 366              	.LCFI17:
 367              		.cfi_def_cfa_register 7
 368 0006 F860     		str	r0, [r7, #12]
 369 0008 7A60     		str	r2, [r7, #4]
 370 000a 3B1C     		mov	r3, r7
 371 000c 0B33     		add	r3, r3, #11
 372 000e 0A1C     		add	r2, r1, #0
 373 0010 1A70     		strb	r2, [r3]
 307:../Generated_Code/DrvPwmTimerB.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 308:../Generated_Code/DrvPwmTimerB.c ****   /* Parameter test - this test can be disabled by setting the "Ignore range checking"
 309:../Generated_Code/DrvPwmTimerB.c ****      property to the "yes" value in the "Configuration inspector" */
 310:../Generated_Code/DrvPwmTimerB.c ****   if (ChannelIdx > LAST_CHANNEL) {     /* Is the channel index out of range? */
 374              		.loc 1 310 0
 375 0012 3B1C     		mov	r3, r7
 376 0014 0B33     		add	r3, r3, #11
 377 0016 1B78     		ldrb	r3, [r3]
 378 0018 002B     		cmp	r3, #0
 379 001a 01D0     		beq	.L21
 311:../Generated_Code/DrvPwmTimerB.c ****     return ERR_PARAM_INDEX;            /* If yes then error */
 380              		.loc 1 311 0
 381 001c 8223     		mov	r3, #130
 382 001e 1BE0     		b	.L22
 383              	.L21:
 312:../Generated_Code/DrvPwmTimerB.c ****   }
 313:../Generated_Code/DrvPwmTimerB.c ****   if ((ChannelMode[ChannelIdx]) != 0U) { /* Is the channel in compare mode? */
 384              		.loc 1 313 0
 385 0020 3B1C     		mov	r3, r7
 386 0022 0B33     		add	r3, r3, #11
 387 0024 1B78     		ldrb	r3, [r3]
 388 0026 0E4A     		ldr	r2, .L25
 389 0028 D35C     		ldrb	r3, [r2, r3]
 390 002a 002B     		cmp	r3, #0
 391 002c 01D0     		beq	.L23
 314:../Generated_Code/DrvPwmTimerB.c ****     return ERR_NOTAVAIL;               /* If not then error */
 392              		.loc 1 314 0
 393 002e 0923     		mov	r3, #9
 394 0030 12E0     		b	.L22
 395              	.L23:
 315:../Generated_Code/DrvPwmTimerB.c ****   }
 316:../Generated_Code/DrvPwmTimerB.c ****   TPM_PDD_WriteChannelValueReg(TPM0_BASE_PTR, ChannelDevice[ChannelIdx], (uint16_t)Ticks);
 396              		.loc 1 316 0
 397 0032 0C49     		ldr	r1, .L25+4
 398 0034 3B1C     		mov	r3, r7
 399 0036 0B33     		add	r3, r3, #11
 400 0038 1B78     		ldrb	r3, [r3]
 401 003a 0B4A     		ldr	r2, .L25+8
 402 003c D35C     		ldrb	r3, [r2, r3]
 403 003e 7A68     		ldr	r2, [r7, #4]
 404 0040 92B2     		uxth	r2, r2
 405 0042 0133     		add	r3, r3, #1
 406 0044 DB00     		lsl	r3, r3, #3
 407 0046 CB18     		add	r3, r1, r3
 408 0048 9A60     		str	r2, [r3, #8]
 317:../Generated_Code/DrvPwmTimerB.c ****   if (Ticks > 65535U) {                /* Was the given value greater than counter width? */
 409              		.loc 1 317 0
 410 004a 7A68     		ldr	r2, [r7, #4]
 411 004c 074B     		ldr	r3, .L25+12
 412 004e 9A42     		cmp	r2, r3
 413 0050 01D9     		bls	.L24
 318:../Generated_Code/DrvPwmTimerB.c ****     return ERR_PARAM_TICKS;            /* If yes then truncation of user data to 16 bits is reporte
 414              		.loc 1 318 0
 415 0052 9823     		mov	r3, #152
 416 0054 00E0     		b	.L22
 417              	.L24:
 319:../Generated_Code/DrvPwmTimerB.c ****   }
 320:../Generated_Code/DrvPwmTimerB.c ****   return ERR_OK;                       /* OK */
 418              		.loc 1 320 0
 419 0056 0023     		mov	r3, #0
 420              	.L22:
 321:../Generated_Code/DrvPwmTimerB.c **** }
 421              		.loc 1 321 0
 422 0058 181C     		mov	r0, r3
 423 005a BD46     		mov	sp, r7
 424 005c 04B0     		add	sp, sp, #16
 425              		@ sp needed for prologue
 426 005e 80BD     		pop	{r7, pc}
 427              	.L26:
 428              		.align	2
 429              	.L25:
 430 0060 00000000 		.word	ChannelMode
 431 0064 00800340 		.word	1073971200
 432 0068 00000000 		.word	ChannelDevice
 433 006c FFFF0000 		.word	65535
 434              		.cfi_endproc
 435              	.LFE5:
 437              		.section	.text.DrvPwmTimerB_GetOffsetTicks,"ax",%progbits
 438              		.align	2
 439              		.global	DrvPwmTimerB_GetOffsetTicks
 440              		.code	16
 441              		.thumb_func
 443              	DrvPwmTimerB_GetOffsetTicks:
 444              	.LFB6:
 322:../Generated_Code/DrvPwmTimerB.c **** 
 323:../Generated_Code/DrvPwmTimerB.c **** /*
 324:../Generated_Code/DrvPwmTimerB.c **** ** ===================================================================
 325:../Generated_Code/DrvPwmTimerB.c **** **     Method      :  DrvPwmTimerB_GetOffsetTicks (component TimerUnit_LDD)
 326:../Generated_Code/DrvPwmTimerB.c **** **
 327:../Generated_Code/DrvPwmTimerB.c **** **     Description :
 328:../Generated_Code/DrvPwmTimerB.c **** **         Returns the number of counter ticks to compare match channel
 329:../Generated_Code/DrvPwmTimerB.c **** **         specified by the parameter ChannelIdx. See also method
 330:../Generated_Code/DrvPwmTimerB.c **** **         <SetOffsetTicks>. This method is available when at least one
 331:../Generated_Code/DrvPwmTimerB.c **** **         channel is configured.
 332:../Generated_Code/DrvPwmTimerB.c **** **     Parameters  :
 333:../Generated_Code/DrvPwmTimerB.c **** **         NAME            - DESCRIPTION
 334:../Generated_Code/DrvPwmTimerB.c **** **       * DeviceDataPtr   - Device data structure
 335:../Generated_Code/DrvPwmTimerB.c **** **                           pointer returned by <Init> method.
 336:../Generated_Code/DrvPwmTimerB.c **** **         ChannelIdx      - Index of the component
 337:../Generated_Code/DrvPwmTimerB.c **** **                           channel.
 338:../Generated_Code/DrvPwmTimerB.c **** **       * TicksPtr        - Pointer to return value of the
 339:../Generated_Code/DrvPwmTimerB.c **** **                           number of counter ticks to compare match.
 340:../Generated_Code/DrvPwmTimerB.c **** **     Returns     :
 341:../Generated_Code/DrvPwmTimerB.c **** **         ---             - Error code, possible codes:
 342:../Generated_Code/DrvPwmTimerB.c **** **                           ERR_OK - OK 
 343:../Generated_Code/DrvPwmTimerB.c **** **                           ERR_PARAM_INDEX - ChannelIdx parameter is
 344:../Generated_Code/DrvPwmTimerB.c **** **                           out of possible range.
 345:../Generated_Code/DrvPwmTimerB.c **** **                           ERR_NOTAVAIL -  The compare mode is not
 346:../Generated_Code/DrvPwmTimerB.c **** **                           selected for selected channel.
 347:../Generated_Code/DrvPwmTimerB.c **** **                           ERR_SPEED - The component does not work in
 348:../Generated_Code/DrvPwmTimerB.c **** **                           the active clock configuration
 349:../Generated_Code/DrvPwmTimerB.c **** ** ===================================================================
 350:../Generated_Code/DrvPwmTimerB.c **** */
 351:../Generated_Code/DrvPwmTimerB.c **** LDD_TError DrvPwmTimerB_GetOffsetTicks(LDD_TDeviceData *DeviceDataPtr, uint8_t ChannelIdx, DrvPwmTi
 352:../Generated_Code/DrvPwmTimerB.c **** {
 445              		.loc 1 352 0
 446              		.cfi_startproc
 447 0000 80B5     		push	{r7, lr}
 448              	.LCFI18:
 449              		.cfi_def_cfa_offset 8
 450              		.cfi_offset 7, -8
 451              		.cfi_offset 14, -4
 452 0002 84B0     		sub	sp, sp, #16
 453              	.LCFI19:
 454              		.cfi_def_cfa_offset 24
 455 0004 00AF     		add	r7, sp, #0
 456              	.LCFI20:
 457              		.cfi_def_cfa_register 7
 458 0006 F860     		str	r0, [r7, #12]
 459 0008 7A60     		str	r2, [r7, #4]
 460 000a 3B1C     		mov	r3, r7
 461 000c 0B33     		add	r3, r3, #11
 462 000e 0A1C     		add	r2, r1, #0
 463 0010 1A70     		strb	r2, [r3]
 353:../Generated_Code/DrvPwmTimerB.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 354:../Generated_Code/DrvPwmTimerB.c ****   /* Parameter test - this test can be disabled by setting the "Ignore range checking"
 355:../Generated_Code/DrvPwmTimerB.c ****      property to the "yes" value in the "Configuration inspector" */
 356:../Generated_Code/DrvPwmTimerB.c ****   if (ChannelIdx > LAST_CHANNEL) {     /* Is the channel index out of range? */
 464              		.loc 1 356 0
 465 0012 3B1C     		mov	r3, r7
 466 0014 0B33     		add	r3, r3, #11
 467 0016 1B78     		ldrb	r3, [r3]
 468 0018 002B     		cmp	r3, #0
 469 001a 01D0     		beq	.L28
 357:../Generated_Code/DrvPwmTimerB.c ****     return ERR_PARAM_INDEX;            /* If yes then error */
 470              		.loc 1 357 0
 471 001c 8223     		mov	r3, #130
 472 001e 15E0     		b	.L29
 473              	.L28:
 358:../Generated_Code/DrvPwmTimerB.c ****   }
 359:../Generated_Code/DrvPwmTimerB.c ****   if ((ChannelMode[ChannelIdx]) != 0U) { /* Is the channel in compare mode? */
 474              		.loc 1 359 0
 475 0020 3B1C     		mov	r3, r7
 476 0022 0B33     		add	r3, r3, #11
 477 0024 1B78     		ldrb	r3, [r3]
 478 0026 0B4A     		ldr	r2, .L31
 479 0028 D35C     		ldrb	r3, [r2, r3]
 480 002a 002B     		cmp	r3, #0
 481 002c 01D0     		beq	.L30
 360:../Generated_Code/DrvPwmTimerB.c ****     return ERR_NOTAVAIL;               /* If not then error */
 482              		.loc 1 360 0
 483 002e 0923     		mov	r3, #9
 484 0030 0CE0     		b	.L29
 485              	.L30:
 361:../Generated_Code/DrvPwmTimerB.c ****   }
 362:../Generated_Code/DrvPwmTimerB.c ****   *TicksPtr = (DrvPwmTimerB_TValueType)(TPM_PDD_ReadChannelValueReg(TPM0_BASE_PTR, ChannelDevice[Ch
 486              		.loc 1 362 0
 487 0032 094A     		ldr	r2, .L31+4
 488 0034 3B1C     		mov	r3, r7
 489 0036 0B33     		add	r3, r3, #11
 490 0038 1B78     		ldrb	r3, [r3]
 491 003a 0849     		ldr	r1, .L31+8
 492 003c CB5C     		ldrb	r3, [r1, r3]
 493 003e 0133     		add	r3, r3, #1
 494 0040 DB00     		lsl	r3, r3, #3
 495 0042 D318     		add	r3, r2, r3
 496 0044 9A68     		ldr	r2, [r3, #8]
 497 0046 7B68     		ldr	r3, [r7, #4]
 498 0048 1A60     		str	r2, [r3]
 363:../Generated_Code/DrvPwmTimerB.c ****   return ERR_OK;                       /* OK */
 499              		.loc 1 363 0
 500 004a 0023     		mov	r3, #0
 501              	.L29:
 364:../Generated_Code/DrvPwmTimerB.c **** }
 502              		.loc 1 364 0
 503 004c 181C     		mov	r0, r3
 504 004e BD46     		mov	sp, r7
 505 0050 04B0     		add	sp, sp, #16
 506              		@ sp needed for prologue
 507 0052 80BD     		pop	{r7, pc}
 508              	.L32:
 509              		.align	2
 510              	.L31:
 511 0054 00000000 		.word	ChannelMode
 512 0058 00800340 		.word	1073971200
 513 005c 00000000 		.word	ChannelDevice
 514              		.cfi_endproc
 515              	.LFE6:
 517              		.text
 518              	.Letext0:
 519              		.file 2 "C:/Freescale/CW MCU v10.3/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 520              		.file 3 "../Generated_Code/IO_Map.h"
 521              		.file 4 "../Generated_Code/PE_LDD.h"
 522              		.file 5 "E:/CW103_Work_Space/Mqx_Lite_Test/MQXLITE/psp/cortex_m/psptypes.h"
 523              		.file 6 "../Generated_Code/DrvPwmTimerB.h"
DEFINED SYMBOLS
                            *ABS*:00000000 DrvPwmTimerB.c
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:18     .rodata.ChannelDevice:00000000 $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:21     .rodata.ChannelDevice:00000000 ChannelDevice
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:24     .rodata.ChannelMode:00000000 $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:27     .rodata.ChannelMode:00000000 ChannelMode
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:30     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:33     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:36     .text.DrvPwmTimerB_Init:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:41     .text.DrvPwmTimerB_Init:00000000 DrvPwmTimerB_Init
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:152    .text.DrvPwmTimerB_Init:00000094 $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:165    .text.DrvPwmTimerB_Deinit:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:170    .text.DrvPwmTimerB_Deinit:00000000 DrvPwmTimerB_Deinit
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:208    .text.DrvPwmTimerB_Deinit:00000024 $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:214    .text.DrvPwmTimerB_Enable:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:219    .text.DrvPwmTimerB_Enable:00000000 DrvPwmTimerB_Enable
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:261    .text.DrvPwmTimerB_Enable:0000002c $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:266    .text.DrvPwmTimerB_Disable:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:271    .text.DrvPwmTimerB_Disable:00000000 DrvPwmTimerB_Disable
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:305    .text.DrvPwmTimerB_Disable:00000020 $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:310    .text.DrvPwmTimerB_GetCounterValue:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:315    .text.DrvPwmTimerB_GetCounterValue:00000000 DrvPwmTimerB_GetCounterValue
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:343    .text.DrvPwmTimerB_GetCounterValue:00000014 $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:348    .text.DrvPwmTimerB_SetOffsetTicks:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:353    .text.DrvPwmTimerB_SetOffsetTicks:00000000 DrvPwmTimerB_SetOffsetTicks
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:430    .text.DrvPwmTimerB_SetOffsetTicks:00000060 $d
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:438    .text.DrvPwmTimerB_GetOffsetTicks:00000000 $t
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:443    .text.DrvPwmTimerB_GetOffsetTicks:00000000 DrvPwmTimerB_GetOffsetTicks
C:\DOCUME~1\SNAKUL~1.DEL\LOCALS~1\Temp\ccR5CySc.s:511    .text.DrvPwmTimerB_GetOffsetTicks:00000054 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
PE_LDD_DeviceDataList
